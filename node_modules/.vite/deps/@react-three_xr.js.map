{
  "version": 3,
  "sources": ["../../@react-three/xr/dist/space.js", "../../three/src/math/MathUtils.js", "../../@pmndrs/xr/dist/controller/gamepad.js", "../../three/examples/jsm/utils/BufferGeometryUtils.js", "../../three/examples/jsm/loaders/GLTFLoader.js", "../../@pmndrs/xr/dist/hand/pose.js", "../../three/examples/jsm/utils/SkeletonUtils.js", "../../@pmndrs/xr/dist/hand/model.js", "../../@pmndrs/xr/dist/hand/state.js", "../../@pmndrs/xr/dist/hand/visual.js", "../../@pmndrs/xr/dist/input.js", "../../@pmndrs/xr/dist/visible.js", "../../@pmndrs/xr/dist/pointer/cursor.js", "../../@pmndrs/xr/dist/pointer/ray.js", "../../@pmndrs/xr/dist/pointer/event.js", "../../@pmndrs/xr/dist/pointer/default.js", "../../@pmndrs/xr/dist/space.js", "../../@pmndrs/xr/dist/init.js", "../../@pmndrs/xr/dist/store.js", "../../@pmndrs/xr/dist/vanilla/pointer.js", "../../@pmndrs/xr/dist/controller/model.js", "../../@pmndrs/xr/dist/controller/visual.js", "../../@pmndrs/pointer-events/dist/utils.js", "../../@pmndrs/pointer-events/dist/event.js", "../../@pmndrs/pointer-events/dist/intersections/utils.js", "../../@pmndrs/pointer-events/dist/pointer.js", "../../@pmndrs/pointer-events/dist/intersections/intersector.js", "../../@pmndrs/pointer-events/dist/intersections/lines.js", "../../@pmndrs/pointer-events/dist/intersections/ray.js", "../../@pmndrs/pointer-events/dist/intersections/sphere.js", "../../@pmndrs/pointer-events/dist/pointer/grab.js", "../../@pmndrs/pointer-events/dist/pointer/ray.js", "../../@pmndrs/pointer-events/dist/pointer/lines.js", "../../@pmndrs/pointer-events/dist/pointer/touch.js", "../../@pmndrs/pointer-events/dist/pointer/index.js", "../../@pmndrs/pointer-events/dist/forward.js", "../../@pmndrs/pointer-events/dist/combine.js", "../../@pmndrs/xr/dist/mesh.js", "../../@pmndrs/xr/dist/plane.js", "../../@pmndrs/xr/dist/utils.js", "../../@pmndrs/xr/dist/layer.js", "../../@pmndrs/xr/dist/misc.js", "../../@pmndrs/xr/dist/teleport.js", "../../@pmndrs/xr/dist/hit-test.js", "../../@pmndrs/xr/dist/anchor.js", "../../@pmndrs/xr/dist/index.js", "../../@pmndrs/xr/dist/controller/utils.js", "../../@pmndrs/xr/dist/controller/layout.js", "../../@pmndrs/xr/dist/controller/state.js", "../../@react-three/xr/dist/contexts.js", "../../@react-three/xr/dist/xr.js", "../../@react-three/xr/dist/elements.js", "../../@react-three/xr/dist/utils.js", "../../@react-three/xr/dist/hooks.js", "../../@react-three/xr/dist/default.js", "../../@react-three/xr/dist/controller.js", "../../@react-three/xr/dist/input.js", "../../@react-three/xr/dist/hand.js", "../../@react-three/xr/dist/pointer.js", "../../@react-three/xr/dist/teleport.js", "../../zustand/esm/shallow.mjs", "../../@react-three/xr/dist/mesh.js", "../../@react-three/xr/dist/plane.js", "../../@react-three/xr/dist/guard/facing-camera.js", "../../@react-three/xr/dist/guard/session-mode.js", "../../@react-three/xr/dist/guard/session-supported.js", "../../@react-three/xr/dist/guard/focus.js", "../../@react-three/xr/dist/origin.js", "../../@react-three/xr/dist/hit-test.js", "../../@react-three/xr/dist/anchor.js", "../../@react-three/xr/dist/dom-overlay.js", "../../@react-three/xr/dist/layer.js", "../../@react-three/xr/dist/deprecated/button.js", "../../@react-three/xr/dist/deprecated/hooks.js", "../../@react-three/xr/dist/deprecated/interactive.js", "../../@react-three/xr/dist/deprecated/ray-grab.js"],
  "sourcesContent": ["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createGetXRSpaceMatrix } from '@pmndrs/xr/internals';\nimport { useFrame } from '@react-three/fiber';\nimport { forwardRef, useContext, useEffect, useImperativeHandle, useMemo, useRef, useState, } from 'react';\nimport { xrSpaceContext } from './contexts.js';\nimport { useXR } from './xr.js';\n/**\n * component that puts its children at the provided space (or reference space type)\n */\nexport const XRSpace = forwardRef(({ space, children }, ref) => {\n    const internalRef = useRef(null);\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const resolvedSpace = typeof space === 'string' ? useXRSpace(space) : space;\n    useImperativeHandle(ref, () => internalRef.current, []);\n    useApplyXRSpaceMatrix(internalRef, resolvedSpace, (_state, _delta, frame) => {\n        if (internalRef.current == null) {\n            return;\n        }\n        internalRef.current.visible = frame != null;\n    });\n    if (resolvedSpace == null) {\n        return null;\n    }\n    return (_jsx(\"group\", { xrSpace: resolvedSpace, visible: false, matrixAutoUpdate: false, ref: internalRef, children: _jsx(xrSpaceContext.Provider, { value: resolvedSpace, children: children }) }));\n});\nexport function useXRSpace(type) {\n    if (type == null) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const context = useContext(xrSpaceContext);\n        if (context == null) {\n            throw new Error(`XR objects must be placed inside the XROrigin`);\n        }\n        return context;\n    }\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const [referenceSpace, setReferenceSpace] = useState(undefined);\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const session = useXR((xr) => xr.session);\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n        if (session == null) {\n            return;\n        }\n        let aborted = false;\n        session.requestReferenceSpace(type).then((space) => {\n            if (aborted) {\n                return;\n            }\n            setReferenceSpace(space);\n        });\n        return () => void (aborted = true);\n    }, [session, type]);\n    return referenceSpace;\n}\n/**\n * hook that returns a function to compute a matrix that contains the transformation of the provided xr space\n */\nexport function useGetXRSpaceMatrix(space) {\n    const localReferenceSpace = useContext(xrSpaceContext);\n    const referenceSpace = useXR((xr) => localReferenceSpace ?? xr.originReferenceSpace);\n    return useMemo(() => (space == null || referenceSpace == null ? undefined : createGetXRSpaceMatrix(space, referenceSpace)), [space, referenceSpace]);\n}\n/**\n * hook that applies the transformation of the provided xr space to the provided object reference\n * @param onFrame optional callback that gets executed after the matrix of the reference object was updated\n * @requires that matrixAutoUpdate is disabled for the referenced object\n */\nexport function useApplyXRSpaceMatrix(ref, space, onFrame) {\n    const getXRSpaceMatrix = useGetXRSpaceMatrix(space);\n    useFrame((state, delta, frame) => {\n        if (ref.current == null || getXRSpaceMatrix == null) {\n            return;\n        }\n        getXRSpaceMatrix(ref.current.matrix, frame);\n        onFrame?.(state, delta, frame);\n        //makes sure we update the frame before using the space transformation anywhere\n    }, -100);\n}\n", "const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];\n\nlet _seed = 1234567;\n\n\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nfunction generateUUID() {\n\n\tconst d0 = Math.random() * 0xffffffff | 0;\n\tconst d1 = Math.random() * 0xffffffff | 0;\n\tconst d2 = Math.random() * 0xffffffff | 0;\n\tconst d3 = Math.random() * 0xffffffff | 0;\n\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\n\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\n\n\t// .toLowerCase() here flattens concatenated strings to save heap memory space.\n\treturn uuid.toLowerCase();\n\n}\n\nfunction clamp( value, min, max ) {\n\n\treturn Math.max( min, Math.min( max, value ) );\n\n}\n\n// compute euclidean modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo( n, m ) {\n\n\treturn ( ( n % m ) + m ) % m;\n\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear( x, a1, a2, b1, b2 ) {\n\n\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp( x, y, value ) {\n\n\tif ( x !== y ) {\n\n\t\treturn ( value - x ) / ( y - x );\n\n\t} else {\n\n\t\treturn 0;\n\n\t}\n\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp( x, y, t ) {\n\n\treturn ( 1 - t ) * x + t * y;\n\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp( x, y, lambda, dt ) {\n\n\treturn lerp( x, y, 1 - Math.exp( - lambda * dt ) );\n\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong( x, length = 1 ) {\n\n\treturn length - Math.abs( euclideanModulo( x, length * 2 ) - length );\n\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * ( 3 - 2 * x );\n\n}\n\nfunction smootherstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n}\n\n// Random integer from <low, high> interval\nfunction randInt( low, high ) {\n\n\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n}\n\n// Random float from <low, high> interval\nfunction randFloat( low, high ) {\n\n\treturn low + Math.random() * ( high - low );\n\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread( range ) {\n\n\treturn range * ( 0.5 - Math.random() );\n\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom( s ) {\n\n\tif ( s !== undefined ) _seed = s;\n\n\t// Mulberry32 generator\n\n\tlet t = _seed += 0x6D2B79F5;\n\n\tt = Math.imul( t ^ t >>> 15, t | 1 );\n\n\tt ^= t + Math.imul( t ^ t >>> 7, t | 61 );\n\n\treturn ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;\n\n}\n\nfunction degToRad( degrees ) {\n\n\treturn degrees * DEG2RAD;\n\n}\n\nfunction radToDeg( radians ) {\n\n\treturn radians * RAD2DEG;\n\n}\n\nfunction isPowerOfTwo( value ) {\n\n\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n}\n\nfunction ceilPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction floorPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction setQuaternionFromProperEuler( q, a, b, c, order ) {\n\n\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n\t// rotations are applied to the axes in the order specified by 'order'\n\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t// angles are in radians\n\n\tconst cos = Math.cos;\n\tconst sin = Math.sin;\n\n\tconst c2 = cos( b / 2 );\n\tconst s2 = sin( b / 2 );\n\n\tconst c13 = cos( ( a + c ) / 2 );\n\tconst s13 = sin( ( a + c ) / 2 );\n\n\tconst c1_3 = cos( ( a - c ) / 2 );\n\tconst s1_3 = sin( ( a - c ) / 2 );\n\n\tconst c3_1 = cos( ( c - a ) / 2 );\n\tconst s3_1 = sin( ( c - a ) / 2 );\n\n\tswitch ( order ) {\n\n\t\tcase 'XYX':\n\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YZY':\n\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZXZ':\n\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'XZX':\n\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YXY':\n\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZYZ':\n\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );\n\n\t}\n\n}\n\nfunction denormalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn value / 4294967295.0;\n\n\t\tcase Uint16Array:\n\n\t\t\treturn value / 65535.0;\n\n\t\tcase Uint8Array:\n\n\t\t\treturn value / 255.0;\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.max( value / 2147483647.0, - 1.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.max( value / 32767.0, - 1.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.max( value / 127.0, - 1.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nfunction normalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn Math.round( value * 4294967295.0 );\n\n\t\tcase Uint16Array:\n\n\t\t\treturn Math.round( value * 65535.0 );\n\n\t\tcase Uint8Array:\n\n\t\t\treturn Math.round( value * 255.0 );\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.round( value * 2147483647.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.round( value * 32767.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.round( value * 127.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nconst MathUtils = {\n\tDEG2RAD: DEG2RAD,\n\tRAD2DEG: RAD2DEG,\n\tgenerateUUID: generateUUID,\n\tclamp: clamp,\n\teuclideanModulo: euclideanModulo,\n\tmapLinear: mapLinear,\n\tinverseLerp: inverseLerp,\n\tlerp: lerp,\n\tdamp: damp,\n\tpingpong: pingpong,\n\tsmoothstep: smoothstep,\n\tsmootherstep: smootherstep,\n\trandInt: randInt,\n\trandFloat: randFloat,\n\trandFloatSpread: randFloatSpread,\n\tseededRandom: seededRandom,\n\tdegToRad: degToRad,\n\tradToDeg: radToDeg,\n\tisPowerOfTwo: isPowerOfTwo,\n\tceilPowerOfTwo: ceilPowerOfTwo,\n\tfloorPowerOfTwo: floorPowerOfTwo,\n\tsetQuaternionFromProperEuler: setQuaternionFromProperEuler,\n\tnormalize: normalize,\n\tdenormalize: denormalize\n};\n\nexport {\n\tDEG2RAD,\n\tRAD2DEG,\n\tgenerateUUID,\n\tclamp,\n\teuclideanModulo,\n\tmapLinear,\n\tinverseLerp,\n\tlerp,\n\tdamp,\n\tpingpong,\n\tsmoothstep,\n\tsmootherstep,\n\trandInt,\n\trandFloat,\n\trandFloatSpread,\n\tseededRandom,\n\tdegToRad,\n\tradToDeg,\n\tisPowerOfTwo,\n\tceilPowerOfTwo,\n\tfloorPowerOfTwo,\n\tsetQuaternionFromProperEuler,\n\tnormalize,\n\tdenormalize,\n\tMathUtils\n};\n", "import { clamp } from 'three/src/math/MathUtils.js';\nconst ButtonTouchThreshold = 0.05;\nconst AxisTouchThreshold = 0.1;\nexport function updateXRControllerGamepadState(target, inputSource, layout) {\n    const gamepad = inputSource.gamepad;\n    if (gamepad == null) {\n        return;\n    }\n    const layoutComponents = layout.components;\n    for (const key in layoutComponents) {\n        let component = target[key];\n        if (component == null) {\n            target[key] = component = {};\n        }\n        const { gamepadIndices } = layoutComponents[key];\n        let pressed = false;\n        let touched = false;\n        if (gamepadIndices.button != null && gamepadIndices.button < gamepad.buttons.length) {\n            const gamepadButton = gamepad.buttons[gamepadIndices.button];\n            component.button = clamp(gamepadButton.value, 0, 1);\n            pressed ||= gamepadButton.pressed || component.button === 1;\n            touched ||= gamepadButton.touched || component.button > ButtonTouchThreshold;\n        }\n        if (gamepadIndices.xAxis != null && gamepadIndices.xAxis < gamepad.axes.length) {\n            component.xAxis = clamp(gamepad.axes[gamepadIndices.xAxis], -1, 1);\n            touched ||= Math.abs(component.xAxis) > AxisTouchThreshold;\n        }\n        if (gamepadIndices.yAxis != null && gamepadIndices.yAxis < gamepad.axes.length) {\n            component.yAxis = clamp(gamepad.axes[gamepadIndices.yAxis], -1, 1);\n            touched ||= Math.abs(component.yAxis) > AxisTouchThreshold;\n        }\n        component.state = pressed ? 'pressed' : touched ? 'touched' : 'default';\n    }\n}\n", "import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet gpuType = - 1;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\n\t\tif ( gpuType !== attribute.gpuType ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.count * itemSize;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tconst result = new BufferAttribute( array, itemSize, normalized );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst tupleOffset = offset / itemSize;\n\t\t\tfor ( let j = 0, l = attribute.count; j < l; j ++ ) {\n\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\t\tconst value = attribute.getComponent( j, c );\n\t\t\t\t\tresult.setComponent( j + tupleOffset, c, value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tarray.set( attribute.array, offset );\n\n\t\t}\n\n\t\toffset += attribute.count * itemSize;\n\n\t}\n\n\tif ( gpuType !== undefined ) {\n\n\t\tresult.gpuType = gpuType;\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new attr.constructor(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttributes = geometry.morphAttributes[ name ];\n\t\tif ( morphAttributes ) {\n\n\t\t\tif ( ! tmpMorphAttributes[ name ] ) tmpMorphAttributes[ name ] = [];\n\t\t\tmorphAttributes.forEach( ( morphAttr, i ) => {\n\n\t\t\t\tconst array = new morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize );\n\t\t\t\ttmpMorphAttributes[ name ][ i ] = new morphAttr.constructor( array, morphAttr.itemSize, morphAttr.normalized );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst halfTolerance = tolerance * 0.5;\n\tconst exponent = Math.log10( 1 / tolerance );\n\tconst hashMultiplier = Math.pow( 10, exponent );\n\tconst hashAdditive = halfTolerance * hashMultiplier;\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * hashMultiplier + hashAdditive ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttributes = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newArray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewArray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttributes ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttributes.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttributes[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new tmpAttribute.constructor(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new tmpMorphAttribute.constructor(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry\n * @param {number} [creaseAngle]\n * @return {BufferGeometry}\n */\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vectors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\t// BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n\t// and returns the original geometry\n\tconst resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n", "import {\n\tAnimationClip,\n\tBone,\n\tBox3,\n\tBufferAttribute,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tColorManagement,\n\tDirectionalLight,\n\tDoubleSide,\n\tFileLoader,\n\tFrontSide,\n\tGroup,\n\tImageBitmapLoader,\n\tInstancedMesh,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tInterpolant,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tLine,\n\tLineBasicMaterial,\n\tLineLoop,\n\tLineSegments,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tLinearSRGBColorSpace,\n\tLoader,\n\tLoaderUtils,\n\tMaterial,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tMeshBasicMaterial,\n\tMeshPhysicalMaterial,\n\tMeshStandardMaterial,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tNumberKeyframeTrack,\n\tObject3D,\n\tOrthographicCamera,\n\tPerspectiveCamera,\n\tPointLight,\n\tPoints,\n\tPointsMaterial,\n\tPropertyBinding,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tRepeatWrapping,\n\tSkeleton,\n\tSkinnedMesh,\n\tSphere,\n\tSpotLight,\n\tTexture,\n\tTextureLoader,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack,\n\tSRGBColorSpace,\n\tInstancedBufferAttribute\n} from 'three';\nimport { toTrianglesDrawMode } from '../utils/BufferGeometryUtils.js';\n\nclass GLTFLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.dracoLoader = null;\n\t\tthis.ktx2Loader = null;\n\t\tthis.meshoptDecoder = null;\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsDispersionExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureBasisUExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureWebPExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureAVIFExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsSheenExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsVolumeExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsIorExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsEmissiveStrengthExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsSpecularExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsIridescenceExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsAnisotropyExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsBumpExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFLightsExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshoptCompression( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshGpuInstancing( parser );\n\n\t\t} );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet resourcePath;\n\n\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\tresourcePath = this.resourcePath;\n\n\t\t} else if ( this.path !== '' ) {\n\n\t\t\t// If a base path is set, resources will be relative paths from that plus the relative path of the gltf file\n\t\t\t// Example  path = 'https://my-cnd-server.com/', url = 'assets/models/model.gltf'\n\t\t\t// resourcePath = 'https://my-cnd-server.com/assets/models/'\n\t\t\t// referenced resource 'model.bin' will be loaded from 'https://my-cnd-server.com/assets/models/model.bin'\n\t\t\t// referenced resource '../textures/texture.png' will be loaded from 'https://my-cnd-server.com/assets/textures/texture.png'\n\t\t\tconst relativeUrl = LoaderUtils.extractUrlBase( url );\n\t\t\tresourcePath = LoaderUtils.resolveURL( relativeUrl, this.path );\n\n\t\t} else {\n\n\t\t\tresourcePath = LoaderUtils.extractUrlBase( url );\n\n\t\t}\n\n\t\t// Tells the LoadingManager to track an extra item, which resolves after\n\t\t// the model is fully loaded. This means the count of items loaded will\n\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\n\t\tthis.manager.itemStart( url );\n\n\t\tconst _onError = function ( e ) {\n\n\t\t\tif ( onError ) {\n\n\t\t\t\tonError( e );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t};\n\n\t\tconst loader = new FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\n\n\t\t\t\t\tonLoad( gltf );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, _onError );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\t_onError( e );\n\n\t\t\t}\n\n\t\t}, onProgress, _onError );\n\n\t}\n\n\tsetDRACOLoader( dracoLoader ) {\n\n\t\tthis.dracoLoader = dracoLoader;\n\t\treturn this;\n\n\t}\n\n\tsetDDSLoader() {\n\n\t\tthrow new Error(\n\n\t\t\t'THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".'\n\n\t\t);\n\n\t}\n\n\tsetKTX2Loader( ktx2Loader ) {\n\n\t\tthis.ktx2Loader = ktx2Loader;\n\t\treturn this;\n\n\t}\n\n\tsetMeshoptDecoder( meshoptDecoder ) {\n\n\t\tthis.meshoptDecoder = meshoptDecoder;\n\t\treturn this;\n\n\t}\n\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tparse( data, path, onLoad, onError ) {\n\n\t\tlet json;\n\t\tconst extensions = {};\n\t\tconst plugins = {};\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tif ( typeof data === 'string' ) {\n\n\t\t\tjson = JSON.parse( data );\n\n\t\t} else if ( data instanceof ArrayBuffer ) {\n\n\t\t\tconst magic = textDecoder.decode( new Uint8Array( data, 0, 4 ) );\n\n\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\tif ( onError ) onError( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tjson = JSON.parse( extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content );\n\n\t\t\t} else {\n\n\t\t\t\tjson = JSON.parse( textDecoder.decode( data ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tjson = data;\n\n\t\t}\n\n\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\n\n\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst parser = new GLTFParser( json, {\n\n\t\t\tpath: path || this.resourcePath || '',\n\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\trequestHeader: this.requestHeader,\n\t\t\tmanager: this.manager,\n\t\t\tktx2Loader: this.ktx2Loader,\n\t\t\tmeshoptDecoder: this.meshoptDecoder\n\n\t\t} );\n\n\t\tparser.fileLoader.setRequestHeader( this.requestHeader );\n\n\t\tfor ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {\n\n\t\t\tconst plugin = this.pluginCallbacks[ i ]( parser );\n\n\t\t\tif ( ! plugin.name ) console.error( 'THREE.GLTFLoader: Invalid plugin found: missing name' );\n\n\t\t\tplugins[ plugin.name ] = plugin;\n\n\t\t\t// Workaround to avoid determining as unknown extension\n\t\t\t// in addUnknownExtensionsToUserData().\n\t\t\t// Remove this workaround if we move all the existing\n\t\t\t// extension handlers to plugin system\n\t\t\textensions[ plugin.name ] = true;\n\n\t\t}\n\n\t\tif ( json.extensionsUsed ) {\n\n\t\t\tfor ( let i = 0; i < json.extensionsUsed.length; ++ i ) {\n\n\t\t\t\tconst extensionName = json.extensionsUsed[ i ];\n\t\t\t\tconst extensionsRequired = json.extensionsRequired || [];\n\n\t\t\t\tswitch ( extensionName ) {\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tparser.setExtensions( extensions );\n\t\tparser.setPlugins( plugins );\n\t\tparser.parse( onLoad, onError );\n\n\t}\n\n\tparseAsync( data, path ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.parse( data, path, resolve, reject );\n\n\t\t} );\n\n\t}\n\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n\n\tlet objects = {};\n\n\treturn\t{\n\n\t\tget: function ( key ) {\n\n\t\t\treturn objects[ key ];\n\n\t\t},\n\n\t\tadd: function ( key, object ) {\n\n\t\t\tobjects[ key ] = object;\n\n\t\t},\n\n\t\tremove: function ( key ) {\n\n\t\t\tdelete objects[ key ];\n\n\t\t},\n\n\t\tremoveAll: function () {\n\n\t\t\tobjects = {};\n\n\t\t}\n\n\t};\n\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n\tKHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',\n\tKHR_MATERIALS_IOR: 'KHR_materials_ior',\n\tKHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\n\tKHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n\tKHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n\tKHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\n\tKHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',\n\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\tKHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n\tKHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n\tKHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\n\tEXT_MATERIALS_BUMP: 'EXT_materials_bump',\n\tEXT_TEXTURE_WEBP: 'EXT_texture_webp',\n\tEXT_TEXTURE_AVIF: 'EXT_texture_avif',\n\tEXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\n\tEXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'\n};\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightsExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n\t\t// Object3D instance caches\n\t\tthis.cache = { refs: {}, uses: {} };\n\n\t}\n\n\t_markDefs() {\n\n\t\tconst parser = this.parser;\n\t\tconst nodeDefs = this.parser.json.nodes || [];\n\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.extensions\n\t\t\t\t\t&& nodeDef.extensions[ this.name ]\n\t\t\t\t\t&& nodeDef.extensions[ this.name ].light !== undefined ) {\n\n\t\t\t\tparser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_loadLight( lightIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst cacheKey = 'light:' + lightIndex;\n\t\tlet dependency = parser.cache.get( cacheKey );\n\n\t\tif ( dependency ) return dependency;\n\n\t\tconst json = parser.json;\n\t\tconst extensions = ( json.extensions && json.extensions[ this.name ] ) || {};\n\t\tconst lightDefs = extensions.lights || [];\n\t\tconst lightDef = lightDefs[ lightIndex ];\n\t\tlet lightNode;\n\n\t\tconst color = new Color( 0xffffff );\n\n\t\tif ( lightDef.color !== undefined ) color.setRGB( lightDef.color[ 0 ], lightDef.color[ 1 ], lightDef.color[ 2 ], LinearSRGBColorSpace );\n\n\t\tconst range = lightDef.range !== undefined ? lightDef.range : 0;\n\n\t\tswitch ( lightDef.type ) {\n\n\t\t\tcase 'directional':\n\t\t\t\tlightNode = new DirectionalLight( color );\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tcase 'point':\n\t\t\t\tlightNode = new PointLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\tbreak;\n\n\t\t\tcase 'spot':\n\t\t\t\tlightNode = new SpotLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\t// Handle spotlight properties.\n\t\t\t\tlightDef.spot = lightDef.spot || {};\n\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );\n\n\t\t}\n\n\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\n\t\t// here, because node-level parsing will only override position if explicitly specified.\n\t\tlightNode.position.set( 0, 0, 0 );\n\n\t\tlightNode.decay = 2;\n\n\t\tassignExtrasToUserData( lightNode, lightDef );\n\n\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\n\n\t\tlightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );\n\n\t\tdependency = Promise.resolve( lightNode );\n\n\t\tparser.cache.add( cacheKey, dependency );\n\n\t\treturn dependency;\n\n\t}\n\n\tgetDependency( type, index ) {\n\n\t\tif ( type !== 'light' ) return;\n\n\t\treturn this._loadLight( index );\n\n\t}\n\n\tcreateNodeAttachment( nodeIndex ) {\n\n\t\tconst self = this;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\t\tconst lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};\n\t\tconst lightIndex = lightDef.light;\n\n\t\tif ( lightIndex === undefined ) return null;\n\n\t\treturn this._loadLight( lightIndex ).then( function ( light ) {\n\n\t\t\treturn parser._getNodeRef( self.cache, lightIndex, light );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n\t}\n\n\tgetMaterialType() {\n\n\t\treturn MeshBasicMaterial;\n\n\t}\n\n\textendParams( materialParams, materialDef, parser ) {\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness;\n\n\t\tif ( metallicRoughness ) {\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;\n\n\t\tif ( emissiveStrength !== undefined ) {\n\n\t\t\tmaterialParams.emissiveIntensity = emissiveStrength;\n\n\t\t}\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.clearcoatFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\n\n\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = extension.clearcoatNormalTexture.scale;\n\n\t\t\t\tmaterialParams.clearcoatNormalScale = new Vector2( scale, scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials dispersion Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_dispersion\n */\nclass GLTFMaterialsDispersionExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.dispersion = extension.dispersion !== undefined ? extension.dispersion : 0;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.iridescenceFactor !== undefined ) {\n\n\t\t\tmaterialParams.iridescence = extension.iridescenceFactor;\n\n\t\t}\n\n\t\tif ( extension.iridescenceTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );\n\n\t\t}\n\n\t\tif ( extension.iridescenceIor !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceIOR = extension.iridescenceIor;\n\n\t\t}\n\n\t\tif ( materialParams.iridescenceThicknessRange === undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange = [ 100, 400 ];\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessMinimum !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessMaximum !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.sheenColor = new Color( 0, 0, 0 );\n\t\tmaterialParams.sheenRoughness = 0;\n\t\tmaterialParams.sheen = 1;\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.sheenColorFactor !== undefined ) {\n\n\t\t\tconst colorFactor = extension.sheenColorFactor;\n\t\t\tmaterialParams.sheenColor.setRGB( colorFactor[ 0 ], colorFactor[ 1 ], colorFactor[ 2 ], LinearSRGBColorSpace );\n\n\t\t}\n\n\t\tif ( extension.sheenRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.sheenRoughness = extension.sheenRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.sheenColorTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\tif ( extension.sheenRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.transmissionFactor !== undefined ) {\n\n\t\t\tmaterialParams.transmission = extension.transmissionFactor;\n\n\t\t}\n\n\t\tif ( extension.transmissionTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\n\n\t\tif ( extension.thicknessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );\n\n\t\t}\n\n\t\tmaterialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n\n\t\tconst colorArray = extension.attenuationColor || [ 1, 1, 1 ];\n\t\tmaterialParams.attenuationColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IOR;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\n\n\t\tif ( extension.specularTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );\n\n\t\t}\n\n\t\tconst colorArray = extension.specularColorFactor || [ 1, 1, 1 ];\n\t\tmaterialParams.specularColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );\n\n\t\tif ( extension.specularColorTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n\n/**\n * Materials bump Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\n */\nclass GLTFMaterialsBumpExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_MATERIALS_BUMP;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0;\n\n\t\tif ( extension.bumpTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'bumpMap', extension.bumpTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials anisotropy Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.anisotropyStrength !== undefined ) {\n\n\t\t\tmaterialParams.anisotropy = extension.anisotropyStrength;\n\n\t\t}\n\n\t\tif ( extension.anisotropyRotation !== undefined ) {\n\n\t\t\tmaterialParams.anisotropyRotation = extension.anisotropyRotation;\n\n\t\t}\n\n\t\tif ( extension.anisotropyTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'anisotropyMap', extension.anisotropyTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\nclass GLTFTextureBasisUExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ this.name ];\n\t\tconst loader = parser.options.ktx2Loader;\n\n\t\tif ( ! loader ) {\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );\n\n\t\t\t} else {\n\n\t\t\t\t// Assumes that the extension is optional and that a fallback texture is present\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t}\n\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\nclass GLTFTextureWebPExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n\t\tthis.isSupported = null;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.detectSupport().then( function ( isSupported ) {\n\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );\n\n\t\t\t}\n\n\t\t\t// Fall back to PNG or JPEG.\n\t\t\treturn parser.loadTexture( textureIndex );\n\n\t\t} );\n\n\t}\n\n\tdetectSupport() {\n\n\t\tif ( ! this.isSupported ) {\n\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\n\n\t\t\t\tconst image = new Image();\n\n\t\t\t\t// Lossy test image. Support for lossy images doesn't guarantee support for all\n\t\t\t\t// WebP images, unfortunately.\n\t\t\t\timage.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\n\n\t\t\t\timage.onload = image.onerror = function () {\n\n\t\t\t\t\tresolve( image.height === 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this.isSupported;\n\n\t}\n\n}\n\n/**\n * AVIF Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif\n */\nclass GLTFTextureAVIFExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n\t\tthis.isSupported = null;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.detectSupport().then( function ( isSupported ) {\n\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: AVIF required by asset but unsupported.' );\n\n\t\t\t}\n\n\t\t\t// Fall back to PNG or JPEG.\n\t\t\treturn parser.loadTexture( textureIndex );\n\n\t\t} );\n\n\t}\n\n\tdetectSupport() {\n\n\t\tif ( ! this.isSupported ) {\n\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\n\n\t\t\t\tconst image = new Image();\n\n\t\t\t\t// Lossy test image.\n\t\t\t\timage.src = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=';\n\t\t\t\timage.onload = image.onerror = function () {\n\n\t\t\t\t\tresolve( image.height === 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this.isSupported;\n\n\t}\n\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\nclass GLTFMeshoptCompression {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n\t\tthis.parser = parser;\n\n\t}\n\n\tloadBufferView( index ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst bufferView = json.bufferViews[ index ];\n\n\t\tif ( bufferView.extensions && bufferView.extensions[ this.name ] ) {\n\n\t\t\tconst extensionDef = bufferView.extensions[ this.name ];\n\n\t\t\tconst buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );\n\t\t\tconst decoder = this.parser.options.meshoptDecoder;\n\n\t\t\tif ( ! decoder || ! decoder.supported ) {\n\n\t\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Assumes that the extension is optional and that fallback buffer data is present\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn buffer.then( function ( res ) {\n\n\t\t\t\tconst byteOffset = extensionDef.byteOffset || 0;\n\t\t\t\tconst byteLength = extensionDef.byteLength || 0;\n\n\t\t\t\tconst count = extensionDef.count;\n\t\t\t\tconst stride = extensionDef.byteStride;\n\n\t\t\t\tconst source = new Uint8Array( res, byteOffset, byteLength );\n\n\t\t\t\tif ( decoder.decodeGltfBufferAsync ) {\n\n\t\t\t\t\treturn decoder.decodeGltfBufferAsync( count, stride, source, extensionDef.mode, extensionDef.filter ).then( function ( res ) {\n\n\t\t\t\t\t\treturn res.buffer;\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\n\t\t\t\t\treturn decoder.ready.then( function () {\n\n\t\t\t\t\t\tconst result = new ArrayBuffer( count * stride );\n\t\t\t\t\t\tdecoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );\n\t\t\t\t\t\treturn result;\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n */\nclass GLTFMeshGpuInstancing {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n\t\tthis.parser = parser;\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( ! nodeDef.extensions || ! nodeDef.extensions[ this.name ] ||\n\t\t\tnodeDef.mesh === undefined ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst meshDef = json.meshes[ nodeDef.mesh ];\n\n\t\t// No Points or Lines + Instancing support yet\n\n\t\tfor ( const primitive of meshDef.primitives ) {\n\n\t\t\tif ( primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&\n\t\t\t\t primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&\n\t\t\t\t primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&\n\t\t\t\t primitive.mode !== undefined ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst extensionDef = nodeDef.extensions[ this.name ];\n\t\tconst attributesDef = extensionDef.attributes;\n\n\t\t// @TODO: Can we support InstancedMesh + SkinnedMesh?\n\n\t\tconst pending = [];\n\t\tconst attributes = {};\n\n\t\tfor ( const key in attributesDef ) {\n\n\t\t\tpending.push( this.parser.getDependency( 'accessor', attributesDef[ key ] ).then( accessor => {\n\n\t\t\t\tattributes[ key ] = accessor;\n\t\t\t\treturn attributes[ key ];\n\n\t\t\t} ) );\n\n\t\t}\n\n\t\tif ( pending.length < 1 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tpending.push( this.parser.createNodeMesh( nodeIndex ) );\n\n\t\treturn Promise.all( pending ).then( results => {\n\n\t\t\tconst nodeObject = results.pop();\n\t\t\tconst meshes = nodeObject.isGroup ? nodeObject.children : [ nodeObject ];\n\t\t\tconst count = results[ 0 ].count; // All attribute counts should be same\n\t\t\tconst instancedMeshes = [];\n\n\t\t\tfor ( const mesh of meshes ) {\n\n\t\t\t\t// Temporal variables\n\t\t\t\tconst m = new Matrix4();\n\t\t\t\tconst p = new Vector3();\n\t\t\t\tconst q = new Quaternion();\n\t\t\t\tconst s = new Vector3( 1, 1, 1 );\n\n\t\t\t\tconst instancedMesh = new InstancedMesh( mesh.geometry, mesh.material, count );\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tif ( attributes.TRANSLATION ) {\n\n\t\t\t\t\t\tp.fromBufferAttribute( attributes.TRANSLATION, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.ROTATION ) {\n\n\t\t\t\t\t\tq.fromBufferAttribute( attributes.ROTATION, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.SCALE ) {\n\n\t\t\t\t\t\ts.fromBufferAttribute( attributes.SCALE, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tinstancedMesh.setMatrixAt( i, m.compose( p, q, s ) );\n\n\t\t\t\t}\n\n\t\t\t\t// Add instance attributes to the geometry, excluding TRS.\n\t\t\t\tfor ( const attributeName in attributes ) {\n\n\t\t\t\t\tif ( attributeName === '_COLOR_0' ) {\n\n\t\t\t\t\t\tconst attr = attributes[ attributeName ];\n\t\t\t\t\t\tinstancedMesh.instanceColor = new InstancedBufferAttribute( attr.array, attr.itemSize, attr.normalized );\n\n\t\t\t\t\t} else if ( attributeName !== 'TRANSLATION' &&\n\t\t\t\t\t\t attributeName !== 'ROTATION' &&\n\t\t\t\t\t\t attributeName !== 'SCALE' ) {\n\n\t\t\t\t\t\tmesh.geometry.setAttribute( attributeName, attributes[ attributeName ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Just in case\n\t\t\t\tObject3D.prototype.copy.call( instancedMesh, mesh );\n\n\t\t\t\tthis.parser.assignFinalMaterial( instancedMesh );\n\n\t\t\t\tinstancedMeshes.push( instancedMesh );\n\n\t\t\t}\n\n\t\t\tif ( nodeObject.isGroup ) {\n\n\t\t\t\tnodeObject.clear();\n\n\t\t\t\tnodeObject.add( ... instancedMeshes );\n\n\t\t\t\treturn nodeObject;\n\n\t\t\t}\n\n\t\t\treturn instancedMeshes[ 0 ];\n\n\t\t} );\n\n\t}\n\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\nclass GLTFBinaryExtension {\n\n\tconstructor( data ) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tconst headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tthis.header = {\n\t\t\tmagic: textDecoder.decode( new Uint8Array( data.slice( 0, 4 ) ) ),\n\t\t\tversion: headerView.getUint32( 4, true ),\n\t\t\tlength: headerView.getUint32( 8, true )\n\t\t};\n\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\n\n\t\t} else if ( this.header.version < 2.0 ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\n\n\t\t}\n\n\t\tconst chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n\t\tconst chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tlet chunkIndex = 0;\n\n\t\twhile ( chunkIndex < chunkContentsLength ) {\n\n\t\t\tconst chunkLength = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tconst chunkType = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\n\n\t\t\t\tconst contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\n\t\t\t\tthis.content = textDecoder.decode( contentArray );\n\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\n\n\t\t\t\tconst byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\n\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\n\t\t}\n\n\t\tif ( this.content === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\nclass GLTFDracoMeshCompressionExtension {\n\n\tconstructor( json, dracoLoader ) {\n\n\t\tif ( ! dracoLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\tthis.json = json;\n\t\tthis.dracoLoader = dracoLoader;\n\t\tthis.dracoLoader.preload();\n\n\t}\n\n\tdecodePrimitive( primitive, parser ) {\n\n\t\tconst json = this.json;\n\t\tconst dracoLoader = this.dracoLoader;\n\t\tconst bufferViewIndex = primitive.extensions[ this.name ].bufferView;\n\t\tconst gltfAttributeMap = primitive.extensions[ this.name ].attributes;\n\t\tconst threeAttributeMap = {};\n\t\tconst attributeNormalizedMap = {};\n\t\tconst attributeTypeMap = {};\n\n\t\tfor ( const attributeName in gltfAttributeMap ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\n\n\t\t}\n\n\t\tfor ( const attributeName in primitive.attributes ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\n\n\t\t\t\tconst accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\n\t\t\t\tconst componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType.name;\n\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\n\n\t\t\t\t\tfor ( const attributeName in geometry.attributes ) {\n\n\t\t\t\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\tconst normalized = attributeNormalizedMap[ attributeName ];\n\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( geometry );\n\n\t\t\t\t}, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\nclass GLTFTextureTransformExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n\n\t}\n\n\textendTexture( texture, transform ) {\n\n\t\tif ( ( transform.texCoord === undefined || transform.texCoord === texture.channel )\n\t\t\t&& transform.offset === undefined\n\t\t\t&& transform.rotation === undefined\n\t\t\t&& transform.scale === undefined ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21819.\n\t\t\treturn texture;\n\n\t\t}\n\n\t\ttexture = texture.clone();\n\n\t\tif ( transform.texCoord !== undefined ) {\n\n\t\t\ttexture.channel = transform.texCoord;\n\n\t\t}\n\n\t\tif ( transform.offset !== undefined ) {\n\n\t\t\ttexture.offset.fromArray( transform.offset );\n\n\t\t}\n\n\t\tif ( transform.rotation !== undefined ) {\n\n\t\t\ttexture.rotation = transform.rotation;\n\n\t\t}\n\n\t\tif ( transform.scale !== undefined ) {\n\n\t\t\ttexture.repeat.fromArray( transform.scale );\n\n\t\t}\n\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\nclass GLTFMeshQuantizationExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n\n\t}\n\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// Copies a sample value to the result buffer. See description of glTF\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tvalueSize = this.valueSize,\n\t\t\toffset = index * valueSize * 3 + valueSize;\n\n\t\tfor ( let i = 0; i !== valueSize; i ++ ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer;\n\t\tconst values = this.sampleValues;\n\t\tconst stride = this.valueSize;\n\n\t\tconst stride2 = stride * 2;\n\t\tconst stride3 = stride * 3;\n\n\t\tconst td = t1 - t0;\n\n\t\tconst p = ( t - t0 ) / td;\n\t\tconst pp = p * p;\n\t\tconst ppp = pp * p;\n\n\t\tconst offset1 = i1 * stride3;\n\t\tconst offset0 = offset1 - stride3;\n\n\t\tconst s2 = - 2 * ppp + 3 * pp;\n\t\tconst s3 = ppp - pp;\n\t\tconst s0 = 1 - s2;\n\t\tconst s1 = s3 - pp + p;\n\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\t\tfor ( let i = 0; i !== stride; i ++ ) {\n\n\t\t\tconst p0 = values[ offset0 + i + stride ]; // splineVertex_k\n\t\t\tconst m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\n\t\t\tconst p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\n\t\t\tconst m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nconst _q = new Quaternion();\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = super.interpolate_( i1, t0, t, t1 );\n\n\t\t_q.fromArray( result ).normalize().toArray( result );\n\n\t\treturn result;\n\n\t}\n\n}\n\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n\tFLOAT: 5126,\n\t//FLOAT_MAT2: 35674,\n\tFLOAT_MAT3: 35675,\n\tFLOAT_MAT4: 35676,\n\tFLOAT_VEC2: 35664,\n\tFLOAT_VEC3: 35665,\n\tFLOAT_VEC4: 35666,\n\tLINEAR: 9729,\n\tREPEAT: 10497,\n\tSAMPLER_2D: 35678,\n\tPOINTS: 0,\n\tLINES: 1,\n\tLINE_LOOP: 2,\n\tLINE_STRIP: 3,\n\tTRIANGLES: 4,\n\tTRIANGLE_STRIP: 5,\n\tTRIANGLE_FAN: 6,\n\tUNSIGNED_BYTE: 5121,\n\tUNSIGNED_SHORT: 5123\n};\n\nconst WEBGL_COMPONENT_TYPES = {\n\t5120: Int8Array,\n\t5121: Uint8Array,\n\t5122: Int16Array,\n\t5123: Uint16Array,\n\t5125: Uint32Array,\n\t5126: Float32Array\n};\n\nconst WEBGL_FILTERS = {\n\t9728: NearestFilter,\n\t9729: LinearFilter,\n\t9984: NearestMipmapNearestFilter,\n\t9985: LinearMipmapNearestFilter,\n\t9986: NearestMipmapLinearFilter,\n\t9987: LinearMipmapLinearFilter\n};\n\nconst WEBGL_WRAPPINGS = {\n\t33071: ClampToEdgeWrapping,\n\t33648: MirroredRepeatWrapping,\n\t10497: RepeatWrapping\n};\n\nconst WEBGL_TYPE_SIZES = {\n\t'SCALAR': 1,\n\t'VEC2': 2,\n\t'VEC3': 3,\n\t'VEC4': 4,\n\t'MAT2': 4,\n\t'MAT3': 9,\n\t'MAT4': 16\n};\n\nconst ATTRIBUTES = {\n\tPOSITION: 'position',\n\tNORMAL: 'normal',\n\tTANGENT: 'tangent',\n\tTEXCOORD_0: 'uv',\n\tTEXCOORD_1: 'uv1',\n\tTEXCOORD_2: 'uv2',\n\tTEXCOORD_3: 'uv3',\n\tCOLOR_0: 'color',\n\tWEIGHTS_0: 'skinWeight',\n\tJOINTS_0: 'skinIndex',\n};\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\ttranslation: 'position',\n\trotation: 'quaternion',\n\tweights: 'morphTargetInfluences'\n};\n\nconst INTERPOLATION = {\n\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\n\tLINEAR: InterpolateLinear,\n\tSTEP: InterpolateDiscrete\n};\n\nconst ALPHA_MODES = {\n\tOPAQUE: 'OPAQUE',\n\tMASK: 'MASK',\n\tBLEND: 'BLEND'\n};\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\nfunction createDefaultMaterial( cache ) {\n\n\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\n\n\t\tcache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {\n\t\t\tcolor: 0xFFFFFF,\n\t\t\temissive: 0x000000,\n\t\t\tmetalness: 1,\n\t\t\troughness: 1,\n\t\t\ttransparent: false,\n\t\t\tdepthTest: true,\n\t\t\tside: FrontSide\n\t\t} );\n\n\t}\n\n\treturn cache[ 'DefaultMaterial' ];\n\n}\n\nfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\n\n\t// Add unknown glTF extensions to an object's userData.\n\n\tfor ( const name in objectDef.extensions ) {\n\n\t\tif ( knownExtensions[ name ] === undefined ) {\n\n\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\n\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData( object, gltfDef ) {\n\n\tif ( gltfDef.extras !== undefined ) {\n\n\t\tif ( typeof gltfDef.extras === 'object' ) {\n\n\t\t\tObject.assign( object.userData, gltfDef.extras );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets( geometry, targets, parser ) {\n\n\tlet hasMorphPosition = false;\n\tlet hasMorphNormal = false;\n\tlet hasMorphColor = false;\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\n\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\n\t\tif ( target.COLOR_0 !== undefined ) hasMorphColor = true;\n\n\t\tif ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;\n\n\t}\n\n\tif ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );\n\n\tconst pendingPositionAccessors = [];\n\tconst pendingNormalAccessors = [];\n\tconst pendingColorAccessors = [];\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( hasMorphPosition ) {\n\n\t\t\tconst pendingAccessor = target.POSITION !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\n\t\t\t\t: geometry.attributes.position;\n\n\t\t\tpendingPositionAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphNormal ) {\n\n\t\t\tconst pendingAccessor = target.NORMAL !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\n\t\t\t\t: geometry.attributes.normal;\n\n\t\t\tpendingNormalAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphColor ) {\n\n\t\t\tconst pendingAccessor = target.COLOR_0 !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.COLOR_0 )\n\t\t\t\t: geometry.attributes.color;\n\n\t\t\tpendingColorAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t}\n\n\treturn Promise.all( [\n\t\tPromise.all( pendingPositionAccessors ),\n\t\tPromise.all( pendingNormalAccessors ),\n\t\tPromise.all( pendingColorAccessors )\n\t] ).then( function ( accessors ) {\n\n\t\tconst morphPositions = accessors[ 0 ];\n\t\tconst morphNormals = accessors[ 1 ];\n\t\tconst morphColors = accessors[ 2 ];\n\n\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\n\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\n\t\tif ( hasMorphColor ) geometry.morphAttributes.color = morphColors;\n\t\tgeometry.morphTargetsRelative = true;\n\n\t\treturn geometry;\n\n\t} );\n\n}\n\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets( mesh, meshDef ) {\n\n\tmesh.updateMorphTargets();\n\n\tif ( meshDef.weights !== undefined ) {\n\n\t\tfor ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {\n\n\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\n\n\t\t}\n\n\t}\n\n\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\n\n\t\tconst targetNames = meshDef.extras.targetNames;\n\n\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\n\n\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\tfor ( let i = 0, il = targetNames.length; i < il; i ++ ) {\n\n\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\n\n\t\t}\n\n\t}\n\n}\n\nfunction createPrimitiveKey( primitiveDef ) {\n\n\tlet geometryKey;\n\n\tconst dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\n\n\tif ( dracoExtension ) {\n\n\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\n\t\t\t\t+ ':' + dracoExtension.indices\n\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\n\n\t} else {\n\n\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\n\n\t}\n\n\tif ( primitiveDef.targets !== undefined ) {\n\n\t\tfor ( let i = 0, il = primitiveDef.targets.length; i < il; i ++ ) {\n\n\t\t\tgeometryKey += ':' + createAttributesKey( primitiveDef.targets[ i ] );\n\n\t\t}\n\n\t}\n\n\treturn geometryKey;\n\n}\n\nfunction createAttributesKey( attributes ) {\n\n\tlet attributesKey = '';\n\n\tconst keys = Object.keys( attributes ).sort();\n\n\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\n\n\t}\n\n\treturn attributesKey;\n\n}\n\nfunction getNormalizedComponentScale( constructor ) {\n\n\t// Reference:\n\t// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n\tswitch ( constructor ) {\n\n\t\tcase Int8Array:\n\t\t\treturn 1 / 127;\n\n\t\tcase Uint8Array:\n\t\t\treturn 1 / 255;\n\n\t\tcase Int16Array:\n\t\t\treturn 1 / 32767;\n\n\t\tcase Uint16Array:\n\t\t\treturn 1 / 65535;\n\n\t\tdefault:\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );\n\n\t}\n\n}\n\nfunction getImageURIMimeType( uri ) {\n\n\tif ( uri.search( /\\.jpe?g($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/jpeg/ ) === 0 ) return 'image/jpeg';\n\tif ( uri.search( /\\.webp($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/webp/ ) === 0 ) return 'image/webp';\n\n\treturn 'image/png';\n\n}\n\nconst _identityMatrix = new Matrix4();\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n\n\tconstructor( json = {}, options = {} ) {\n\n\t\tthis.json = json;\n\t\tthis.extensions = {};\n\t\tthis.plugins = {};\n\t\tthis.options = options;\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// associations between Three.js objects and glTF elements\n\t\tthis.associations = new Map();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = {};\n\n\t\t// Node cache\n\t\tthis.nodeCache = {};\n\n\t\t// Object3D instance caches\n\t\tthis.meshCache = { refs: {}, uses: {} };\n\t\tthis.cameraCache = { refs: {}, uses: {} };\n\t\tthis.lightCache = { refs: {}, uses: {} };\n\n\t\tthis.sourceCache = {};\n\t\tthis.textureCache = {};\n\n\t\t// Track node names, to ensure no duplicates\n\t\tthis.nodeNamesUsed = {};\n\n\t\t// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n\t\t// expensive work of uploading a texture to the GPU off the main thread.\n\n\t\tlet isSafari = false;\n\t\tlet safariVersion = - 1;\n\t\tlet isFirefox = false;\n\t\tlet firefoxVersion = - 1;\n\n\t\tif ( typeof navigator !== 'undefined' ) {\n\n\t\t\tconst userAgent = navigator.userAgent;\n\n\t\t\tisSafari = /^((?!chrome|android).)*safari/i.test( userAgent ) === true;\n\t\t\tconst safariMatch = userAgent.match( /Version\\/(\\d+)/ );\n\t\t\tsafariVersion = isSafari && safariMatch ? parseInt( safariMatch[ 1 ], 10 ) : - 1;\n\n\t\t\tisFirefox = userAgent.indexOf( 'Firefox' ) > - 1;\n\t\t\tfirefoxVersion = isFirefox ? userAgent.match( /Firefox\\/([0-9]+)\\./ )[ 1 ] : - 1;\n\n\t\t}\n\n\t\tif ( typeof createImageBitmap === 'undefined' || ( isSafari && safariVersion < 17 ) || ( isFirefox && firefoxVersion < 98 ) ) {\n\n\t\t\tthis.textureLoader = new TextureLoader( this.options.manager );\n\n\t\t} else {\n\n\t\t\tthis.textureLoader = new ImageBitmapLoader( this.options.manager );\n\n\t\t}\n\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\n\t\tthis.textureLoader.setRequestHeader( this.options.requestHeader );\n\n\t\tthis.fileLoader = new FileLoader( this.options.manager );\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\n\n\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\n\n\t\t\tthis.fileLoader.setWithCredentials( true );\n\n\t\t}\n\n\t}\n\n\tsetExtensions( extensions ) {\n\n\t\tthis.extensions = extensions;\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\tparse( onLoad, onError ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\t\tthis.nodeCache = {};\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\treturn ext._markDefs && ext._markDefs();\n\n\t\t} );\n\n\t\tPromise.all( this._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.beforeRoot && ext.beforeRoot();\n\n\t\t} ) ).then( function () {\n\n\t\t\treturn Promise.all( [\n\n\t\t\t\tparser.getDependencies( 'scene' ),\n\t\t\t\tparser.getDependencies( 'animation' ),\n\t\t\t\tparser.getDependencies( 'camera' ),\n\n\t\t\t] );\n\n\t\t} ).then( function ( dependencies ) {\n\n\t\t\tconst result = {\n\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\n\t\t\t\tscenes: dependencies[ 0 ],\n\t\t\t\tanimations: dependencies[ 1 ],\n\t\t\t\tcameras: dependencies[ 2 ],\n\t\t\t\tasset: json.asset,\n\t\t\t\tparser: parser,\n\t\t\t\tuserData: {}\n\t\t\t};\n\n\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\n\n\t\t\tassignExtrasToUserData( result, json );\n\n\t\t\treturn Promise.all( parser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.afterRoot && ext.afterRoot( result );\n\n\t\t\t} ) ).then( function () {\n\n\t\t\t\tfor ( const scene of result.scenes ) {\n\n\t\t\t\t\tscene.updateMatrixWorld();\n\n\t\t\t\t}\n\n\t\t\t\tonLoad( result );\n\n\t\t\t} );\n\n\t\t} ).catch( onError );\n\n\t}\n\n\t/**\n\t * Marks the special nodes/meshes in json for efficient parse.\n\t */\n\t_markDefs() {\n\n\t\tconst nodeDefs = this.json.nodes || [];\n\t\tconst skinDefs = this.json.skins || [];\n\t\tconst meshDefs = this.json.meshes || [];\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\n\n\t\t\tconst joints = skinDefs[ skinIndex ].joints;\n\n\t\t\tfor ( let i = 0, il = joints.length; i < il; i ++ ) {\n\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Iterate over all nodes, marking references to shared resources,\n\t\t// as well as skeleton joints.\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.meshCache, nodeDef.mesh );\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.cameraCache, nodeDef.camera );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Counts references to shared node / Object3D resources. These resources\n\t * can be reused, or \"instantiated\", at multiple nodes in the scene\n\t * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n\t * be marked. Non-scenegraph resources (like Materials, Geometries, and\n\t * Textures) can be reused directly and are not marked here.\n\t *\n\t * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t */\n\t_addNodeRef( cache, index ) {\n\n\t\tif ( index === undefined ) return;\n\n\t\tif ( cache.refs[ index ] === undefined ) {\n\n\t\t\tcache.refs[ index ] = cache.uses[ index ] = 0;\n\n\t\t}\n\n\t\tcache.refs[ index ] ++;\n\n\t}\n\n\t/** Returns a reference to a shared resource, cloning it if necessary. */\n\t_getNodeRef( cache, index, object ) {\n\n\t\tif ( cache.refs[ index ] <= 1 ) return object;\n\n\t\tconst ref = object.clone();\n\n\t\t// Propagates mappings to the cloned object, prevents mappings on the\n\t\t// original object from being lost.\n\t\tconst updateMappings = ( original, clone ) => {\n\n\t\t\tconst mappings = this.associations.get( original );\n\t\t\tif ( mappings != null ) {\n\n\t\t\t\tthis.associations.set( clone, mappings );\n\n\t\t\t}\n\n\t\t\tfor ( const [ i, child ] of original.children.entries() ) {\n\n\t\t\t\tupdateMappings( child, clone.children[ i ] );\n\n\t\t\t}\n\n\t\t};\n\n\t\tupdateMappings( object, ref );\n\n\t\tref.name += '_instance_' + ( cache.uses[ index ] ++ );\n\n\t\treturn ref;\n\n\t}\n\n\t_invokeOne( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.push( this );\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) return result;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t_invokeAll( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.unshift( this );\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) pending.push( result );\n\n\t\t}\n\n\t\treturn pending;\n\n\t}\n\n\t/**\n\t * Requests the specified dependency asynchronously, with caching.\n\t * @param {string} type\n\t * @param {number} index\n\t * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n\t */\n\tgetDependency( type, index ) {\n\n\t\tconst cacheKey = type + ':' + index;\n\t\tlet dependency = this.cache.get( cacheKey );\n\n\t\tif ( ! dependency ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'scene':\n\t\t\t\t\tdependency = this.loadScene( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'node':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadNode && ext.loadNode( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMesh && ext.loadMesh( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'accessor':\n\t\t\t\t\tdependency = this.loadAccessor( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bufferView':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadBufferView && ext.loadBufferView( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'buffer':\n\t\t\t\t\tdependency = this.loadBuffer( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'material':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMaterial && ext.loadMaterial( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadTexture && ext.loadTexture( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'skin':\n\t\t\t\t\tdependency = this.loadSkin( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'animation':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadAnimation && ext.loadAnimation( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'camera':\n\t\t\t\t\tdependency = this.loadCamera( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext != this && ext.getDependency && ext.getDependency( type, index );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tif ( ! dependency ) {\n\n\t\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.cache.add( cacheKey, dependency );\n\n\t\t}\n\n\t\treturn dependency;\n\n\t}\n\n\t/**\n\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t * @param {string} type\n\t * @return {Promise<Array<Object>>}\n\t */\n\tgetDependencies( type ) {\n\n\t\tlet dependencies = this.cache.get( type );\n\n\t\tif ( ! dependencies ) {\n\n\t\t\tconst parser = this;\n\t\t\tconst defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\n\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\n\n\t\t\t\treturn parser.getDependency( type, index );\n\n\t\t\t} ) );\n\n\t\t\tthis.cache.add( type, dependencies );\n\n\t\t}\n\n\t\treturn dependencies;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBuffer( bufferIndex ) {\n\n\t\tconst bufferDef = this.json.buffers[ bufferIndex ];\n\t\tconst loader = this.fileLoader;\n\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\n\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\n\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\n\n\t\t}\n\n\t\tconst options = this.options;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tloader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\n\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferViewIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBufferView( bufferViewIndex ) {\n\n\t\tconst bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\n\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\n\n\t\t\tconst byteLength = bufferViewDef.byteLength || 0;\n\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t * @param {number} accessorIndex\n\t * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n\t */\n\tloadAccessor( accessorIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst accessorDef = this.json.accessors[ accessorIndex ];\n\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\t\t\tconst normalized = accessorDef.normalized === true;\n\n\t\t\tconst array = new TypedArray( accessorDef.count * itemSize );\n\t\t\treturn Promise.resolve( new BufferAttribute( array, itemSize, normalized ) );\n\n\t\t}\n\n\t\tconst pendingBufferViews = [];\n\n\t\tif ( accessorDef.bufferView !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\n\n\t\t} else {\n\n\t\t\tpendingBufferViews.push( null );\n\n\t\t}\n\n\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\n\n\t\t}\n\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\n\n\t\t\tconst bufferView = bufferViews[ 0 ];\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tconst elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tconst itemBytes = elementBytes * itemSize;\n\t\t\tconst byteOffset = accessorDef.byteOffset || 0;\n\t\t\tconst byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\n\t\t\tconst normalized = accessorDef.normalized === true;\n\t\t\tlet array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\n\n\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\n\t\t\t\tconst ibSlice = Math.floor( byteOffset / byteStride );\n\t\t\t\tconst ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n\t\t\t\tlet ib = parser.cache.get( ibCacheKey );\n\n\t\t\t\tif ( ! ib ) {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new InterleavedBuffer( array, byteStride / elementBytes );\n\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\n\n\t\t\t} else {\n\n\t\t\t\tif ( bufferView === null ) {\n\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\tconst itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tconst TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\n\n\t\t\t\tconst byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tconst byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tconst sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\n\t\t\t\tconst sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\n\n\t\t\t\tif ( bufferView !== null ) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst index = sparseIndices[ i ];\n\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t * @param {number} textureIndex\n\t * @return {Promise<THREE.Texture|null>}\n\t */\n\tloadTexture( textureIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst sourceIndex = textureDef.source;\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tlet loader = this.textureLoader;\n\n\t\tif ( sourceDef.uri ) {\n\n\t\t\tconst handler = options.manager.getHandler( sourceDef.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.loadTextureImage( textureIndex, sourceIndex, loader );\n\n\t}\n\n\tloadTextureImage( textureIndex, sourceIndex, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tconst cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;\n\n\t\tif ( this.textureCache[ cacheKey ] ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21559.\n\t\t\treturn this.textureCache[ cacheKey ];\n\n\t\t}\n\n\t\tconst promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {\n\n\t\t\ttexture.flipY = false;\n\n\t\t\ttexture.name = textureDef.name || sourceDef.name || '';\n\n\t\t\tif ( texture.name === '' && typeof sourceDef.uri === 'string' && sourceDef.uri.startsWith( 'data:image/' ) === false ) {\n\n\t\t\t\ttexture.name = sourceDef.uri;\n\n\t\t\t}\n\n\t\t\tconst samplers = json.samplers || {};\n\t\t\tconst sampler = samplers[ textureDef.sampler ] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;\n\n\t\t\tparser.associations.set( texture, { textures: textureIndex } );\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function () {\n\n\t\t\treturn null;\n\n\t\t} );\n\n\t\tthis.textureCache[ cacheKey ] = promise;\n\n\t\treturn promise;\n\n\t}\n\n\tloadImageSource( sourceIndex, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( this.sourceCache[ sourceIndex ] !== undefined ) {\n\n\t\t\treturn this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );\n\n\t\t}\n\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tconst URL = self.URL || self.webkitURL;\n\n\t\tlet sourceURI = sourceDef.uri || '';\n\t\tlet isObjectURL = false;\n\n\t\tif ( sourceDef.bufferView !== undefined ) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tconst blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\n\t\t\t\treturn sourceURI;\n\n\t\t\t} );\n\n\t\t} else if ( sourceDef.uri === undefined ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );\n\n\t\t}\n\n\t\tconst promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tlet onLoad = resolve;\n\n\t\t\t\tif ( loader.isImageBitmapLoader === true ) {\n\n\t\t\t\t\tonLoad = function ( imageBitmap ) {\n\n\t\t\t\t\t\tconst texture = new Texture( imageBitmap );\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tresolve( texture );\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tloader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );\n\n\t\t\t} );\n\n\t\t} ).then( function ( texture ) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif ( isObjectURL === true ) {\n\n\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( texture, sourceDef );\n\n\t\t\ttexture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function ( error ) {\n\n\t\t\tconsole.error( 'THREE.GLTFLoader: Couldn\\'t load texture', sourceURI );\n\t\t\tthrow error;\n\n\t\t} );\n\n\t\tthis.sourceCache[ sourceIndex ] = promise;\n\t\treturn promise;\n\n\t}\n\n\t/**\n\t * Asynchronously assigns a texture to the given material parameters.\n\t * @param {Object} materialParams\n\t * @param {string} mapName\n\t * @param {Object} mapDef\n\t * @return {Promise<Texture>}\n\t */\n\tassignTexture( materialParams, mapName, mapDef, colorSpace ) {\n\n\t\tconst parser = this;\n\n\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\n\n\t\t\tif ( ! texture ) return null;\n\n\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord > 0 ) {\n\n\t\t\t\ttexture = texture.clone();\n\t\t\t\ttexture.channel = mapDef.texCoord;\n\n\t\t\t}\n\n\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\n\n\t\t\t\tconst transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\tconst gltfReference = parser.associations.get( texture );\n\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\n\t\t\t\t\tparser.associations.set( texture, gltfReference );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( colorSpace !== undefined ) {\n\n\t\t\t\ttexture.colorSpace = colorSpace;\n\n\t\t\t}\n\n\t\t\tmaterialParams[ mapName ] = texture;\n\n\t\t\treturn texture;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\n\t * already has a material (generated from the glTF material options alone)\n\t * but reuse of the same glTF material may require multiple threejs materials\n\t * to accommodate different primitive types, defines, etc. New materials will\n\t * be created if necessary, and reused from a cache.\n\t * @param  {Object3D} mesh Mesh, Line, or Points instance.\n\t */\n\tassignFinalMaterial( mesh ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tlet material = mesh.material;\n\n\t\tconst useDerivativeTangents = geometry.attributes.tangent === undefined;\n\t\tconst useVertexColors = geometry.attributes.color !== undefined;\n\t\tconst useFlatShading = geometry.attributes.normal === undefined;\n\n\t\tif ( mesh.isPoints ) {\n\n\t\t\tconst cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\tlet pointsMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! pointsMaterial ) {\n\n\t\t\t\tpointsMaterial = new PointsMaterial();\n\t\t\t\tMaterial.prototype.copy.call( pointsMaterial, material );\n\t\t\t\tpointsMaterial.color.copy( material.color );\n\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = pointsMaterial;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tconst cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\tlet lineMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! lineMaterial ) {\n\n\t\t\t\tlineMaterial = new LineBasicMaterial();\n\t\t\t\tMaterial.prototype.copy.call( lineMaterial, material );\n\t\t\t\tlineMaterial.color.copy( material.color );\n\t\t\t\tlineMaterial.map = material.map;\n\n\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = lineMaterial;\n\n\t\t}\n\n\t\t// Clone the material if it will be modified\n\t\tif ( useDerivativeTangents || useVertexColors || useFlatShading ) {\n\n\t\t\tlet cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n\t\t\tif ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';\n\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\n\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\n\n\t\t\tlet cachedMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! cachedMaterial ) {\n\n\t\t\t\tcachedMaterial = material.clone();\n\n\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\n\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\n\n\t\t\t\tif ( useDerivativeTangents ) {\n\n\t\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\t\tif ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;\n\t\t\t\t\tif ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\n\n\t\t\t\tthis.associations.set( cachedMaterial, this.associations.get( material ) );\n\n\t\t\t}\n\n\t\t\tmaterial = cachedMaterial;\n\n\t\t}\n\n\t\tmesh.material = material;\n\n\t}\n\n\tgetMaterialType( /* materialIndex */ ) {\n\n\t\treturn MeshStandardMaterial;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t * @param {number} materialIndex\n\t * @return {Promise<Material>}\n\t */\n\tloadMaterial( materialIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst materialDef = json.materials[ materialIndex ];\n\n\t\tlet materialType;\n\t\tconst materialParams = {};\n\t\tconst materialExtensions = materialDef.extensions || {};\n\n\t\tconst pending = [];\n\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\n\n\t\t\tconst kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\n\t\t\tmaterialType = kmuExtension.getMaterialType();\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );\n\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialType = this._invokeOne( function ( ext ) {\n\n\t\t\t\treturn ext.getMaterialType && ext.getMaterialType( materialIndex );\n\n\t\t\t} );\n\n\t\t\tpending.push( Promise.all( this._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );\n\n\t\t\t} ) ) );\n\n\t\t}\n\n\t\tif ( materialDef.doubleSided === true ) {\n\n\t\t\tmaterialParams.side = DoubleSide;\n\n\t\t}\n\n\t\tconst alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\n\n\t\t\tmaterialParams.transparent = true;\n\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\n\t\t\tmaterialParams.depthWrite = false;\n\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\n\n\t\t\tmaterialParams.normalScale = new Vector2( 1, 1 );\n\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = materialDef.normalTexture.scale;\n\n\t\t\t\tmaterialParams.normalScale.set( scale, scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\n\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tconst emissiveFactor = materialDef.emissiveFactor;\n\t\t\tmaterialParams.emissive = new Color().setRGB( emissiveFactor[ 0 ], emissiveFactor[ 1 ], emissiveFactor[ 2 ], LinearSRGBColorSpace );\n\n\t\t}\n\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\tconst material = new materialType( materialParams );\n\n\t\t\tif ( materialDef.name ) material.name = materialDef.name;\n\n\t\t\tassignExtrasToUserData( material, materialDef );\n\n\t\t\tparser.associations.set( material, { materials: materialIndex } );\n\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\n\n\t\t\treturn material;\n\n\t\t} );\n\n\t}\n\n\t/** When Object3D instances are targeted by animation, they need unique names. */\n\tcreateUniqueName( originalName ) {\n\n\t\tconst sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );\n\n\t\tif ( sanitizedName in this.nodeNamesUsed ) {\n\n\t\t\treturn sanitizedName + '_' + ( ++ this.nodeNamesUsed[ sanitizedName ] );\n\n\t\t} else {\n\n\t\t\tthis.nodeNamesUsed[ sanitizedName ] = 0;\n\n\t\t\treturn sanitizedName;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t *\n\t * Creates BufferGeometries from primitives.\n\t *\n\t * @param {Array<GLTF.Primitive>} primitives\n\t * @return {Promise<Array<BufferGeometry>>}\n\t */\n\tloadGeometries( primitives ) {\n\n\t\tconst parser = this;\n\t\tconst extensions = this.extensions;\n\t\tconst cache = this.primitiveCache;\n\n\t\tfunction createDracoPrimitive( primitive ) {\n\n\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\n\t\t\t\t.decodePrimitive( primitive, parser )\n\t\t\t\t.then( function ( geometry ) {\n\n\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = primitives[ i ];\n\t\t\tconst cacheKey = createPrimitiveKey( primitive );\n\n\t\t\t// See if we've already created this geometry\n\t\t\tconst cached = cache[ cacheKey ];\n\n\t\t\tif ( cached ) {\n\n\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\tpending.push( cached.promise );\n\n\t\t\t} else {\n\n\t\t\t\tlet geometryPromise;\n\n\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\n\n\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );\n\n\t\t\t\t}\n\n\t\t\t\t// Cache this geometry\n\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\n\n\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t * @param {number} meshIndex\n\t * @return {Promise<Group|Mesh|SkinnedMesh>}\n\t */\n\tloadMesh( meshIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\tconst meshDef = json.meshes[ meshIndex ];\n\t\tconst primitives = meshDef.primitives;\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst material = primitives[ i ].material === undefined\n\t\t\t\t? createDefaultMaterial( this.cache )\n\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\n\n\t\t\tpending.push( material );\n\n\t\t}\n\n\t\tpending.push( parser.loadGeometries( primitives ) );\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst materials = results.slice( 0, results.length - 1 );\n\t\t\tconst geometries = results[ results.length - 1 ];\n\n\t\t\tconst meshes = [];\n\n\t\t\tfor ( let i = 0, il = geometries.length; i < il; i ++ ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\t// 1. create Mesh\n\n\t\t\t\tlet mesh;\n\n\t\t\t\tconst material = materials[ i ];\n\n\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n\t\t\t\t\t\tprimitive.mode === undefined ) {\n\n\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\n\t\t\t\t\t\t? new SkinnedMesh( geometry, material )\n\t\t\t\t\t\t: new Mesh( geometry, material );\n\n\t\t\t\t\tif ( mesh.isSkinnedMesh === true ) {\n\n\t\t\t\t\t\t// normalize skin weights to fix malformed assets (see #15319)\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\n\n\t\t\t\t\tmesh = new LineSegments( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\n\n\t\t\t\t\tmesh = new Line( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\n\n\t\t\t\t\tmesh = new LineLoop( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\n\n\t\t\t\t\tmesh = new Points( geometry, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\n\n\t\t\t\t}\n\n\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\n\n\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\n\n\t\t\t\t}\n\n\t\t\t\tmesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );\n\n\t\t\t\tassignExtrasToUserData( mesh, meshDef );\n\n\t\t\t\tif ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );\n\n\t\t\t\tparser.assignFinalMaterial( mesh );\n\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tparser.associations.set( meshes[ i ], {\n\t\t\t\t\tmeshes: meshIndex,\n\t\t\t\t\tprimitives: i\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( meshes.length === 1 ) {\n\n\t\t\t\tif ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, meshes[ 0 ], meshDef );\n\n\t\t\t\treturn meshes[ 0 ];\n\n\t\t\t}\n\n\t\t\tconst group = new Group();\n\n\t\t\tif ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, group, meshDef );\n\n\t\t\tparser.associations.set( group, { meshes: meshIndex } );\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t * @param {number} cameraIndex\n\t * @return {Promise<THREE.Camera>}\n\t */\n\tloadCamera( cameraIndex ) {\n\n\t\tlet camera;\n\t\tconst cameraDef = this.json.cameras[ cameraIndex ];\n\t\tconst params = cameraDef[ cameraDef.type ];\n\n\t\tif ( ! params ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( cameraDef.type === 'perspective' ) {\n\n\t\t\tcamera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\n\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\n\n\t\t\tcamera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );\n\n\t\t}\n\n\t\tif ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );\n\n\t\tassignExtrasToUserData( camera, cameraDef );\n\n\t\treturn Promise.resolve( camera );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t * @param {number} skinIndex\n\t * @return {Promise<Skeleton>}\n\t */\n\tloadSkin( skinIndex ) {\n\n\t\tconst skinDef = this.json.skins[ skinIndex ];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = skinDef.joints.length; i < il; i ++ ) {\n\n\t\t\tpending.push( this._loadNodeShallow( skinDef.joints[ i ] ) );\n\n\t\t}\n\n\t\tif ( skinDef.inverseBindMatrices !== undefined ) {\n\n\t\t\tpending.push( this.getDependency( 'accessor', skinDef.inverseBindMatrices ) );\n\n\t\t} else {\n\n\t\t\tpending.push( null );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst inverseBindMatrices = results.pop();\n\t\t\tconst jointNodes = results;\n\n\t\t\t// Note that bones (joint nodes) may or may not be in the\n\t\t\t// scene graph at this time.\n\n\t\t\tconst bones = [];\n\t\t\tconst boneInverses = [];\n\n\t\t\tfor ( let i = 0, il = jointNodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst jointNode = jointNodes[ i ];\n\n\t\t\t\tif ( jointNode ) {\n\n\t\t\t\t\tbones.push( jointNode );\n\n\t\t\t\t\tconst mat = new Matrix4();\n\n\t\t\t\t\tif ( inverseBindMatrices !== null ) {\n\n\t\t\t\t\t\tmat.fromArray( inverseBindMatrices.array, i * 16 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneInverses.push( mat );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new Skeleton( bones, boneInverses );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t * @param {number} animationIndex\n\t * @return {Promise<AnimationClip>}\n\t */\n\tloadAnimation( animationIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\n\t\tconst animationDef = json.animations[ animationIndex ];\n\t\tconst animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n\n\t\tconst pendingNodes = [];\n\t\tconst pendingInputAccessors = [];\n\t\tconst pendingOutputAccessors = [];\n\t\tconst pendingSamplers = [];\n\t\tconst pendingTargets = [];\n\n\t\tfor ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\tconst channel = animationDef.channels[ i ];\n\t\t\tconst sampler = animationDef.samplers[ channel.sampler ];\n\t\t\tconst target = channel.target;\n\t\t\tconst name = target.node;\n\t\t\tconst input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\tconst output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\tif ( target.node === undefined ) continue;\n\n\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\n\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\n\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\n\t\t\tpendingSamplers.push( sampler );\n\t\t\tpendingTargets.push( target );\n\n\t\t}\n\n\t\treturn Promise.all( [\n\n\t\t\tPromise.all( pendingNodes ),\n\t\t\tPromise.all( pendingInputAccessors ),\n\t\t\tPromise.all( pendingOutputAccessors ),\n\t\t\tPromise.all( pendingSamplers ),\n\t\t\tPromise.all( pendingTargets )\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tconst nodes = dependencies[ 0 ];\n\t\t\tconst inputAccessors = dependencies[ 1 ];\n\t\t\tconst outputAccessors = dependencies[ 2 ];\n\t\t\tconst samplers = dependencies[ 3 ];\n\t\t\tconst targets = dependencies[ 4 ];\n\n\t\t\tconst tracks = [];\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst node = nodes[ i ];\n\t\t\t\tconst inputAccessor = inputAccessors[ i ];\n\t\t\t\tconst outputAccessor = outputAccessors[ i ];\n\t\t\t\tconst sampler = samplers[ i ];\n\t\t\t\tconst target = targets[ i ];\n\n\t\t\t\tif ( node === undefined ) continue;\n\n\t\t\t\tif ( node.updateMatrix ) {\n\n\t\t\t\t\tnode.updateMatrix();\n\n\t\t\t\t}\n\n\t\t\t\tconst createdTracks = parser._createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target );\n\n\t\t\t\tif ( createdTracks ) {\n\n\t\t\t\t\tfor ( let k = 0; k < createdTracks.length; k ++ ) {\n\n\t\t\t\t\t\ttracks.push( createdTracks[ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( animationName, undefined, tracks );\n\n\t\t} );\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( nodeDef.mesh === undefined ) return null;\n\n\t\treturn parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\n\n\t\t\tconst node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );\n\n\t\t\t// if weights are provided on the node, override weights on the mesh.\n\t\t\tif ( nodeDef.weights !== undefined ) {\n\n\t\t\t\tnode.traverse( function ( o ) {\n\n\t\t\t\t\tif ( ! o.isMesh ) return;\n\n\t\t\t\t\tfor ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t * @param {number} nodeIndex\n\t * @return {Promise<Object3D>}\n\t */\n\tloadNode( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tconst nodePending = parser._loadNodeShallow( nodeIndex );\n\n\t\tconst childPending = [];\n\t\tconst childrenDef = nodeDef.children || [];\n\n\t\tfor ( let i = 0, il = childrenDef.length; i < il; i ++ ) {\n\n\t\t\tchildPending.push( parser.getDependency( 'node', childrenDef[ i ] ) );\n\n\t\t}\n\n\t\tconst skeletonPending = nodeDef.skin === undefined\n\t\t\t? Promise.resolve( null )\n\t\t\t: parser.getDependency( 'skin', nodeDef.skin );\n\n\t\treturn Promise.all( [\n\t\t\tnodePending,\n\t\t\tPromise.all( childPending ),\n\t\t\tskeletonPending\n\t\t] ).then( function ( results ) {\n\n\t\t\tconst node = results[ 0 ];\n\t\t\tconst children = results[ 1 ];\n\t\t\tconst skeleton = results[ 2 ];\n\n\t\t\tif ( skeleton !== null ) {\n\n\t\t\t\t// This full traverse should be fine because\n\t\t\t\t// child glTF nodes have not been added to this node yet.\n\t\t\t\tnode.traverse( function ( mesh ) {\n\n\t\t\t\t\tif ( ! mesh.isSkinnedMesh ) return;\n\n\t\t\t\t\tmesh.bind( skeleton, _identityMatrix );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = children.length; i < il; i ++ ) {\n\n\t\t\t\tnode.add( children[ i ] );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t// ._loadNodeShallow() parses a single node.\n\t// skin and child nodes are created and added in .loadNode() (no '_' prefix).\n\t_loadNodeShallow( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst parser = this;\n\n\t\t// This method is called from .loadNode() and .loadSkin().\n\t\t// Cache a node to avoid duplication.\n\n\t\tif ( this.nodeCache[ nodeIndex ] !== undefined ) {\n\n\t\t\treturn this.nodeCache[ nodeIndex ];\n\n\t\t}\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\t// reserve node's name before its dependencies, so the root has the intended name.\n\t\tconst nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';\n\n\t\tconst pending = [];\n\n\t\tconst meshPromise = parser._invokeOne( function ( ext ) {\n\n\t\t\treturn ext.createNodeMesh && ext.createNodeMesh( nodeIndex );\n\n\t\t} );\n\n\t\tif ( meshPromise ) {\n\n\t\t\tpending.push( meshPromise );\n\n\t\t}\n\n\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {\n\n\t\t\t\treturn parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );\n\n\t\t\t} ) );\n\n\t\t}\n\n\t\tparser._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );\n\n\t\t} ).forEach( function ( promise ) {\n\n\t\t\tpending.push( promise );\n\n\t\t} );\n\n\t\tthis.nodeCache[ nodeIndex ] = Promise.all( pending ).then( function ( objects ) {\n\n\t\t\tlet node;\n\n\t\t\t// .isBone isn't in glTF spec. See ._markDefs\n\t\t\tif ( nodeDef.isBone === true ) {\n\n\t\t\t\tnode = new Bone();\n\n\t\t\t} else if ( objects.length > 1 ) {\n\n\t\t\t\tnode = new Group();\n\n\t\t\t} else if ( objects.length === 1 ) {\n\n\t\t\t\tnode = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tnode = new Object3D();\n\n\t\t\t}\n\n\t\t\tif ( node !== objects[ 0 ] ) {\n\n\t\t\t\tfor ( let i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\tnode.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.name ) {\n\n\t\t\t\tnode.userData.name = nodeDef.name;\n\t\t\t\tnode.name = nodeName;\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( node, nodeDef );\n\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\n\n\t\t\tif ( nodeDef.matrix !== undefined ) {\n\n\t\t\t\tconst matrix = new Matrix4();\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\n\t\t\t\tnode.applyMatrix4( matrix );\n\n\t\t\t} else {\n\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\n\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\n\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\n\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! parser.associations.has( node ) ) {\n\n\t\t\t\tparser.associations.set( node, {} );\n\n\t\t\t}\n\n\t\t\tparser.associations.get( node ).nodes = nodeIndex;\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t\treturn this.nodeCache[ nodeIndex ];\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t * @param {number} sceneIndex\n\t * @return {Promise<Group>}\n\t */\n\tloadScene( sceneIndex ) {\n\n\t\tconst extensions = this.extensions;\n\t\tconst sceneDef = this.json.scenes[ sceneIndex ];\n\t\tconst parser = this;\n\n\t\t// Loader returns Group, not Scene.\n\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\t\tconst scene = new Group();\n\t\tif ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );\n\n\t\tassignExtrasToUserData( scene, sceneDef );\n\n\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\n\n\t\tconst nodeIds = sceneDef.nodes || [];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = nodeIds.length; i < il; i ++ ) {\n\n\t\t\tpending.push( parser.getDependency( 'node', nodeIds[ i ] ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function ( nodes ) {\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tscene.add( nodes[ i ] );\n\n\t\t\t}\n\n\t\t\t// Removes dangling associations, associations that reference a node that\n\t\t\t// didn't make it into the scene.\n\t\t\tconst reduceAssociations = ( node ) => {\n\n\t\t\t\tconst reducedAssociations = new Map();\n\n\t\t\t\tfor ( const [ key, value ] of parser.associations ) {\n\n\t\t\t\t\tif ( key instanceof Material || key instanceof Texture ) {\n\n\t\t\t\t\t\treducedAssociations.set( key, value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnode.traverse( ( node ) => {\n\n\t\t\t\t\tconst mappings = parser.associations.get( node );\n\n\t\t\t\t\tif ( mappings != null ) {\n\n\t\t\t\t\t\treducedAssociations.set( node, mappings );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn reducedAssociations;\n\n\t\t\t};\n\n\t\t\tparser.associations = reduceAssociations( scene );\n\n\t\t\treturn scene;\n\n\t\t} );\n\n\t}\n\n\t_createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target ) {\n\n\t\tconst tracks = [];\n\n\t\tconst targetName = node.name ? node.name : node.uuid;\n\t\tconst targetNames = [];\n\n\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\n\n\t\t\tnode.traverse( function ( object ) {\n\n\t\t\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\ttargetNames.push( targetName );\n\n\t\t}\n\n\t\tlet TypedKeyframeTrack;\n\n\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\n\n\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\tTypedKeyframeTrack = QuaternionKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tcase PATH_PROPERTIES.position:\n\t\t\tcase PATH_PROPERTIES.scale:\n\n\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tswitch ( outputAccessor.itemSize ) {\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\tcase 3:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tconst interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;\n\n\n\t\tconst outputArray = this._getArrayFromAccessor( outputAccessor );\n\n\t\tfor ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {\n\n\t\t\tconst track = new TypedKeyframeTrack(\n\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\n\t\t\t\tinputAccessor.array,\n\t\t\t\toutputArray,\n\t\t\t\tinterpolation\n\t\t\t);\n\n\t\t\t// Override interpolation with custom factory method.\n\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\tthis._createCubicSplineTrackInterpolant( track );\n\n\t\t\t}\n\n\t\t\ttracks.push( track );\n\n\t\t}\n\n\t\treturn tracks;\n\n\t}\n\n\t_getArrayFromAccessor( accessor ) {\n\n\t\tlet outputArray = accessor.array;\n\n\t\tif ( accessor.normalized ) {\n\n\t\t\tconst scale = getNormalizedComponentScale( outputArray.constructor );\n\t\t\tconst scaled = new Float32Array( outputArray.length );\n\n\t\t\tfor ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {\n\n\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\n\n\t\t\t}\n\n\t\t\toutputArray = scaled;\n\n\t\t}\n\n\t\treturn outputArray;\n\n\t}\n\n\t_createCubicSplineTrackInterpolant( track ) {\n\n\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\n\n\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\tconst interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n\n\t\t\treturn new interpolantType( this.times, this.values, this.getValueSize() / 3, result );\n\n\t\t};\n\n\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n\t}\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst box = new Box3();\n\n\tif ( attributes.POSITION !== undefined ) {\n\n\t\tconst accessor = parser.json.accessors[ attributes.POSITION ];\n\n\t\tconst min = accessor.min;\n\t\tconst max = accessor.max;\n\n\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\tbox.set(\n\t\t\t\tnew Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),\n\t\t\t\tnew Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )\n\t\t\t);\n\n\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\tbox.min.multiplyScalar( boxScale );\n\t\t\t\tbox.max.multiplyScalar( boxScale );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\treturn;\n\n\t\t}\n\n\t} else {\n\n\t\treturn;\n\n\t}\n\n\tconst targets = primitiveDef.targets;\n\n\tif ( targets !== undefined ) {\n\n\t\tconst maxDisplacement = new Vector3();\n\t\tconst vector = new Vector3();\n\n\t\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tconst target = targets[ i ];\n\n\t\t\tif ( target.POSITION !== undefined ) {\n\n\t\t\t\tconst accessor = parser.json.accessors[ target.POSITION ];\n\t\t\t\tconst min = accessor.min;\n\t\t\t\tconst max = accessor.max;\n\n\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\n\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\n\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\n\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\n\n\n\t\t\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\t\t\tvector.multiplyScalar( boxScale );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\n\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\t\t\t\t\tmaxDisplacement.max( vector );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\t\tbox.expandByVector( maxDisplacement );\n\n\t}\n\n\tgeometry.boundingBox = box;\n\n\tconst sphere = new Sphere();\n\n\tbox.getCenter( sphere.center );\n\tsphere.radius = box.min.distanceTo( box.max ) / 2;\n\n\tgeometry.boundingSphere = sphere;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst pending = [];\n\n\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\n\n\t\treturn parser.getDependency( 'accessor', accessorIndex )\n\t\t\t.then( function ( accessor ) {\n\n\t\t\t\tgeometry.setAttribute( attributeName, accessor );\n\n\t\t\t} );\n\n\t}\n\n\tfor ( const gltfAttributeName in attributes ) {\n\n\t\tconst threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\n\n\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\tif ( threeAttributeName in geometry.attributes ) continue;\n\n\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\n\n\t}\n\n\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\n\n\t\tconst accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\n\n\t\t\tgeometry.setIndex( accessor );\n\n\t\t} );\n\n\t\tpending.push( accessor );\n\n\t}\n\n\tif ( ColorManagement.workingColorSpace !== LinearSRGBColorSpace && 'COLOR_0' in attributes ) {\n\n\t\tconsole.warn( `THREE.GLTFLoader: Converting vertex colors from \"srgb-linear\" to \"${ColorManagement.workingColorSpace}\" not supported.` );\n\n\t}\n\n\tassignExtrasToUserData( geometry, primitiveDef );\n\n\tcomputeBounds( geometry, primitiveDef, parser );\n\n\treturn Promise.all( pending ).then( function () {\n\n\t\treturn primitiveDef.targets !== undefined\n\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\n\t\t\t: geometry;\n\n\t} );\n\n}\n\nexport { GLTFLoader };\n", "import { Matrix4, Quaternion } from 'three';\nexport function createHandPoseState(hand) {\n    return {\n        //distances: {},\n        //name: undefined,\n        data: new Float32Array(hand.size * 16),\n    };\n}\nexport function updateXRHandPoseState(state, frame, hand, manager, handedness) {\n    const referenceSpace = manager.getReferenceSpace();\n    /*for (const key in poseUrls) {\n      state.distances[key] = Infinity\n    }*/\n    if (referenceSpace == null ||\n        frame == null ||\n        frame.session.visibilityState === 'visible-blurred' ||\n        frame.session.visibilityState === 'hidden') {\n        //state.name = undefined\n        return;\n    }\n    const validPose = updateXRHandPoseData(frame, referenceSpace, hand, state.data);\n    if (!validPose) {\n        //state.name = undefined\n        return;\n    }\n    let closestPoseName;\n    let closestPoseDistance;\n    /*for (const key in poseUrls) {\n      const pose = loadXRHandPose(poseUrls[key])\n      if (pose == null) {\n        continue\n      }\n      const distance = getXRHandPoseDistance(state.data, pose, handedness === 'left')\n  \n      if (closestPoseDistance != null && distance >= closestPoseDistance) {\n        continue\n      }\n  \n      state.distances[key] = distance\n      closestPoseDistance = distance\n      closestPoseName = key\n    }\n  \n    state.name = closestPoseName*/\n}\nconst invertedWirstHelper = new Matrix4();\nconst matrixHelper = new Matrix4();\nfunction updateXRHandPoseData(frame, referenceSpace, hand, handPoseData) {\n    const validPose = frame.fillPoses(hand.values(), referenceSpace, handPoseData);\n    if (!validPose) {\n        return false;\n    }\n    //calculate bone poses in relation to the wrist\n    // The first item in hand pose information is the wrist\n    invertedWirstHelper.fromArray(handPoseData, 0);\n    invertedWirstHelper.invert();\n    for (let i = 0; i < handPoseData.length; i += 16) {\n        matrixHelper.fromArray(handPoseData, i);\n        matrixHelper.premultiply(invertedWirstHelper);\n        matrixHelper.toArray(handPoseData, i);\n    }\n    return true;\n}\nconst tempMat2 = new Matrix4();\nconst tempMat1 = new Matrix4();\nconst tempQuat2 = new Quaternion();\nconst tempQuat1 = new Quaternion();\nfunction getXRHandPoseDistance(hpData1, phData2, mirrorHP2) {\n    const length = Math.min(hpData1.length, phData2.length);\n    if (length === 0) {\n        return Infinity;\n    }\n    let dist = 0;\n    for (let i = 0; i < length; i += 16) {\n        tempQuat1.setFromRotationMatrix(tempMat1.fromArray(hpData1, i));\n        tempQuat2.setFromRotationMatrix(tempMat2.fromArray(phData2, i));\n        if (mirrorHP2) {\n            mirrorQuaterionOnXAxis(tempQuat2);\n        }\n        dist += tempQuat2.angleTo(tempQuat1);\n    }\n    return dist / (length * 16);\n}\nexport function downloadHandPoseData(handed, handPoseData) {\n    if (handed === 'left') {\n        const length = handPoseData.length;\n        const mirroredHandPoseData = new Float32Array(length);\n        for (let i = 0; i < length; i += 16) {\n            tempMat2.fromArray(handPoseData, i);\n            tempQuat2.setFromRotationMatrix(tempMat2);\n            mirrorQuaterionOnXAxis(tempQuat2);\n            // Copies the rotation component of the supplied matrix m into this matrix rotation component.\n            tempMat2.makeRotationFromQuaternion(tempQuat2);\n            tempMat2.toArray(mirroredHandPoseData, i);\n        }\n        handPoseData = mirroredHandPoseData;\n    }\n    const a = window.document.createElement('a');\n    a.href = window.URL.createObjectURL(new Blob([handPoseData], { type: 'application/octet-stream' }));\n    a.download = 'untitled.handpose';\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n}\n//null means that we are currently loading the pose\nconst poseStorage = new Map();\nfunction loadXRHandPose(path) {\n    const href = new URL(path, window.location.href).href;\n    const pose = poseStorage.get(href);\n    if (pose != null) {\n        return pose;\n    }\n    if (pose === undefined) {\n        //loading process was never started\n        poseStorage.set(href, null);\n        //start loading process and save to poseStorage\n        fetch(href)\n            .then((response) => response.arrayBuffer())\n            .then((buffer) => poseStorage.set(href, new Float32Array(buffer)))\n            .catch(console.error);\n    }\n    return undefined;\n}\nfunction mirrorQuaterionOnXAxis(quaternion) {\n    quaternion.x = -quaternion.x;\n    quaternion.w = -quaternion.w;\n}\n", "import {\n\tAnimationClip,\n\tAnimationMixer,\n\tMatrix4,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tSkeletonHelper,\n\tVector3,\n\tVectorKeyframeTrack\n} from 'three';\n\n\nfunction retarget( target, source, options = {} ) {\n\n\tconst pos = new Vector3(),\n\t\tquat = new Quaternion(),\n\t\tscale = new Vector3(),\n\t\tbindBoneMatrix = new Matrix4(),\n\t\trelativeMatrix = new Matrix4(),\n\t\tglobalMatrix = new Matrix4();\n\n\toptions.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n\toptions.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n\toptions.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n\toptions.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\toptions.names = options.names || {};\n\n\tconst sourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),\n\t\tbones = target.isObject3D ? target.skeleton.bones : getBones( target );\n\n\tlet bindBones,\n\t\tbone, name, boneTo,\n\t\tbonesPosition;\n\n\t// reset bones\n\n\tif ( target.isObject3D ) {\n\n\t\ttarget.skeleton.pose();\n\n\t} else {\n\n\t\toptions.useTargetMatrix = true;\n\t\toptions.preserveMatrix = false;\n\n\t}\n\n\tif ( options.preservePosition ) {\n\n\t\tbonesPosition = [];\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tbonesPosition.push( bones[ i ].position.clone() );\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveMatrix ) {\n\n\t\t// reset matrix\n\n\t\ttarget.updateMatrixWorld();\n\n\t\ttarget.matrixWorld.identity();\n\n\t\t// reset children matrix\n\n\t\tfor ( let i = 0; i < target.children.length; ++ i ) {\n\n\t\t\ttarget.children[ i ].updateMatrixWorld( true );\n\n\t\t}\n\n\t}\n\n\tif ( options.offsets ) {\n\n\t\tbindBones = [];\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\tif ( options.offsets[ name ] ) {\n\n\t\t\t\tbone.matrix.multiply( options.offsets[ name ] );\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\tbone.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\tbindBones.push( bone.matrixWorld.clone() );\n\n\t\t}\n\n\t}\n\n\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\tbone = bones[ i ];\n\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\tboneTo = getBoneByName( name, sourceBones );\n\n\t\tglobalMatrix.copy( bone.matrixWorld );\n\n\t\tif ( boneTo ) {\n\n\t\t\tboneTo.updateMatrixWorld();\n\n\t\t\tif ( options.useTargetMatrix ) {\n\n\t\t\t\trelativeMatrix.copy( boneTo.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\trelativeMatrix.copy( target.matrixWorld ).invert();\n\t\t\t\trelativeMatrix.multiply( boneTo.matrixWorld );\n\n\t\t\t}\n\n\t\t\t// ignore scale to extract rotation\n\n\t\t\tscale.setFromMatrixScale( relativeMatrix );\n\t\t\trelativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );\n\n\t\t\t// apply to global matrix\n\n\t\t\tglobalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );\n\n\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\tconst boneIndex = bones.indexOf( bone ),\n\t\t\t\t\twBindMatrix = bindBones ? bindBones[ boneIndex ] : bindBoneMatrix.copy( target.skeleton.boneInverses[ boneIndex ] ).invert();\n\n\t\t\t\tglobalMatrix.multiply( wBindMatrix );\n\n\t\t\t}\n\n\t\t\tglobalMatrix.copyPosition( relativeMatrix );\n\n\t\t}\n\n\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\tbone.matrix.multiply( globalMatrix );\n\n\t\t} else {\n\n\t\t\tbone.matrix.copy( globalMatrix );\n\n\t\t}\n\n\t\tif ( options.preserveHipPosition && name === options.hip ) {\n\n\t\t\tbone.matrix.setPosition( pos.set( 0, bone.position.y, 0 ) );\n\n\t\t}\n\n\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\tbone.updateMatrixWorld();\n\n\t}\n\n\tif ( options.preservePosition ) {\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\tif ( name !== options.hip ) {\n\n\t\t\t\tbone.position.copy( bonesPosition[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveMatrix ) {\n\n\t\t// restore matrix\n\n\t\ttarget.updateMatrixWorld( true );\n\n\t}\n\n}\n\nfunction retargetClip( target, source, clip, options = {} ) {\n\n\toptions.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n\t// Calculate the fps from the source clip based on the track with the most frames, unless fps is already provided.\n\toptions.fps = options.fps !== undefined ? options.fps : ( Math.max( ...clip.tracks.map( track => track.times.length ) ) / clip.duration );\n\toptions.names = options.names || [];\n\n\tif ( ! source.isObject3D ) {\n\n\t\tsource = getHelperFromSkeleton( source );\n\n\t}\n\n\tconst numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),\n\t\tdelta = clip.duration / ( numFrames - 1 ),\n\t\tconvertedTracks = [],\n\t\tmixer = new AnimationMixer( source ),\n\t\tbones = getBones( target.skeleton ),\n\t\tboneDatas = [];\n\tlet positionOffset,\n\t\tbone, boneTo, boneData,\n\t\tname;\n\n\tmixer.clipAction( clip ).play();\n\tmixer.update( 0 );\n\n\tsource.updateMatrixWorld();\n\n\tfor ( let i = 0; i < numFrames; ++ i ) {\n\n\t\tconst time = i * delta;\n\n\t\tretarget( target, source, options );\n\n\t\tfor ( let j = 0; j < bones.length; ++ j ) {\n\n\t\t\tname = options.names[ bones[ j ].name ] || bones[ j ].name;\n\n\t\t\tboneTo = getBoneByName( name, source.skeleton );\n\n\t\t\tif ( boneTo ) {\n\n\t\t\t\tbone = bones[ j ];\n\t\t\t\tboneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };\n\n\t\t\t\tif ( options.hip === name ) {\n\n\t\t\t\t\tif ( ! boneData.pos ) {\n\n\t\t\t\t\t\tboneData.pos = {\n\t\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\t\tvalues: new Float32Array( numFrames * 3 )\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.useFirstFramePosition ) {\n\n\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\tpositionOffset = bone.position.clone();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbone.position.sub( positionOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.pos.times[ i ] = time;\n\n\t\t\t\t\tbone.position.toArray( boneData.pos.values, i * 3 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! boneData.quat ) {\n\n\t\t\t\t\tboneData.quat = {\n\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\tvalues: new Float32Array( numFrames * 4 )\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tboneData.quat.times[ i ] = time;\n\n\t\t\t\tbone.quaternion.toArray( boneData.quat.values, i * 4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( i === numFrames - 2 ) {\n\n\t\t\t// last mixer update before final loop iteration\n\t\t\t// make sure we do not go over or equal to clip duration\n\t\t\tmixer.update( delta - 0.0000001 );\n\n\t\t} else {\n\n\t\t\tmixer.update( delta );\n\n\t\t}\n\n\t\tsource.updateMatrixWorld();\n\n\t}\n\n\tfor ( let i = 0; i < boneDatas.length; ++ i ) {\n\n\t\tboneData = boneDatas[ i ];\n\n\t\tif ( boneData ) {\n\n\t\t\tif ( boneData.pos ) {\n\n\t\t\t\tconvertedTracks.push( new VectorKeyframeTrack(\n\t\t\t\t\t'.bones[' + boneData.bone.name + '].position',\n\t\t\t\t\tboneData.pos.times,\n\t\t\t\t\tboneData.pos.values\n\t\t\t\t) );\n\n\t\t\t}\n\n\t\t\tconvertedTracks.push( new QuaternionKeyframeTrack(\n\t\t\t\t'.bones[' + boneData.bone.name + '].quaternion',\n\t\t\t\tboneData.quat.times,\n\t\t\t\tboneData.quat.values\n\t\t\t) );\n\n\t\t}\n\n\t}\n\n\tmixer.uncacheAction( clip );\n\n\treturn new AnimationClip( clip.name, - 1, convertedTracks );\n\n}\n\nfunction clone( source ) {\n\n\tconst sourceLookup = new Map();\n\tconst cloneLookup = new Map();\n\n\tconst clone = source.clone();\n\n\tparallelTraverse( source, clone, function ( sourceNode, clonedNode ) {\n\n\t\tsourceLookup.set( clonedNode, sourceNode );\n\t\tcloneLookup.set( sourceNode, clonedNode );\n\n\t} );\n\n\tclone.traverse( function ( node ) {\n\n\t\tif ( ! node.isSkinnedMesh ) return;\n\n\t\tconst clonedMesh = node;\n\t\tconst sourceMesh = sourceLookup.get( node );\n\t\tconst sourceBones = sourceMesh.skeleton.bones;\n\n\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\n\t\tclonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );\n\n\t\tclonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {\n\n\t\t\treturn cloneLookup.get( bone );\n\n\t\t} );\n\n\t\tclonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );\n\n\t} );\n\n\treturn clone;\n\n}\n\n// internal helper\n\nfunction getBoneByName( name, skeleton ) {\n\n\tfor ( let i = 0, bones = getBones( skeleton ); i < bones.length; i ++ ) {\n\n\t\tif ( name === bones[ i ].name )\n\n\t\t\treturn bones[ i ];\n\n\t}\n\n}\n\nfunction getBones( skeleton ) {\n\n\treturn Array.isArray( skeleton ) ? skeleton : skeleton.bones;\n\n}\n\n\nfunction getHelperFromSkeleton( skeleton ) {\n\n\tconst source = new SkeletonHelper( skeleton.bones[ 0 ] );\n\tsource.skeleton = skeleton;\n\n\treturn source;\n\n}\n\nfunction parallelTraverse( a, b, callback ) {\n\n\tcallback( a, b );\n\n\tfor ( let i = 0; i < a.children.length; i ++ ) {\n\n\t\tparallelTraverse( a.children[ i ], b.children[ i ], callback );\n\n\t}\n\n}\n\nexport {\n\tretarget,\n\tretargetClip,\n\tclone,\n};\n", "import { Material, Mesh } from 'three';\nimport { DefaultAssetBasePath, DefaultGltfLoader } from '../index.js';\nimport { clone as cloneSkeleton } from 'three/examples/jsm/utils/SkeletonUtils.js';\n//from https://github.com/pmndrs/three-stdlib/blob/main/src/webxr/XRHandMeshModel.ts\nconst DefaultDefaultXRHandProfileId = 'generic-hand';\nexport function getXRHandAssetPath(handedness, options) {\n    const baseAssetPath = options?.baseAssetPath ?? DefaultAssetBasePath;\n    const defaultProfileId = options?.defaultXRHandProfileId ?? DefaultDefaultXRHandProfileId;\n    return new URL(`${defaultProfileId}/${handedness}.glb`, baseAssetPath).href;\n}\nexport async function loadXRHandModel(assetPath, loader = DefaultGltfLoader) {\n    const gltf = await loader.loadAsync(assetPath);\n    return cloneXRHandGltf(gltf);\n}\nexport function cloneXRHandGltf({ scene }) {\n    const result = cloneSkeleton(scene);\n    const mesh = result.getObjectByProperty('type', 'SkinnedMesh');\n    if (mesh == null) {\n        throw new Error(`missing SkinnedMesh in loaded XRHand model`);\n    }\n    mesh.frustumCulled = false;\n    return result;\n}\nexport function configureXRHandModel(model, options) {\n    model.renderOrder = options?.renderOrder ?? 0;\n    model.traverse((child) => {\n        if (child instanceof Mesh && child.material instanceof Material) {\n            child.material.colorWrite = options?.colorWrite ?? true;\n        }\n    });\n}\n", "import { createHandPoseState, updateXRHandPoseState } from './pose.js';\nimport { getXRHandAssetPath } from './model.js';\nexport function isXRHandInputSource(inputSource) {\n    return inputSource.hand != null;\n}\nexport function createXRHandState(id, inputSource, options, events, isPrimary) {\n    return {\n        id,\n        isPrimary,\n        type: 'hand',\n        inputSource: inputSource,\n        pose: createHandPoseState(inputSource.hand),\n        assetPath: getXRHandAssetPath(inputSource.handedness, options),\n        events,\n    };\n}\nexport function updateXRHandState({ inputSource, pose }, frame, manager) {\n    updateXRHandPoseState(pose, frame, inputSource.hand, manager, inputSource.handedness);\n}\n", "const joints = [\n    'wrist',\n    'thumb-metacarpal',\n    'thumb-phalanx-proximal',\n    'thumb-phalanx-distal',\n    'thumb-tip',\n    'index-finger-metacarpal',\n    'index-finger-phalanx-proximal',\n    'index-finger-phalanx-intermediate',\n    'index-finger-phalanx-distal',\n    'index-finger-tip',\n    'middle-finger-metacarpal',\n    'middle-finger-phalanx-proximal',\n    'middle-finger-phalanx-intermediate',\n    'middle-finger-phalanx-distal',\n    'middle-finger-tip',\n    'ring-finger-metacarpal',\n    'ring-finger-phalanx-proximal',\n    'ring-finger-phalanx-intermediate',\n    'ring-finger-phalanx-distal',\n    'ring-finger-tip',\n    'pinky-finger-metacarpal',\n    'pinky-finger-phalanx-proximal',\n    'pinky-finger-phalanx-intermediate',\n    'pinky-finger-phalanx-distal',\n    'pinky-finger-tip',\n];\nexport function createUpdateXRHandVisuals(hand, handModel, referenceSpace) {\n    const buffer = new Float32Array(hand.size * 16);\n    const jointObjects = joints.map((joint) => {\n        const jointObject = handModel.getObjectByName(joint);\n        if (jointObject == null) {\n            throw new Error(`missing joint \"${joint}\" in hand model`);\n        }\n        jointObject.matrixAutoUpdate = false;\n        return jointObject;\n    });\n    return (frame) => {\n        const resolvedReferenceSpace = typeof referenceSpace === 'function' ? referenceSpace() : referenceSpace;\n        if (frame == null || resolvedReferenceSpace == null) {\n            return;\n        }\n        frame.fillPoses(hand.values(), resolvedReferenceSpace, buffer);\n        const length = jointObjects.length;\n        for (let i = 0; i < length; i++) {\n            jointObjects[i].matrix.fromArray(buffer, i * 16);\n        }\n    };\n}\n", "import { XRControllerLayoutLoader, createXRControllerState, } from './controller/index.js';\nimport { createXRHandState, } from './hand/index.js';\nexport function isXRInputSourceState(val) {\n    return val != null && typeof val === 'object' && 'inputSource' in val;\n}\nfunction setupEvents(session, events) {\n    const listener = (e) => events.push(e);\n    session.addEventListener('selectstart', listener);\n    session.addEventListener('selectend', listener);\n    session.addEventListener('select', listener);\n    session.addEventListener('squeeze', listener);\n    session.addEventListener('squeezestart', listener);\n    session.addEventListener('squeezeend', listener);\n    return () => {\n        session.removeEventListener('selectstart', listener);\n        session.removeEventListener('selectend', listener);\n        session.removeEventListener('select', listener);\n        session.removeEventListener('squeeze', listener);\n        session.removeEventListener('squeezestart', listener);\n        session.removeEventListener('squeezeend', listener);\n    };\n}\nlet idCounter = 0;\nexport function createSyncXRInputSourceStates(addController, options) {\n    const cleanupMap = new Map();\n    const controllerLayoutLoader = new XRControllerLayoutLoader(options);\n    const idMap = new Map();\n    return (session, current, changes) => {\n        if (changes === 'remove-all') {\n            for (const cleanup of cleanupMap.values()) {\n                cleanup();\n            }\n            return current;\n        }\n        const target = [...current];\n        for (const { added, isPrimary, removed } of changes) {\n            if (removed != null) {\n                for (const inputSource of removed) {\n                    const index = target.findIndex(({ inputSource: is, isPrimary: ip }) => ip === isPrimary && is === inputSource);\n                    if (index === -1) {\n                        continue;\n                    }\n                    target.splice(index, 1);\n                    cleanupMap.get(inputSource)?.();\n                    cleanupMap.delete(inputSource);\n                }\n            }\n            if (added == null) {\n                continue;\n            }\n            for (const inputSource of added) {\n                const events = [];\n                let cleanup = setupEvents(session, events);\n                const key = `${inputSource.handedness}-${inputSource.hand ? 'hand' : 'nohand'}-${inputSource.targetRayMode}-${inputSource.profiles.join(',')}`;\n                let id;\n                if ((id = idMap.get(key)) == null) {\n                    idMap.set(key, (id = `${idCounter++}`));\n                }\n                if (inputSource.hand != null) {\n                    target.push(createXRHandState(id, inputSource, options, events, isPrimary));\n                }\n                else {\n                    switch (inputSource.targetRayMode) {\n                        case 'gaze':\n                            target.push({ id, isPrimary, type: 'gaze', inputSource, events });\n                            break;\n                        case 'screen':\n                            target.push({ id, isPrimary, type: 'screenInput', inputSource, events });\n                            break;\n                        case 'transient-pointer':\n                            target.push({ id, isPrimary, type: 'transientPointer', inputSource, events });\n                            break;\n                        case 'tracked-pointer':\n                            let aborted = false;\n                            const cleanupEvents = cleanup;\n                            cleanup = () => {\n                                cleanupEvents();\n                                aborted = true;\n                            };\n                            const stateResult = createXRControllerState(id, inputSource, controllerLayoutLoader, events, isPrimary);\n                            if (stateResult instanceof Promise) {\n                                stateResult.then((state) => !aborted && addController(state)).catch(console.error);\n                            }\n                            else {\n                                target.push(stateResult);\n                            }\n                            break;\n                    }\n                }\n                cleanupMap.set(inputSource, cleanup);\n            }\n        }\n        return target;\n    };\n}\n", "export function setupSyncIsVisible(store, setIsVisible) {\n    const update = (state, prevState) => {\n        if (prevState != null && state.visibilityState === prevState.visibilityState) {\n            return;\n        }\n        setIsVisible(state.visibilityState === 'visible');\n    };\n    update(store.getState());\n    return store.subscribe(update);\n}\n", "import { MeshBasicMaterial, Quaternion, Vector3, } from 'three';\nexport class PointerCursorMaterial extends MeshBasicMaterial {\n    constructor() {\n        super({ transparent: true, toneMapped: false, depthWrite: false });\n    }\n    onBeforeCompile(parameters, renderer) {\n        super.onBeforeCompile(parameters, renderer);\n        parameters.vertexShader = `varying vec2 vLocalPosition;\\n` + parameters.vertexShader;\n        parameters.vertexShader = parameters.vertexShader.replace(`#include <color_vertex>`, `#include <color_vertex>\n        vLocalPosition = position.xy * 2.0;`);\n        parameters.fragmentShader = `varying vec2 vLocalPosition;\\n` + parameters.fragmentShader;\n        parameters.fragmentShader = parameters.fragmentShader.replace('#include <color_fragment>', `#include <color_fragment>\n          float value = max(0.0, 1.0 - sqrt(dot(vLocalPosition, vLocalPosition)));\n          diffuseColor.a = diffuseColor.a * value * value;`);\n    }\n}\nconst ZAxis = new Vector3(0, 0, 1);\nconst quaternionHelper = new Quaternion();\nconst offsetHelper = new Vector3();\nexport function updatePointerCursorModel(mesh, material, pointer, options) {\n    const intersection = pointer.getIntersection();\n    if (intersection == null || !pointer.getEnabled()) {\n        mesh.visible = false;\n        return;\n    }\n    mesh.visible = true;\n    const color = typeof options.color === 'function' ? options.color(pointer) : options.color;\n    if (Array.isArray(color)) {\n        material.color.set(...color);\n    }\n    else {\n        material.color.set(color ?? 'white');\n    }\n    material.opacity = typeof options.opacity === 'function' ? options.opacity(pointer) : (options.opacity ?? 0.4);\n    mesh.position.copy(intersection.pointOnFace);\n    mesh.scale.setScalar(options.size ?? 0.1);\n    if (intersection.normal != null) {\n        quaternionHelper.setFromUnitVectors(ZAxis, intersection.normal);\n        intersection.object.getWorldQuaternion(mesh.quaternion);\n        mesh.quaternion.multiply(quaternionHelper);\n        offsetHelper.set(0, 0, options.cursorOffset ?? 0.01);\n        offsetHelper.applyQuaternion(mesh.quaternion);\n        mesh.position.add(offsetHelper);\n    }\n    mesh.updateMatrix();\n}\n", "import { MeshBasicMaterial, } from 'three';\nexport class PointerRayMaterial extends MeshBasicMaterial {\n    constructor() {\n        super({ transparent: true, toneMapped: false });\n    }\n    onBeforeCompile(parameters, renderer) {\n        super.onBeforeCompile(parameters, renderer);\n        parameters.vertexShader = `varying float vFade;\\n` + parameters.vertexShader;\n        parameters.vertexShader = parameters.vertexShader.replace(`#include <color_vertex>`, `#include <color_vertex>\n            vFade = position.z + 0.5;`);\n        parameters.fragmentShader = `varying float vFade;\\n` + parameters.fragmentShader;\n        parameters.fragmentShader = parameters.fragmentShader.replace('#include <color_fragment>', `#include <color_fragment>\n              diffuseColor.a *= vFade;`);\n    }\n}\nexport function updatePointerRayModel(mesh, material, pointer, options) {\n    if (!pointer.getEnabled()) {\n        mesh.visible = false;\n        return;\n    }\n    mesh.visible = true;\n    const intersection = pointer.getIntersection();\n    const color = typeof options.color === 'function' ? options.color(pointer) : options.color;\n    if (Array.isArray(color)) {\n        material.color.set(...color);\n    }\n    else {\n        material.color.set(color ?? 'white');\n    }\n    material.opacity = typeof options.opacity === 'function' ? options.opacity(pointer) : (options.opacity ?? 0.4);\n    let length = options.maxLength ?? 1;\n    if (intersection != null) {\n        length = Math.min(length, intersection.distance);\n    }\n    mesh.position.z = -length / 2;\n    const size = options.size ?? 0.005;\n    mesh.scale.set(size, size, length);\n    mesh.updateMatrix();\n}\n", "export function bindXRInputSourceEvent(session, inputSource, event, fn) {\n    const filterFn = (event) => {\n        if (inputSource != 'all' && event.inputSource != inputSource) {\n            return;\n        }\n        fn(event);\n    };\n    session.addEventListener(event, filterFn);\n    return () => session.removeEventListener(event, filterFn);\n}\nexport function bindPointerXRInputSourceEvent(pointer, session, inputSource, event, missingEvents, options = {}) {\n    const downListener = (e) => {\n        if (e.inputSource === inputSource) {\n            pointer.down(Object.assign(e, { button: options.button ?? 0 }));\n        }\n    };\n    const upListener = (e) => {\n        if (e.inputSource === inputSource) {\n            pointer.up(Object.assign(e, { button: options.button ?? 0 }));\n        }\n    };\n    const downEventName = `${event}start`;\n    const upEventName = `${event}end`;\n    //missing events are required for transient pointers when the input source is registered asynchrounously\n    //so that events directly emitted on initialization are still processed once the input source is created\n    const length = missingEvents.length;\n    for (let i = 0; i < length; i++) {\n        const event = missingEvents[i];\n        switch (event.type) {\n            case downEventName:\n                downListener(event);\n                break;\n            case upEventName:\n                upListener(event);\n                break;\n        }\n    }\n    session.addEventListener(downEventName, downListener);\n    session.addEventListener(upEventName, upListener);\n    return () => {\n        session.removeEventListener(downEventName, downListener);\n        session.removeEventListener(upEventName, upListener);\n    };\n}\n", "export function defaultGrabPointerOpacity(pointer) {\n    if (pointer.getButtonsDown().size > 0) {\n        return 0.6;\n    }\n    return map(pointer.getIntersection()?.distance ?? Infinity, 0.07, 0, 0.2, 0.4);\n}\nexport function defaultRayPointerOpacity(pointer) {\n    if (pointer.getButtonsDown().size > 0) {\n        return 0.6;\n    }\n    return 0.4;\n}\nexport function defaultTouchPointerOpacity(pointer) {\n    return map(pointer.getIntersection()?.distance ?? Infinity, 0.1, 0.03, 0.2, 0.6);\n}\nfunction map(value, fromMin, fromMax, toMin, toMax) {\n    return toMin + Math.max(0, Math.min(1, (value - fromMin) / (fromMax - fromMin))) * (toMax - toMin);\n}\n", "export function createGetXRSpaceMatrix(space, referenceSpace) {\n    return (target, frame) => {\n        if (space === referenceSpace) {\n            target.identity();\n            return true;\n        }\n        const resolvedReferenceSpace = typeof referenceSpace === 'function' ? referenceSpace() : referenceSpace;\n        if (resolvedReferenceSpace == null) {\n            return false;\n        }\n        const pose = frame?.getPose(space, resolvedReferenceSpace);\n        if (pose == null) {\n            return false;\n        }\n        target.fromArray(pose.transform.matrix);\n        return true;\n    };\n}\nexport function getSpaceFromAncestors(object, origin, originReferenceSpace, targetOffsetMatrix) {\n    targetOffsetMatrix?.copy(object.matrix);\n    const result = getXRSpaceFromAncestorsRec(object.parent, targetOffsetMatrix);\n    if (result != null) {\n        return result;\n    }\n    if (targetOffsetMatrix != null) {\n        computeOriginReferenceSpaceOffset(object, origin, targetOffsetMatrix);\n    }\n    return originReferenceSpace;\n}\nfunction computeOriginReferenceSpaceOffset(object, origin, target) {\n    if (origin == null) {\n        target.copy(object.matrixWorld);\n        return;\n    }\n    target.copy(origin.matrixWorld).invert().multiply(object.matrixWorld);\n}\nfunction getXRSpaceFromAncestorsRec(object, targetOffsetMatrix) {\n    if (object == null) {\n        return undefined;\n    }\n    if (object.xrSpace != null) {\n        return object.xrSpace;\n    }\n    targetOffsetMatrix?.premultiply(object.matrix);\n    return getXRSpaceFromAncestorsRec(object.parent, targetOffsetMatrix);\n}\n", "export function buildXRSessionInit(mode, domOverlayRoot, { anchors = true, handTracking = true, layers = true, meshDetection = true, planeDetection = true, customSessionInit, depthSensing = false, hitTest = true, domOverlay = true, bounded, } = {}) {\n    if (customSessionInit != null) {\n        return customSessionInit;\n    }\n    const requiredFeatures = bounded == null ? ['local-floor'] : bounded ? ['bounded-floor'] : ['unbounded', 'local-floor'];\n    const optionalFeatures = [];\n    if (domOverlay instanceof Element) {\n        domOverlay = true;\n    }\n    addXRSessionFeature(anchors, 'anchors', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(handTracking, 'hand-tracking', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(layers, 'layers', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(meshDetection, 'mesh-detection', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(planeDetection, 'plane-detection', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(depthSensing, 'depth-sensing', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(domOverlay, 'dom-overlay', requiredFeatures, optionalFeatures);\n    addXRSessionFeature(hitTest, 'hit-test', requiredFeatures, optionalFeatures);\n    const init = {\n        requiredFeatures,\n        optionalFeatures,\n        domOverlay: { root: domOverlayRoot },\n    };\n    //TODO: replace with call to isSupportedFeature (unbounded, ...)\n    if (depthSensing) {\n        Object.assign(init, { depthSensing: { usagePreference: ['gpu-optimized'], dataFormatPreference: [] } });\n    }\n    return init;\n}\nfunction addXRSessionFeature(value, key, requiredFeatures, optionalFeatures) {\n    if (value === false) {\n        return;\n    }\n    if (value === true) {\n        optionalFeatures.push(key);\n        return;\n    }\n    requiredFeatures.push(key);\n}\n", "import { createStore } from 'zustand/vanilla';\nimport { updateXRHandState } from './hand/state.js';\nimport { updateXRControllerState } from './controller/index.js';\nimport { createSyncXRInputSourceStates } from './input.js';\nimport { buildXRSessionInit } from './init.js';\nexport function resolveInputSourceImplementation(implementation, handedness, defaultValue) {\n    if (typeof implementation === 'function') {\n        return implementation;\n    }\n    if (typeof implementation === 'object') {\n        if (handedness != null && hasKey(implementation, handedness)) {\n            implementation = implementation[handedness];\n        }\n        else if ('default' in implementation) {\n            implementation = implementation.default;\n        }\n    }\n    if (implementation === false) {\n        return false;\n    }\n    if (implementation === true) {\n        return defaultValue;\n    }\n    return implementation ?? defaultValue;\n}\nfunction hasKey(val, key) {\n    return key in val;\n}\nconst baseInitialState = {\n    session: undefined,\n    mediaBinding: undefined,\n    originReferenceSpace: undefined,\n    visibilityState: undefined,\n    mode: null,\n    frameRate: undefined,\n    inputSourceStates: [],\n    detectedMeshes: [],\n    detectedPlanes: [],\n    layerEntries: [],\n};\nfunction startEmulate(emulate, alert) {\n    Promise.all([navigator.xr?.isSessionSupported('immersive-vr'), navigator.xr?.isSessionSupported('immersive-ar')])\n        .then(([vr, ar]) => (!ar && !vr ? import('./emulate.js') : undefined))\n        .then((pkg) => {\n        if (alert) {\n            window.alert(`emulator started`);\n        }\n        pkg?.emulate(emulate === true ? 'metaQuest3' : emulate);\n    });\n}\nexport function createXRStore(options) {\n    const emulate = options?.emulate ?? 'metaQuest3';\n    let cleanupEmulate;\n    if (typeof window !== 'undefined' && emulate != false) {\n        if (window.location.hostname === 'localhost') {\n            startEmulate(emulate, false);\n        }\n        const keydownListener = (e) => {\n            if (e.altKey && e.metaKey && e.code === 'KeyE') {\n                startEmulate(emulate, true);\n            }\n        };\n        window.addEventListener('keydown', keydownListener);\n        cleanupEmulate = () => window.removeEventListener('keydown', keydownListener);\n    }\n    const domOverlayRoot = options?.domOverlay instanceof HTMLElement ? options.domOverlay : document.createElement('div');\n    const store = createStore(() => ({\n        ...baseInitialState,\n        controller: options?.controller,\n        hand: options?.hand,\n        gaze: options?.gaze,\n        screenInput: options?.screenInput,\n        transientPointer: options?.transientPointer,\n        domOverlayRoot,\n    }));\n    let cleanupDomOverlayRoot;\n    if (domOverlayRoot.parentNode == null) {\n        const setupDisplay = (state) => {\n            domOverlayRoot.style.display = state.session != null ? 'block' : 'none';\n        };\n        const unsubscribe = store.subscribe(setupDisplay);\n        setupDisplay(store.getState());\n        document.body.appendChild(domOverlayRoot);\n        cleanupDomOverlayRoot = () => {\n            domOverlayRoot.remove();\n            unsubscribe();\n        };\n    }\n    document.body.append(domOverlayRoot);\n    const syncXRInputSourceStates = createSyncXRInputSourceStates((state) => store.setState({ inputSourceStates: [...store.getState().inputSourceStates, state] }), options);\n    const bindToSession = createBindToSession(store, syncXRInputSourceStates, options?.secondaryInputSources ?? false);\n    const cleanupSessionGrantedListener = setupSessionGrantedListener(options?.enterGrantedSession, (mode) => enterXR(domOverlayRoot, mode, options, xrManager));\n    let cleanupSessionStartListener;\n    const frameRequests = [];\n    let xrManager;\n    return Object.assign(store, {\n        addLayerEntry(layerEntry) {\n            if (store.getState().session == null) {\n                return;\n            }\n            store.setState({ layerEntries: [...store.getState().layerEntries, layerEntry] });\n        },\n        removeLayerEntry(layerEntry) {\n            if (store.getState().session == null) {\n                return;\n            }\n            store.setState({ layerEntries: store.getState().layerEntries.filter((entry) => entry != layerEntry) });\n        },\n        requestFrame() {\n            return new Promise((resolve) => frameRequests.push(resolve));\n        },\n        setWebXRManager(newXrManager) {\n            if (xrManager === newXrManager) {\n                return;\n            }\n            xrManager = newXrManager;\n            const { foveation, bounded } = options ?? {};\n            newXrManager.setReferenceSpaceType(bounded ? 'bounded-floor' : 'local-floor');\n            if (foveation != null) {\n                newXrManager.setFoveation(foveation);\n            }\n        },\n        setFrameRate(value) {\n            const { session } = store.getState();\n            if (session == null) {\n                return;\n            }\n            setFrameRate(session, value);\n        },\n        setHand(implementation, handedness) {\n            if (handedness == null) {\n                store.setState({ hand: implementation });\n                return;\n            }\n            const currentImplementation = store.getState().hand;\n            const newControllerImplementation = {};\n            if (typeof currentImplementation === 'object') {\n                Object.assign(newControllerImplementation, currentImplementation);\n            }\n            Object.assign(newControllerImplementation, {\n                default: resolveInputSourceImplementation(currentImplementation, undefined, {}),\n                [handedness]: implementation,\n            });\n            store.setState({\n                hand: newControllerImplementation,\n            });\n        },\n        setController(implementation, handedness) {\n            if (handedness == null) {\n                store.setState({ controller: implementation });\n                return;\n            }\n            const currentImplementation = store.getState().controller;\n            const newControllerImplementation = {};\n            if (typeof currentImplementation === 'object') {\n                Object.assign(newControllerImplementation, currentImplementation);\n            }\n            Object.assign(newControllerImplementation, {\n                default: resolveInputSourceImplementation(currentImplementation, undefined, {}),\n                [handedness]: implementation,\n            });\n            store.setState({\n                controller: newControllerImplementation,\n            });\n        },\n        setTransientPointer(implementation, handedness) {\n            if (handedness == null) {\n                store.setState({ transientPointer: implementation });\n                return;\n            }\n            const currentImplementation = store.getState().transientPointer;\n            const newControllerImplementation = {};\n            if (typeof currentImplementation === 'object') {\n                Object.assign(newControllerImplementation, currentImplementation);\n            }\n            Object.assign(newControllerImplementation, {\n                default: resolveInputSourceImplementation(currentImplementation, undefined, {}),\n                [handedness]: implementation,\n            });\n            store.setState({\n                transientPointer: newControllerImplementation,\n            });\n        },\n        setGaze(implementation) {\n            store.setState({ gaze: implementation });\n        },\n        setScreenInput(implementation) {\n            store.setState({ screenInput: implementation });\n        },\n        destroy() {\n            cleanupEmulate?.();\n            cleanupDomOverlayRoot?.();\n            cleanupSessionStartListener?.();\n            cleanupSessionGrantedListener?.();\n            //unbinding the session\n            bindToSession(undefined);\n        },\n        enterXR: (mode) => enterXR(domOverlayRoot, mode, options, xrManager),\n        enterAR: () => enterXR(domOverlayRoot, 'immersive-ar', options, xrManager),\n        enterVR: () => enterXR(domOverlayRoot, 'immersive-vr', options, xrManager),\n        onBeforeFrame(scene, camera, frame) {\n            let update;\n            const referenceSpace = xrManager?.getReferenceSpace() ?? undefined;\n            const state = store.getState();\n            //update origin\n            const origin = camera.parent ?? scene;\n            if (state.origin != origin) {\n                update ??= {};\n                update.origin = origin;\n            }\n            //update reference space\n            if (referenceSpace != state.originReferenceSpace) {\n                update ??= {};\n                update.originReferenceSpace = referenceSpace;\n            }\n            //set xr space on current origin (and reset on previous)\n            origin.xrSpace = referenceSpace;\n            if (state.origin != origin && state.origin != null) {\n                state.origin.xrSpace = undefined;\n            }\n            if (frame != null) {\n                if (xrManager != null) {\n                    updateSession(store, frame, xrManager);\n                }\n                if (state.session == null && referenceSpace != null && frame.session != null) {\n                    update ??= {};\n                    Object.assign(update, bindToSession(frame.session));\n                }\n            }\n            if (update != null) {\n                store.setState(update);\n            }\n            if (frame != null) {\n                const length = frameRequests.length;\n                for (let i = 0; i < length; i++) {\n                    frameRequests[i](frame);\n                }\n                frameRequests.length = 0;\n            }\n        },\n        onBeforeRender() {\n            const { session, layerEntries } = store.getState();\n            if (session == null || xrManager == null) {\n                return;\n            }\n            const currentLayers = session?.renderState.layers;\n            if (currentLayers == null) {\n                return;\n            }\n            //TODO: sort by distance to camera\n            ;\n            layerEntries.sort((l1, l2) => l1.renderOrder - l2.renderOrder);\n            let changed = false;\n            const layers = layerEntries.map(({ layer }, i) => {\n                if (layer != currentLayers[i]) {\n                    changed = true;\n                }\n                return layer;\n            });\n            if (!changed) {\n                return;\n            }\n            layers.push(xrManager.getBaseLayer());\n            session.updateRenderState({\n                layers,\n            });\n        },\n    });\n}\nasync function setFrameRate(session, frameRate) {\n    if (frameRate === false) {\n        return;\n    }\n    const { supportedFrameRates } = session;\n    if (supportedFrameRates == null || supportedFrameRates.length === 0) {\n        return;\n    }\n    if (typeof frameRate === 'function') {\n        const value = frameRate(supportedFrameRates);\n        if (value === false) {\n            return;\n        }\n        return session.updateTargetFrameRate(value);\n    }\n    const multiplier = frameRate === 'high' ? 1 : frameRate === 'mid' ? 0.5 : 0;\n    return session.updateTargetFrameRate(supportedFrameRates[Math.ceil((supportedFrameRates.length - 1) * multiplier)]);\n}\nasync function enterXR(domOverlayRoot, mode, options, xrManager) {\n    if (navigator.xr == null) {\n        return Promise.reject(new Error(`WebXR not supported`));\n    }\n    if (xrManager == null) {\n        return Promise.reject(new Error(`not connected to three.js. Missing are <XR> component?`));\n    }\n    const session = await navigator.xr.requestSession(mode, buildXRSessionInit(mode, domOverlayRoot, options));\n    setFrameRate(session, options?.frameRate ?? 'high');\n    setupXRManager(xrManager, session, options);\n    return session;\n}\nfunction setupXRManager(xr, session, options) {\n    if (xr == null) {\n        return;\n    }\n    const maxFrameBufferScalingFactor = XRWebGLLayer.getNativeFramebufferScaleFactor(session);\n    let frameBufferScaling = options?.frameBufferScaling;\n    if (typeof frameBufferScaling === 'function') {\n        frameBufferScaling = frameBufferScaling(maxFrameBufferScalingFactor);\n    }\n    if (typeof frameBufferScaling === 'string') {\n        frameBufferScaling =\n            frameBufferScaling === 'high' ? maxFrameBufferScalingFactor : frameBufferScaling === 'mid' ? 1 : 0.5;\n    }\n    if (frameBufferScaling != null) {\n        xr?.setFramebufferScaleFactor(frameBufferScaling);\n    }\n    xr?.setSession(session);\n}\nconst allSessionModes = ['immersive-ar', 'immersive-vr', 'inline'];\nfunction setupSessionGrantedListener(enterGrantedSession = allSessionModes, enterXR) {\n    if (enterGrantedSession === false) {\n        return;\n    }\n    if (enterGrantedSession === true) {\n        enterGrantedSession = allSessionModes;\n    }\n    const sessionGrantedListener = async () => {\n        for (const mode of enterGrantedSession) {\n            if (!(await navigator.xr?.isSessionSupported(mode))) {\n                continue;\n            }\n            enterXR(mode);\n        }\n    };\n    navigator.xr?.addEventListener('sessiongranted', sessionGrantedListener);\n    return () => navigator.xr?.removeEventListener('sessiongranted', sessionGrantedListener);\n}\nfunction createBindToSession(store, syncXRInputSourceStates, secondayInputSources) {\n    let cleanupSession;\n    return (session) => {\n        cleanupSession?.();\n        if (session == null) {\n            return {};\n        }\n        //for debouncing the input source and tracked source changes\n        const inputSourceChangesList = [];\n        let inputSourceChangesTimeout;\n        const applySourcesChange = () => {\n            inputSourceChangesTimeout = undefined;\n            store.setState({\n                inputSourceStates: syncXRInputSourceStates(session, store.getState().inputSourceStates, inputSourceChangesList),\n            });\n            inputSourceChangesList.length = 0;\n        };\n        const onSourcesChange = (isPrimary, e) => {\n            inputSourceChangesList.push({ isPrimary, added: e.added, removed: e.removed });\n            if (inputSourceChangesTimeout != null) {\n                return;\n            }\n            if (secondayInputSources) {\n                inputSourceChangesTimeout = setTimeout(applySourcesChange, 100);\n            }\n            else {\n                applySourcesChange();\n            }\n        };\n        const onInputSourcesChange = onSourcesChange.bind(null, true);\n        session.addEventListener('inputsourceschange', onInputSourcesChange);\n        let cleanupSecondaryInputSources;\n        if (secondayInputSources) {\n            const onTrackedSourcesChange = onSourcesChange.bind(null, false);\n            session.addEventListener('trackedsourceschange', onTrackedSourcesChange);\n            cleanupSecondaryInputSources = () => session.removeEventListener('trackedsourceschange', onTrackedSourcesChange);\n        }\n        //frameratechange and visibilitychange handlers\n        const onChange = () => store.setState({ frameRate: session.frameRate, visibilityState: session.visibilityState });\n        session.addEventListener('frameratechange', onChange);\n        session.addEventListener('visibilitychange', onChange);\n        //end handler\n        const onEnd = () => {\n            cleanupSession?.();\n            cleanupSession = undefined;\n            store.setState(baseInitialState);\n        };\n        session.addEventListener('end', onEnd);\n        const initialChanges = [\n            { isPrimary: true, added: session.inputSources },\n        ];\n        if (secondayInputSources) {\n            initialChanges.push({ isPrimary: false, added: session.trackedSources });\n        }\n        const inputSourceStates = syncXRInputSourceStates(session, [], initialChanges);\n        cleanupSession = () => {\n            //cleanup\n            cleanupSecondaryInputSources?.();\n            clearTimeout(inputSourceChangesTimeout);\n            syncXRInputSourceStates(session, store.getState().inputSourceStates, 'remove-all');\n            session.removeEventListener('end', onEnd);\n            session.removeEventListener('frameratechange', onChange);\n            session.removeEventListener('visibilitychange', onChange);\n            session.removeEventListener('inputsourceschange', onInputSourcesChange);\n        };\n        return {\n            inputSourceStates,\n            frameRate: session.frameRate,\n            visibilityState: session.visibilityState,\n            detectedMeshes: [],\n            detectedPlanes: [],\n            mode: session.environmentBlendMode === 'opaque' ? 'immersive-vr' : 'immersive-ar',\n            session,\n            mediaBinding: typeof XRMediaBinding == 'undefined' ? undefined : new XRMediaBinding(session),\n        };\n    };\n}\nfunction updateSession(store, frame, manager) {\n    const referenceSpace = manager.getReferenceSpace();\n    const { detectedMeshes: prevMeshes, detectedPlanes: prevPlanes, session, inputSourceStates } = store.getState();\n    if (referenceSpace == null || session == null) {\n        //not in a XR session\n        return;\n    }\n    //update detected planes and meshes\n    const detectedPlanes = updateDetectedEntities(prevPlanes, frame.detectedPlanes);\n    const detectedMeshes = updateDetectedEntities(prevMeshes, frame.detectedMeshes);\n    if (prevPlanes != detectedPlanes || prevMeshes != detectedMeshes) {\n        store.setState({ detectedPlanes, detectedMeshes });\n    }\n    //update input sources\n    const inputSourceStatesLength = inputSourceStates.length;\n    for (let i = 0; i < inputSourceStatesLength; i++) {\n        const inputSourceState = inputSourceStates[i];\n        switch (inputSourceState.type) {\n            case 'controller':\n                updateXRControllerState(inputSourceState);\n                break;\n            case 'hand':\n                updateXRHandState(inputSourceState, frame, manager);\n                break;\n        }\n    }\n}\nconst emptyArray = [];\nfunction updateDetectedEntities(prevDetectedEntities, detectedEntities) {\n    if (detectedEntities == null) {\n        return emptyArray;\n    }\n    if (prevDetectedEntities != null && equalContent(detectedEntities, prevDetectedEntities)) {\n        return prevDetectedEntities;\n    }\n    return Array.from(detectedEntities);\n}\nfunction equalContent(set, arr) {\n    if (set.size != arr.length) {\n        return false;\n    }\n    for (const entry of arr) {\n        if (!set.has(entry)) {\n            return false;\n        }\n    }\n    return true;\n}\n", "import { BoxGeometry, Mesh, PlaneGeometry } from 'three';\nimport { onXRFrame } from './utils.js';\nimport { PointerRayMaterial, updatePointerRayModel } from '../pointer/ray.js';\nimport { PointerCursorMaterial, updatePointerCursorModel } from '../pointer/cursor.js';\nconst pointerRayGeometry = new BoxGeometry();\nexport class PointerRayModel extends Mesh {\n    constructor(pointer, options = {}) {\n        const material = new PointerRayMaterial();\n        super(pointerRayGeometry, material);\n        this.renderOrder = options.renderOrder ?? 2;\n        onXRFrame(() => updatePointerRayModel(this, material, pointer, options));\n    }\n}\nconst pointerCursorGeometry = new PlaneGeometry();\nexport class PointerCursorModel extends Mesh {\n    constructor(pointer, options = {}) {\n        const material = new PointerCursorMaterial();\n        super(pointerCursorGeometry, material);\n        this.renderOrder = options.renderOrder ?? 1;\n        onXRFrame(() => updatePointerCursorModel(this, material, pointer, options));\n    }\n}\n", "import { DefaultGltfLoader } from '../index.js';\nimport { Material, Mesh } from 'three';\nexport async function loadXRControllerModel(layout, loader = DefaultGltfLoader) {\n    const { scene } = await loader.loadAsync(layout.assetPath);\n    return scene.clone(true);\n}\n/**\n * function for getting the object of a specific component from the xr controller model\n */\nexport function getXRControllerComponentObject(model, layout, componentId) {\n    const component = layout.components[componentId];\n    const firstVisualResponse = component.visualResponses[Object.keys(component.visualResponses)[0]];\n    if (firstVisualResponse == null) {\n        return undefined;\n    }\n    return model.getObjectByName(firstVisualResponse.valueNodeName);\n}\nexport function configureXRControllerModel(model, options) {\n    model.renderOrder = options?.renderOrder ?? 0;\n    model.traverse((child) => {\n        if (child instanceof Mesh && child.material instanceof Material) {\n            child.material.colorWrite = options?.colorWrite ?? true;\n        }\n    });\n}\n", "import { Vector2 } from 'three';\nexport function createUpdateXRControllerVisuals(model, layout, gamepadState) {\n    const updateVisuals = [];\n    for (const componentName in layout.components) {\n        const component = layout.components[componentName];\n        let state = gamepadState[componentName];\n        if (state == null) {\n            gamepadState[componentName] = state = {\n                state: 'default',\n            };\n        }\n        updateVisuals.push(...Object.values(component.visualResponses).map((visualResponse) => createUpdateVisualResponse(model, state, visualResponse)));\n    }\n    return () => {\n        const length = updateVisuals.length;\n        for (let i = 0; i < length; i++) {\n            updateVisuals[i]();\n        }\n    };\n}\nfunction createUpdateVisualResponse(model, componentState, visualResponse) {\n    const valueNode = model.getObjectByName(visualResponse.valueNodeName);\n    componentState.object = valueNode;\n    if (valueNode == null) {\n        return () => { };\n    }\n    if (visualResponse.valueNodeProperty === 'visibility') {\n        return () => (valueNode.visible = visualResponse.states.includes(componentState.state));\n    }\n    const minNode = model.getObjectByName(visualResponse.minNodeName);\n    const maxNode = model.getObjectByName(visualResponse.maxNodeName);\n    if (minNode == null || maxNode == null) {\n        return () => { };\n    }\n    return () => {\n        const value = getVisualReponseValue(componentState, visualResponse);\n        valueNode.quaternion.slerpQuaternions(minNode.quaternion, maxNode.quaternion, value);\n        valueNode.position.lerpVectors(minNode.position, maxNode.position, value);\n        valueNode.updateMatrix();\n    };\n}\n/**\n * @returns a value between 0 and 1\n */\nfunction getVisualReponseValue(componentState, { componentProperty, states }) {\n    const stateIsActive = states.includes(componentState.state);\n    switch (componentProperty) {\n        case 'xAxis':\n            return stateIsActive ? getNormalizesAxis(componentState).x : 0.5;\n        case 'yAxis':\n            return stateIsActive ? getNormalizesAxis(componentState).y : 0.5;\n        case 'button':\n            return stateIsActive ? (componentState.button ?? 0) : 0;\n        case 'state':\n            return stateIsActive ? 1.0 : 0.0;\n    }\n}\nconst vector2Helper = new Vector2();\n/**\n * project the point (x: [-1, 1], y: [-1, 1]) onto a circle\n */\nfunction getNormalizesAxis({ xAxis = 0, yAxis = 0 }) {\n    const hypotenuse = vector2Helper.lengthSq(); //we can use the length squared since \"1 * 1 = 1\"\n    if (hypotenuse > 1) {\n        const theta = Math.atan2(yAxis, xAxis);\n        vector2Helper.set(Math.cos(theta), Math.sin(theta));\n    }\n    else {\n        //point is inside the circle\n        vector2Helper.set(xAxis, yAxis);\n    }\n    vector2Helper.multiplyScalar(0.5).addScalar(0.5);\n    return vector2Helper;\n}\n", "import { BufferAttribute, Matrix4, Triangle, Vector2, Vector3 } from 'three';\nexport function hasObjectListeners({ _listeners, __r3f }) {\n    if (_listeners != null && Object.keys(_listeners).length > 0) {\n        return true;\n    }\n    if (__r3f != null && __r3f?.eventCount > 0) {\n        return true;\n    }\n    return false;\n}\nexport function getObjectListeners({ _listeners, __r3f }, forEvent) {\n    if (_listeners != null && forEvent in _listeners) {\n        return _listeners[forEvent];\n    }\n    //R3F compatibility\n    if (__r3f == null) {\n        return undefined;\n    }\n    const handler = __r3f.handlers[r3fEventToHandlerMap[forEvent]];\n    if (handler == null) {\n        return;\n    }\n    return [handler];\n}\nconst r3fEventToHandlerMap = {\n    click: 'onClick',\n    contextmenu: 'onContextMenu',\n    dblclick: 'onDoubleClick',\n    pointercancel: 'onPointerCancel',\n    pointerdown: 'onPointerDown',\n    pointerenter: 'onPointerEnter',\n    pointerleave: 'onPointerLeave',\n    pointermove: 'onPointerMove',\n    pointerout: 'onPointerOut',\n    pointerover: 'onPointerOver',\n    pointerup: 'onPointerUp',\n    wheel: 'onWheel',\n};\nconst triangleHelper1 = new Triangle();\nconst triangleHelper2 = new Triangle();\nconst aVec2Helper = new Vector2();\nconst bVec2Helper = new Vector2();\nconst cVec2Helper = new Vector2();\nconst pointHelper = new Vector3();\nconst inverseMatrix = new Matrix4();\nconst localPointHelper = new Vector3();\nexport function getClosestUV(target, point, mesh) {\n    localPointHelper.copy(point).applyMatrix4(inverseMatrix.copy(mesh.matrixWorld).invert());\n    const uv = mesh.geometry.attributes.uv;\n    if (uv == null || !(uv instanceof BufferAttribute)) {\n        return void target.set(0, 0);\n    }\n    let clostestDistance;\n    loopThroughTriangles(mesh, (i1, i2, i3) => {\n        mesh.getVertexPosition(i1, triangleHelper1.a);\n        mesh.getVertexPosition(i2, triangleHelper1.b);\n        mesh.getVertexPosition(i3, triangleHelper1.c);\n        const distance = triangleHelper1.closestPointToPoint(localPointHelper, pointHelper).distanceTo(localPointHelper);\n        if (clostestDistance != null && distance >= clostestDistance) {\n            return void target.set(0, 0);\n        }\n        clostestDistance = distance;\n        triangleHelper2.copy(triangleHelper1);\n        aVec2Helper.fromBufferAttribute(uv, i1);\n        bVec2Helper.fromBufferAttribute(uv, i2);\n        cVec2Helper.fromBufferAttribute(uv, i3);\n    });\n    if (clostestDistance == null) {\n        return void target.set(0, 0);\n    }\n    triangleHelper2.closestPointToPoint(localPointHelper, pointHelper);\n    triangleHelper2.getInterpolation(pointHelper, aVec2Helper, bVec2Helper, cVec2Helper, target);\n}\nfunction loopThroughTriangles(mesh, fn) {\n    const drawRange = mesh.geometry.drawRange;\n    if (mesh.geometry.index != null) {\n        const index = mesh.geometry.index;\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(index.count, drawRange.start + drawRange.count);\n        for (let i = start; i < end; i += 3) {\n            fn(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n        }\n        return;\n    }\n    const position = mesh.geometry.attributes.position;\n    if (position == null) {\n        return;\n    }\n    const start = Math.max(0, drawRange.start);\n    const end = Math.min(position.count, drawRange.start + drawRange.count);\n    for (let i = start; i < end; i += 3) {\n        fn(i, i + 1, i + 2);\n    }\n}\n", "import { getObjectListeners } from './utils.js';\nexport class PointerEvent {\n    type;\n    bubbles;\n    nativeEvent;\n    pointer;\n    intersection;\n    currentObject;\n    object;\n    //--- pointer events data\n    get pointerId() {\n        return this.pointer.id;\n    }\n    get pointerType() {\n        return this.pointer.type;\n    }\n    get pointerState() {\n        return this.pointer.state;\n    }\n    get timeStamp() {\n        return this.nativeEvent.timeStamp;\n    }\n    get button() {\n        return this.nativeEvent.button;\n    }\n    get shiftKey() {\n        return this.nativeEvent.shiftKey ?? false;\n    }\n    get metaKey() {\n        return this.nativeEvent.metaKey ?? false;\n    }\n    get ctrlKey() {\n        return this.nativeEvent.ctrlKey ?? false;\n    }\n    get altKey() {\n        return this.nativeEvent.altKey ?? false;\n    }\n    //--- intersection data\n    get distance() {\n        return this.intersection.distance;\n    }\n    get distanceToRay() {\n        return this.intersection.distanceToRay;\n    }\n    get point() {\n        return this.intersection.point;\n    }\n    get index() {\n        return this.intersection.index;\n    }\n    get face() {\n        return this.intersection.face;\n    }\n    get faceIndex() {\n        return this.intersection.faceIndex;\n    }\n    get uv() {\n        return this.intersection.uv;\n    }\n    get uv1() {\n        return this.intersection.uv1;\n    }\n    get normal() {\n        return this.intersection.normal;\n    }\n    get instanceId() {\n        return this.intersection.instanceId;\n    }\n    get pointOnLine() {\n        return this.intersection.pointOnLine;\n    }\n    get batchId() {\n        return this.intersection.batchId;\n    }\n    get pointerPosition() {\n        return this.intersection.pointerPosition;\n    }\n    get pointerQuaternion() {\n        return this.intersection.pointerQuaternion;\n    }\n    get pointOnFace() {\n        return this.intersection.pointOnFace;\n    }\n    get localPoint() {\n        return this.intersection.localPoint;\n    }\n    get details() {\n        return this.intersection.details;\n    }\n    /** same as target */\n    get target() {\n        return this.object;\n    }\n    /** same as currentTarget */\n    get currentTarget() {\n        return this.currentObject;\n    }\n    //the stop propagation functions will be set while propagating\n    stopPropagation;\n    stopImmediatePropagation;\n    constructor(type, bubbles, nativeEvent, pointer, intersection, currentObject = intersection.object, object = currentObject) {\n        this.type = type;\n        this.bubbles = bubbles;\n        this.nativeEvent = nativeEvent;\n        this.pointer = pointer;\n        this.intersection = intersection;\n        this.currentObject = currentObject;\n        this.object = object;\n    }\n    /**\n     * for internal use\n     */\n    retarget(currentObject) {\n        const { type, bubbles, nativeEvent, pointer, intersection, target } = this;\n        return new PointerEvent(type, bubbles, nativeEvent, pointer, intersection, currentObject, target);\n    }\n}\nexport class WheelEvent extends PointerEvent {\n    get deltaX() {\n        return this.nativeEvent.deltaX;\n    }\n    get deltaY() {\n        return this.nativeEvent.deltaY;\n    }\n    get deltaZ() {\n        return this.nativeEvent.deltaZ;\n    }\n    constructor(nativeEvent, pointer, intersection, currentObject, object) {\n        super('wheel', true, nativeEvent, pointer, intersection, currentObject, object);\n    }\n    /**\n     * for internal use\n     */\n    retarget(currentObject) {\n        const { type, bubbles, nativeEvent, pointer, intersection, target } = this;\n        return new WheelEvent(nativeEvent, pointer, intersection, currentObject, target);\n    }\n}\nexport function emitPointerEvent(event) {\n    emitPointerEventRec(event, event.currentObject);\n}\nfunction emitPointerEventRec(baseEvent, currentObject) {\n    if (currentObject == null) {\n        return;\n    }\n    const listeners = getObjectListeners(currentObject, baseEvent.type);\n    let propagationStopped = !baseEvent.bubbles;\n    if (listeners != null && listeners.length > 0) {\n        const event = baseEvent.retarget(currentObject);\n        const length = listeners.length;\n        event.stopPropagation = () => (propagationStopped = true);\n        let loopStopped = false;\n        event.stopImmediatePropagation = () => {\n            propagationStopped = true;\n            loopStopped = true;\n        };\n        for (let i = 0; i < length && !loopStopped; i++) {\n            listeners[i](event);\n        }\n    }\n    if (propagationStopped) {\n        return;\n    }\n    emitPointerEventRec(baseEvent, currentObject.parent);\n}\n", "import { hasObjectListeners } from '../utils.js';\nexport function computeIntersectionWorldPlane(target, intersection, object) {\n    if (intersection.face == null) {\n        return false;\n    }\n    target.setFromNormalAndCoplanarPoint(intersection.face.normal, intersection.localPoint);\n    target.applyMatrix4(object.matrixWorld);\n    return true;\n}\nfunction isPointerEventsAllowed(hasListener, pointerEvents, pointerEventsType) {\n    if (pointerEvents === 'none') {\n        return false;\n    }\n    if (pointerEvents === 'listener' && !hasListener) {\n        return false;\n    }\n    if (pointerEventsType === 'all') {\n        return true;\n    }\n    if (typeof pointerEventsType === 'function') {\n        return ({ id, type, state }) => pointerEventsType(id, type, state);\n    }\n    let value;\n    let invert;\n    if ('deny' in pointerEventsType) {\n        invert = true;\n        value = pointerEventsType.deny;\n    }\n    else {\n        invert = false;\n        value = pointerEventsType.allow;\n    }\n    if (Array.isArray(value)) {\n        return (pointer) => invertIf(value.includes(pointer.type), invert);\n    }\n    return (pointer) => invertIf(value === pointer.type, invert);\n}\nfunction invertIf(toInvert, ifIsTrue) {\n    return ifIsTrue ? !toInvert : toInvert;\n}\nexport function intersectPointerEventTargets(object, pointers, parentHasListener = false, parentPointerEvents, parentPointerEventsType, parentPointerEventsOrder) {\n    const hasListener = parentHasListener || hasObjectListeners(object);\n    const pointerEvents = object.pointerEvents ?? parentPointerEvents ?? 'listener';\n    const pointerEventsType = object.pointerEventsType ?? parentPointerEventsType ?? 'all';\n    const pointerEventsOrder = object.pointerEventsOrder ?? parentPointerEventsOrder;\n    const isAllowed = isPointerEventsAllowed(hasListener, pointerEvents, pointerEventsType);\n    const length = pointers.length;\n    if (isAllowed === true) {\n        for (let i = 0; i < length; i++) {\n            pointers[i].intersector.executeIntersection(object, pointerEventsOrder);\n        }\n    }\n    else if (typeof isAllowed === 'function') {\n        for (let i = 0; i < length; i++) {\n            const pointer = pointers[i];\n            if (!isAllowed(pointer)) {\n                continue;\n            }\n            pointers[i].intersector.executeIntersection(object, pointerEventsOrder);\n        }\n    }\n    const childrenLength = object.children.length;\n    for (let i = 0; i < childrenLength; i++) {\n        intersectPointerEventTargets(object.children[i], pointers, hasListener, pointerEvents, pointerEventsType, pointerEventsOrder);\n    }\n}\n/**\n * @returns undefined if `i1` is the dominant intersection\n * @param i2DistanceOffset modifies i2 and adds the i2DistanceOffset to the current distance\n */\nexport function getDominantIntersectionIndex(i1, pointerEventsOrder1, i2, pointerEventsOrder2, { customFilter, customSort: compare = defaultSort } = {}) {\n    let index = undefined;\n    const length = i2.length;\n    for (let i = 0; i < length; i++) {\n        const intersection = i2[i];\n        if (!(customFilter?.(intersection) ?? true)) {\n            continue;\n        }\n        if (i1 == null || compare(i1, pointerEventsOrder1, intersection, pointerEventsOrder2) > 0) {\n            i1 = intersection;\n            index = i;\n        }\n    }\n    return index;\n}\n/**\n * @returns a negative number if i1 should be sorted before i2\n */\nfunction defaultSort(i1, pointerEventsOrder1 = 0, i2, pointerEventsOrder2 = 0) {\n    if (pointerEventsOrder1 != pointerEventsOrder2) {\n        //inverted order because order is sorted highest first\n        return pointerEventsOrder2 - pointerEventsOrder1;\n    }\n    //i1 - i2 because negative values mean the sorting i1 before i2 is correct\n    return i1.distance - i2.distance;\n}\n", "import { Object3D } from 'three';\nimport { PointerEvent, WheelEvent, emitPointerEvent } from './event.js';\nimport { intersectPointerEventTargets } from './intersections/utils.js';\nconst buttonsDownTimeKey = Symbol('buttonsDownTime');\nconst buttonsClickTimeKey = Symbol('buttonsClickTime');\nconst pointerMap = new Map();\nObject3D.prototype.setPointerCapture = function (pointerId) {\n    getPointerById(pointerId)?.setCapture(this);\n};\nObject3D.prototype.releasePointerCapture = function (pointerId) {\n    const pointer = getPointerById(pointerId);\n    if (pointer == null || !pointer.hasCaptured(this)) {\n        return;\n    }\n    pointer.setCapture(undefined);\n};\nObject3D.prototype.hasPointerCapture = function (pointerId) {\n    return getPointerById(pointerId)?.hasCaptured(this) ?? false;\n};\nexport function getPointerById(pointerId) {\n    return pointerMap.get(pointerId);\n}\nexport class Pointer {\n    id;\n    type;\n    state;\n    intersector;\n    onMoveCommited;\n    parentSetPointerCapture;\n    parentReleasePointerCapture;\n    options;\n    //state\n    prevIntersection;\n    intersection;\n    prevEnabled = true;\n    enabled = true;\n    //derived state\n    /**\n     * ordered leaf -> root (bottom -> top)\n     */\n    pointerEntered = [];\n    pointerEnteredHelper = [];\n    pointerCapture;\n    buttonsDownTime = new Map();\n    buttonsDown = new Set();\n    //to handle interaction before first move\n    wasMoved = false;\n    onFirstMove = [];\n    constructor(id, type, state, intersector, onMoveCommited, parentSetPointerCapture, parentReleasePointerCapture, options = {}) {\n        this.id = id;\n        this.type = type;\n        this.state = state;\n        this.intersector = intersector;\n        this.onMoveCommited = onMoveCommited;\n        this.parentSetPointerCapture = parentSetPointerCapture;\n        this.parentReleasePointerCapture = parentReleasePointerCapture;\n        this.options = options;\n        pointerMap.set(id, this);\n    }\n    getPointerCapture() {\n        return this.pointerCapture;\n    }\n    hasCaptured(object) {\n        return this.pointerCapture?.object === object;\n    }\n    setCapture(object) {\n        if (this.pointerCapture?.object === object) {\n            return;\n        }\n        if (this.pointerCapture != null) {\n            this.parentReleasePointerCapture?.();\n            this.pointerCapture = undefined;\n        }\n        if (object != null && this.intersection != null) {\n            this.pointerCapture = { object, intersection: this.intersection };\n            this.parentSetPointerCapture?.();\n        }\n    }\n    getButtonsDown() {\n        return this.buttonsDown;\n    }\n    getIntersection() {\n        return this.intersection;\n    }\n    getEnabled() {\n        return this.enabled;\n    }\n    setEnabled(enabled, nativeEvent, commit = true) {\n        if (this.enabled === enabled) {\n            return;\n        }\n        if (!enabled && this.pointerCapture != null) {\n            this.parentReleasePointerCapture?.();\n            this.pointerCapture = undefined;\n        }\n        this.enabled = enabled;\n        if (commit) {\n            this.commit(nativeEvent);\n        }\n    }\n    computeIntersection(scene, nativeEvent) {\n        if (this.pointerCapture != null) {\n            return this.intersector.intersectPointerCapture(this.pointerCapture, nativeEvent);\n        }\n        this.intersector.startIntersection(nativeEvent);\n        intersectPointerEventTargets(scene, [this]);\n        return this.intersector.finalizeIntersection();\n    }\n    setIntersection(intersection) {\n        this.intersection = intersection;\n    }\n    /**\n     * allows to separately compute and afterwards commit a move\n     * => do not forget to call commitMove after computeMove\n     * can be used to compute the current intersection and disable or enable the pointer before commiting the move\n     */\n    computeMove(scene, nativeEvent) {\n        this.intersection = this.computeIntersection(scene, nativeEvent);\n    }\n    commit(nativeEvent) {\n        const prevIntersection = this.prevEnabled ? this.prevIntersection : undefined;\n        const intersection = this.enabled ? this.intersection : undefined;\n        //pointer out\n        if (prevIntersection != null && prevIntersection.object != intersection?.object) {\n            emitPointerEvent(new PointerEvent('pointerout', true, nativeEvent, this, prevIntersection));\n        }\n        const pointerLeft = this.pointerEntered;\n        this.pointerEntered = [];\n        this.pointerEnteredHelper.length = 0;\n        computeEnterLeave(intersection?.object, this.pointerEntered, pointerLeft, this.pointerEnteredHelper);\n        //pointerleave\n        const length = pointerLeft.length;\n        for (let i = 0; i < length; i++) {\n            const object = pointerLeft[i];\n            emitPointerEvent(new PointerEvent('pointerleave', false, nativeEvent, this, prevIntersection, object));\n        }\n        //pointer over\n        if (intersection != null && prevIntersection?.object != intersection.object) {\n            emitPointerEvent(new PointerEvent('pointerover', true, nativeEvent, this, intersection));\n        }\n        //pointer enter\n        //inverse loop so that we emit enter from top -> bottom (root -> leaf)\n        for (let i = this.pointerEnteredHelper.length - 1; i >= 0; i--) {\n            const object = this.pointerEnteredHelper[i];\n            emitPointerEvent(new PointerEvent('pointerenter', false, nativeEvent, this, intersection, object));\n        }\n        //pointer move\n        if (intersection != null) {\n            emitPointerEvent(new PointerEvent('pointermove', true, nativeEvent, this, intersection));\n        }\n        this.prevIntersection = this.intersection;\n        this.prevEnabled = this.enabled;\n        if (!this.wasMoved) {\n            this.wasMoved = true;\n            const length = this.onFirstMove.length;\n            for (let i = 0; i < length; i++) {\n                this.onFirstMove[i]();\n            }\n            this.onFirstMove.length = 0;\n        }\n        this.onMoveCommited?.(this);\n    }\n    /**\n     * computes and commits a move\n     */\n    move(scene, nativeEvent) {\n        this.computeMove(scene, nativeEvent);\n        this.commit(nativeEvent);\n    }\n    down(nativeEvent) {\n        this.buttonsDown.add(nativeEvent.button);\n        if (!this.enabled) {\n            return;\n        }\n        if (!this.wasMoved) {\n            this.onFirstMove.push(this.down.bind(this, nativeEvent));\n            return;\n        }\n        if (this.intersection == null) {\n            return;\n        }\n        //pointer down\n        emitPointerEvent(new PointerEvent('pointerdown', true, nativeEvent, this, this.intersection));\n        //store button down times on object and on pointer\n        const { object } = this.intersection;\n        object[buttonsDownTimeKey] ??= new Map();\n        object[buttonsDownTimeKey].set(nativeEvent.button, nativeEvent.timeStamp);\n        this.buttonsDownTime.set(nativeEvent.button, nativeEvent.timeStamp);\n    }\n    up(nativeEvent) {\n        this.buttonsDown.delete(nativeEvent.button);\n        if (!this.enabled) {\n            return;\n        }\n        if (!this.wasMoved) {\n            this.onFirstMove.push(this.up.bind(this, nativeEvent));\n            return;\n        }\n        if (this.intersection == null) {\n            return;\n        }\n        const { contextMenuButton = 2, dblClickThresholdMs = 500, clickThesholdMs = 300 } = this.options;\n        this.pointerCapture = undefined;\n        const isClicked = getIsClicked(this.buttonsDownTime, this.intersection.object[buttonsDownTimeKey], nativeEvent.button, nativeEvent.timeStamp, clickThesholdMs);\n        //context menu\n        if (isClicked && nativeEvent.button === contextMenuButton) {\n            emitPointerEvent(new PointerEvent('contextmenu', true, nativeEvent, this, this.intersection));\n        }\n        //poinerup\n        emitPointerEvent(new PointerEvent('pointerup', true, nativeEvent, this, this.intersection));\n        if (!isClicked || nativeEvent.button === contextMenuButton) {\n            return;\n        }\n        //click\n        emitPointerEvent(new PointerEvent('click', true, nativeEvent, this, this.intersection));\n        //dblclick\n        const { object } = this.intersection;\n        const buttonsClickTime = (object[buttonsClickTimeKey] ??= new Map());\n        const buttonClickTime = buttonsClickTime.get(nativeEvent.button);\n        if (buttonClickTime == null || nativeEvent.timeStamp - buttonClickTime > dblClickThresholdMs) {\n            buttonsClickTime.set(nativeEvent.button, nativeEvent.timeStamp);\n            return;\n        }\n        emitPointerEvent(new PointerEvent('dblclick', true, nativeEvent, this, this.intersection));\n        buttonsClickTime.delete(nativeEvent.button);\n    }\n    cancel(nativeEvent) {\n        if (!this.enabled) {\n            return;\n        }\n        if (!this.wasMoved) {\n            this.onFirstMove.push(this.cancel.bind(this, nativeEvent));\n            return;\n        }\n        if (this.intersection == null) {\n            return;\n        }\n        //pointer cancel\n        emitPointerEvent(new PointerEvent('pointercancel', true, nativeEvent, this, this.intersection));\n    }\n    wheel(scene, nativeEvent, useCurrentIntersection) {\n        if (!this.enabled) {\n            return;\n        }\n        let intersection = this.intersection;\n        if (!useCurrentIntersection) {\n            intersection = this.computeIntersection(scene, nativeEvent);\n        }\n        if (!this.wasMoved && useCurrentIntersection) {\n            this.onFirstMove.push(this.cancel.bind(this, nativeEvent));\n            return;\n        }\n        if (intersection == null) {\n            return;\n        }\n        //wheel\n        emitPointerEvent(new WheelEvent(nativeEvent, this, intersection));\n    }\n    exit(nativeEvent) {\n        if (!this.wasMoved) {\n            this.onFirstMove.push(this.exit.bind(this, nativeEvent));\n            return;\n        }\n        //reset state\n        if (this.pointerCapture != null) {\n            this.parentReleasePointerCapture?.();\n            this.pointerCapture = undefined;\n        }\n        this.intersection = undefined;\n        this.commit(nativeEvent);\n    }\n}\n/**\n * @returns an array that contains the object and all its ancestors ordered leaf -> root (bottom -> top)\n */\nfunction computeEnterLeave(currentObject, targetAllAncestors, targeDiffRemovedAncestors, targetDiffAddedAncestors) {\n    if (currentObject == null) {\n        return;\n    }\n    const index = targeDiffRemovedAncestors.indexOf(currentObject);\n    if (index != -1) {\n        targeDiffRemovedAncestors.splice(index, 1);\n    }\n    else {\n        targetDiffAddedAncestors.push(currentObject);\n    }\n    targetAllAncestors.push(currentObject);\n    computeEnterLeave(currentObject.parent, targetAllAncestors, targeDiffRemovedAncestors, targetDiffAddedAncestors);\n}\nfunction getIsClicked(pointerButtonsPressTime, objectButtonsDownTime, button, buttonUpTime, clickThesholdMs) {\n    if (objectButtonsDownTime == null) {\n        return false;\n    }\n    const objectButtonPressTime = objectButtonsDownTime.get(button);\n    if (objectButtonPressTime == null) {\n        return false;\n    }\n    if (buttonUpTime - objectButtonPressTime > clickThesholdMs) {\n        return false;\n    }\n    if (objectButtonPressTime != pointerButtonsPressTime.get(button)) {\n        //we have released the button somewhere else\n        return false;\n    }\n    return true;\n}\n", "export class Intersector {\n    //state of the current intersection\n    intersection;\n    pointerEventsOrder;\n    startIntersection(nativeEvent) {\n        this.intersection = undefined;\n        this.pointerEventsOrder = undefined;\n        this.prepareIntersection(nativeEvent);\n    }\n}\n", "import { Line3, Matrix4, Plane, Quaternion, Ray, Raycaster, Vector3, } from 'three';\nimport { computeIntersectionWorldPlane, getDominantIntersectionIndex } from './utils.js';\nimport { Intersector } from './intersector.js';\nconst invertedMatrixHelper = new Matrix4();\nconst intersectsHelper = [];\nconst lineHelper = new Line3();\nconst planeHelper = new Plane();\nconst rayHelper = new Ray();\nconst defaultLinePoints = [new Vector3(0, 0, 0), new Vector3(0, 0, 1)];\nexport class LinesIntersector extends Intersector {\n    prepareTransformation;\n    options;\n    raycasters = [];\n    fromMatrixWorld = new Matrix4();\n    intersectionLineIndex = 0;\n    intersectionDistanceOnLine = 0;\n    constructor(prepareTransformation, options) {\n        super();\n        this.prepareTransformation = prepareTransformation;\n        this.options = options;\n    }\n    intersectPointerCapture({ intersection, object }, nativeEvent) {\n        const details = intersection.details;\n        if (details.type != 'lines') {\n            return undefined;\n        }\n        if (!this.prepareTransformation(nativeEvent, this.fromMatrixWorld)) {\n            return undefined;\n        }\n        const linePoints = this.options.linePoints ?? defaultLinePoints;\n        lineHelper.set(linePoints[details.lineIndex], linePoints[details.lineIndex + 1]).applyMatrix4(this.fromMatrixWorld);\n        const point = lineHelper.at(details.distanceOnLine / lineHelper.distance(), new Vector3());\n        computeIntersectionWorldPlane(planeHelper, intersection, object);\n        const pointOnFace = rayHelper.intersectPlane(planeHelper, new Vector3()) ?? point;\n        return {\n            ...intersection,\n            pointOnFace,\n            point,\n            pointerPosition: new Vector3().setFromMatrixPosition(this.fromMatrixWorld),\n            pointerQuaternion: new Quaternion().setFromRotationMatrix(this.fromMatrixWorld),\n        };\n    }\n    prepareIntersection(nativeEvent) {\n        if (!this.prepareTransformation(nativeEvent, this.fromMatrixWorld)) {\n            return false;\n        }\n        const linePoints = this.options.linePoints ?? defaultLinePoints;\n        const length = linePoints.length - 1;\n        for (let i = 0; i < length; i++) {\n            const start = linePoints[i];\n            const end = linePoints[i + 1];\n            const raycaster = this.raycasters[i] ?? (this.raycasters[i] = new Raycaster());\n            //transform from local object to world\n            raycaster.ray.origin.copy(start).applyMatrix4(this.fromMatrixWorld);\n            raycaster.ray.direction.copy(end).applyMatrix4(this.fromMatrixWorld);\n            //compute length & normalized direction\n            raycaster.ray.direction.sub(raycaster.ray.origin);\n            const lineLength = raycaster.ray.direction.length();\n            raycaster.ray.direction.divideScalar(lineLength);\n            raycaster.far = lineLength;\n        }\n        this.raycasters.length = length;\n        return true;\n    }\n    executeIntersection(object, objectPointerEventsOrder) {\n        let lineLengthSum = 0;\n        const length = this.raycasters.length;\n        //TODO: optimize - we only need to intersect with raycasters before or equal to the raycaster that did the current intersection\n        for (let i = 0; i < length; i++) {\n            const raycaster = this.raycasters[i];\n            object.raycast(raycaster, intersectsHelper);\n            for (const intersection of intersectsHelper) {\n                intersection.distance += lineLengthSum;\n            }\n            const index = getDominantIntersectionIndex(this.intersection, this.pointerEventsOrder, intersectsHelper, objectPointerEventsOrder, this.options);\n            if (index != null) {\n                this.intersection = intersectsHelper[index];\n                this.intersectionLineIndex = i;\n                this.intersectionDistanceOnLine = this.intersection.distance - raycaster.far;\n                this.pointerEventsOrder = objectPointerEventsOrder;\n            }\n            intersectsHelper.length = 0;\n            lineLengthSum += raycaster.far;\n        }\n    }\n    finalizeIntersection() {\n        if (this.intersection == null) {\n            return undefined;\n        }\n        //TODO: consider maxLength\n        return Object.assign(this.intersection, {\n            details: {\n                lineIndex: this.intersectionLineIndex,\n                distanceOnLine: this.intersectionDistanceOnLine,\n                type: 'lines',\n            },\n            pointerPosition: new Vector3().setFromMatrixPosition(this.fromMatrixWorld),\n            pointerQuaternion: new Quaternion().setFromRotationMatrix(this.fromMatrixWorld),\n            pointOnFace: this.intersection.point,\n            localPoint: this.intersection.point\n                .clone()\n                .applyMatrix4(invertedMatrixHelper.copy(this.intersection.object.matrixWorld).invert()),\n        });\n    }\n}\n", "import { Matrix4, Plane, Quaternion, Raycaster, Vector3, Vector2, } from 'three';\nimport { computeIntersectionWorldPlane, getDominantIntersectionIndex } from './utils.js';\nimport { Intersector } from './intersector.js';\nconst invertedMatrixHelper = new Matrix4();\nconst intersectsHelper = [];\nconst matrixHelper = new Matrix4();\nconst scaleHelper = new Vector3();\nconst NegZAxis = new Vector3(0, 0, -1);\nconst directionHelper = new Vector3();\nconst planeHelper = new Plane();\nexport class RayIntersector extends Intersector {\n    prepareTransformation;\n    options;\n    raycaster = new Raycaster();\n    raycasterQuaternion = new Quaternion();\n    worldScale = 0;\n    constructor(prepareTransformation, options) {\n        super();\n        this.prepareTransformation = prepareTransformation;\n        this.options = options;\n    }\n    intersectPointerCapture({ intersection, object }, nativeEvent) {\n        if (intersection.details.type != 'ray') {\n            return undefined;\n        }\n        if (!this.prepareIntersection(nativeEvent)) {\n            return undefined;\n        }\n        computeIntersectionWorldPlane(planeHelper, intersection, object);\n        const { ray } = this.raycaster;\n        const pointOnFace = ray.intersectPlane(planeHelper, new Vector3()) ?? intersection.point;\n        return {\n            ...intersection,\n            object,\n            pointOnFace,\n            point: ray.direction.clone().multiplyScalar(intersection.distance).add(ray.origin),\n            pointerPosition: ray.origin.clone(),\n            pointerQuaternion: this.raycasterQuaternion.clone(),\n        };\n    }\n    prepareIntersection(nativeEvent) {\n        if (!this.prepareTransformation(nativeEvent, matrixHelper)) {\n            return false;\n        }\n        matrixHelper.decompose(this.raycaster.ray.origin, this.raycasterQuaternion, scaleHelper);\n        this.worldScale = scaleHelper.x;\n        this.raycaster.ray.direction.copy(this.options?.direction ?? NegZAxis).applyQuaternion(this.raycasterQuaternion);\n        return true;\n    }\n    executeIntersection(object, objectPointerEventsOrder) {\n        object.raycast(this.raycaster, intersectsHelper);\n        const index = getDominantIntersectionIndex(this.intersection, this.pointerEventsOrder, intersectsHelper, objectPointerEventsOrder, this.options);\n        if (index != null) {\n            this.intersection = intersectsHelper[index];\n            this.pointerEventsOrder = objectPointerEventsOrder;\n        }\n        intersectsHelper.length = 0;\n    }\n    finalizeIntersection() {\n        if (this.intersection == null) {\n            return undefined;\n        }\n        if (this.options.minDistance != null && this.intersection.distance * this.worldScale < this.options.minDistance) {\n            return undefined;\n        }\n        return Object.assign(this.intersection, {\n            details: {\n                type: 'ray',\n            },\n            pointerPosition: this.raycaster.ray.origin.clone(),\n            pointerQuaternion: this.raycasterQuaternion.clone(),\n            pointOnFace: this.intersection.point,\n            localPoint: this.intersection.point\n                .clone()\n                .applyMatrix4(invertedMatrixHelper.copy(this.intersection.object.matrixWorld).invert()),\n        });\n    }\n}\nexport class CameraRayIntersector extends Intersector {\n    prepareTransformation;\n    options;\n    raycaster = new Raycaster();\n    fromPosition = new Vector3();\n    fromQuaternion = new Quaternion();\n    coords = new Vector2();\n    viewPlane = new Plane();\n    constructor(prepareTransformation, options) {\n        super();\n        this.prepareTransformation = prepareTransformation;\n        this.options = options;\n    }\n    intersectPointerCapture({ intersection, object }, nativeEvent) {\n        const details = intersection.details;\n        if (details.type != 'camera-ray') {\n            return undefined;\n        }\n        if (!this.prepareIntersection(nativeEvent)) {\n            return undefined;\n        }\n        this.viewPlane.constant -= details.distanceViewPlane;\n        //find captured intersection point by intersecting the ray to the plane of the camera\n        const point = this.raycaster.ray.intersectPlane(this.viewPlane, new Vector3());\n        if (point == null) {\n            return undefined;\n        }\n        computeIntersectionWorldPlane(this.viewPlane, intersection, object);\n        const pointOnFace = this.raycaster.ray.intersectPlane(this.viewPlane, new Vector3()) ?? point;\n        return {\n            ...intersection,\n            object,\n            point,\n            pointOnFace,\n            pointerPosition: this.fromPosition.clone(),\n            pointerQuaternion: this.fromQuaternion.clone(),\n        };\n    }\n    prepareIntersection(nativeEvent) {\n        const from = this.prepareTransformation(nativeEvent, this.coords);\n        if (from == null) {\n            return false;\n        }\n        from.matrixWorld.decompose(this.fromPosition, this.fromQuaternion, scaleHelper);\n        from.updateWorldMatrix(true, false);\n        this.raycaster.setFromCamera(this.coords, from);\n        this.viewPlane.setFromNormalAndCoplanarPoint(from.getWorldDirection(directionHelper), this.raycaster.ray.origin);\n        return true;\n    }\n    executeIntersection(object, objectPointerEventsOrder) {\n        object.raycast(this.raycaster, intersectsHelper);\n        const index = getDominantIntersectionIndex(this.intersection, this.pointerEventsOrder, intersectsHelper, objectPointerEventsOrder, this.options);\n        if (index != null) {\n            this.intersection = intersectsHelper[index];\n            this.pointerEventsOrder = objectPointerEventsOrder;\n        }\n        intersectsHelper.length = 0;\n    }\n    finalizeIntersection() {\n        if (this.intersection == null) {\n            return undefined;\n        }\n        invertedMatrixHelper.copy(this.intersection.object.matrixWorld).invert();\n        return Object.assign(this.intersection, {\n            details: {\n                type: 'camera-ray',\n                distanceViewPlane: this.viewPlane.distanceToPoint(this.intersection.point),\n            },\n            pointOnFace: this.intersection.point,\n            pointerPosition: this.fromPosition.clone(),\n            pointerQuaternion: this.fromQuaternion.clone(),\n            localPoint: this.intersection.point.clone().applyMatrix4(invertedMatrixHelper),\n        });\n    }\n}\n", "import { InstancedMesh, Matrix4, Mesh, Vector3, Sphere, Quaternion, Plane, } from 'three';\nimport { computeIntersectionWorldPlane, getDominantIntersectionIndex } from './utils.js';\nimport { Intersector } from './intersector.js';\nconst collisionSphere = new Sphere();\nconst intersectsHelper = [];\nexport class SphereIntersector extends Intersector {\n    prepareTransformation;\n    options;\n    fromPosition = new Vector3();\n    fromQuaternion = new Quaternion();\n    constructor(\n    /**\n     * @returns the sphere radius\n     */\n    prepareTransformation, options) {\n        super();\n        this.prepareTransformation = prepareTransformation;\n        this.options = options;\n    }\n    intersectPointerCapture({ intersection, object }, nativeEvent) {\n        if (intersection.details.type != 'sphere') {\n            return undefined;\n        }\n        if (this.prepareTransformation(nativeEvent, this.fromPosition, this.fromQuaternion) == null) {\n            return undefined;\n        }\n        //compute old inputDevicePosition-point offset\n        oldInputDevicePointOffset.copy(intersection.point).sub(intersection.pointerPosition);\n        //compute oldInputDeviceQuaternion-newInputDeviceQuaternion offset\n        inputDeviceQuaternionOffset.copy(intersection.pointerQuaternion).invert().multiply(this.fromQuaternion);\n        //apply quaternion offset to old inputDevicePosition-point offset and add to new inputDevicePosition\n        const point = oldInputDevicePointOffset.clone().applyQuaternion(inputDeviceQuaternionOffset).add(this.fromPosition);\n        computeIntersectionWorldPlane(planeHelper, intersection, object);\n        const pointOnFace = planeHelper.projectPoint(this.fromPosition, new Vector3());\n        return {\n            details: {\n                type: 'sphere',\n            },\n            distance: intersection.distance,\n            pointerPosition: this.fromPosition.clone(),\n            pointerQuaternion: this.fromQuaternion.clone(),\n            object,\n            point,\n            pointOnFace,\n            face: intersection.face,\n            localPoint: intersection.localPoint,\n        };\n    }\n    prepareIntersection(nativeEvent) {\n        const radius = this.prepareTransformation(nativeEvent, this.fromPosition, this.fromQuaternion);\n        if (radius == null) {\n            return false;\n        }\n        collisionSphere.center.copy(this.fromPosition);\n        collisionSphere.radius = radius;\n        return true;\n    }\n    executeIntersection(object, objectPointerEventsOrder) {\n        intersectSphereWithObject(collisionSphere, object, intersectsHelper);\n        const index = getDominantIntersectionIndex(this.intersection, this.pointerEventsOrder, intersectsHelper, objectPointerEventsOrder, this.options);\n        if (index != null) {\n            this.intersection = intersectsHelper[index];\n            this.pointerEventsOrder = objectPointerEventsOrder;\n        }\n        intersectsHelper.length = 0;\n    }\n    finalizeIntersection() {\n        if (this.intersection == null) {\n            return undefined;\n        }\n        return Object.assign(this.intersection, {\n            details: {\n                type: 'sphere',\n            },\n            pointOnFace: this.intersection.point,\n            pointerPosition: this.fromPosition.clone(),\n            pointerQuaternion: this.fromQuaternion.clone(),\n            localPoint: this.intersection.point\n                .clone()\n                .applyMatrix4(invertedMatrixHelper.copy(this.intersection.object.matrixWorld).invert()),\n        });\n    }\n}\nconst matrixHelper = new Matrix4();\nfunction isSpherecastable(obj) {\n    return 'spherecast' in obj;\n}\nfunction intersectSphereWithObject(pointerSphere, object, target) {\n    object.updateWorldMatrix(true, false);\n    if (isSpherecastable(object)) {\n        object.spherecast(pointerSphere, target);\n        return;\n    }\n    if (object instanceof InstancedMesh) {\n        if (object.geometry.boundingSphere == null) {\n            object.geometry.computeBoundingSphere();\n        }\n        if (object.geometry.boundingBox == null) {\n            object.geometry.computeBoundingBox();\n        }\n        for (let i = 0; i < object.count; i++) {\n            object.getMatrixAt(i, matrixHelper);\n            matrixHelper.premultiply(object.matrixWorld);\n            if (!isSphereIntersectingMesh(pointerSphere, object, matrixHelper)) {\n                continue;\n            }\n            const intersection = intersectSphereMesh(pointerSphere, object, matrixHelper, i);\n            if (intersection == null) {\n                continue;\n            }\n            target.push(intersection);\n        }\n    }\n    if (!(object instanceof Mesh)) {\n        return;\n    }\n    if (!isSphereIntersectingMesh(pointerSphere, object, object.matrixWorld)) {\n        return;\n    }\n    invertedMatrixHelper.copy(object.matrixWorld).invert();\n    const intersection = intersectSphereMesh(pointerSphere, object, object.matrixWorld);\n    if (intersection == null) {\n        return;\n    }\n    target.push(intersection);\n}\nconst oldInputDevicePointOffset = new Vector3();\nconst inputDeviceQuaternionOffset = new Quaternion();\nconst planeHelper = new Plane();\nconst helperSphere = new Sphere();\nfunction isSphereIntersectingMesh(pointerSphere, { geometry }, meshMatrixWorld) {\n    if (geometry.boundingSphere == null) {\n        geometry.computeBoundingSphere();\n    }\n    helperSphere.copy(geometry.boundingSphere).applyMatrix4(meshMatrixWorld);\n    return helperSphere.center.distanceToSquared(pointerSphere.center) < (pointerSphere.radius + helperSphere.radius) ** 2;\n}\nconst vectorHelper = new Vector3();\nconst boxSizeHelper = new Vector3();\nconst boxCenterHelper = new Vector3();\nconst vec0_0001 = new Vector3(0.0001, 0.0001, 0.0001);\nconst invertedMatrixHelper = new Matrix4();\nfunction intersectSphereMesh(pointerSphere, mesh, meshMatrixWorld, instanceId) {\n    invertedMatrixHelper.copy(meshMatrixWorld).invert();\n    helperSphere.copy(pointerSphere).applyMatrix4(invertedMatrixHelper);\n    const { geometry } = mesh;\n    if (geometry.boundingBox == null) {\n        geometry.computeBoundingBox();\n    }\n    geometry.boundingBox.getSize(boxSizeHelper);\n    geometry.boundingBox.getCenter(boxCenterHelper);\n    geometry.boundingBox.clampPoint(helperSphere.center, vectorHelper);\n    vectorHelper.applyMatrix4(meshMatrixWorld); //world coordinates\n    const distanceToSphereCenterSquared = vectorHelper.distanceToSquared(pointerSphere.center);\n    if (distanceToSphereCenterSquared > pointerSphere.radius * pointerSphere.radius) {\n        return undefined;\n    }\n    boxSizeHelper.max(vec0_0001);\n    const normal = helperSphere.center.clone().sub(boxCenterHelper);\n    normal.divide(boxSizeHelper);\n    maximizeAxisVector(normal);\n    const point = vectorHelper.clone();\n    return {\n        distance: Math.sqrt(distanceToSphereCenterSquared),\n        face: {\n            a: 0,\n            b: 0,\n            c: 0,\n            materialIndex: 0,\n            normal,\n        },\n        normal,\n        point,\n        instanceId,\n        object: mesh,\n    };\n}\nfunction maximizeAxisVector(vec) {\n    const absX = Math.abs(vec.x);\n    const absY = Math.abs(vec.y);\n    const absZ = Math.abs(vec.z);\n    if (absX >= absY && absX >= absZ) {\n        //x biggest\n        vec.set(vec.x < 0 ? -1 : 1, 0, 0);\n        return;\n    }\n    if (absY >= absX && absY >= absZ) {\n        //y biggest\n        vec.set(0, vec.y < 0 ? -1 : 1, 0);\n        return;\n    }\n    //z biggest\n    vec.set(0, 0, vec.z < 0 ? -1 : 1);\n}\n", "import { Pointer } from '../pointer.js';\nimport { SphereIntersector } from '../intersections/sphere.js';\nimport { generateUniquePointerId } from './index.js';\nexport function createGrabPointer(space, pointerState, options = {}, pointerType = 'grab') {\n    return new Pointer(generateUniquePointerId(), pointerType, pointerState, new SphereIntersector((_nativeEvent, fromPosition, fromQuaternion) => {\n        const spaceObject = space.current;\n        if (spaceObject == null) {\n            return undefined;\n        }\n        spaceObject.updateWorldMatrix(true, false);\n        fromPosition.setFromMatrixPosition(spaceObject.matrixWorld);\n        fromQuaternion.setFromRotationMatrix(spaceObject.matrixWorld);\n        return options.radius ?? 0.07;\n    }, options), undefined, undefined, undefined, options);\n}\n", "import { Pointer } from '../pointer.js';\nimport { RayIntersector } from '../intersections/index.js';\nimport { generateUniquePointerId } from './index.js';\nexport function createRayPointer(space, pointerState, options = {}, pointerType = 'ray') {\n    return new Pointer(generateUniquePointerId(), pointerType, pointerState, new RayIntersector((_nativeEvent, matrixWorld) => {\n        if (space.current == null) {\n            return false;\n        }\n        matrixWorld.copy(space.current.matrixWorld);\n        return true;\n    }, options), undefined, undefined, undefined, options);\n}\n", "import { Pointer } from '../pointer.js';\nimport { LinesIntersector } from '../intersections/index.js';\nimport { generateUniquePointerId } from './index.js';\nexport function createLinesPointer(space, pointerState, options = {}, pointerType = 'lines') {\n    return new Pointer(generateUniquePointerId(), pointerType, pointerState, new LinesIntersector((_nativeEvent, fromMatrixWorld) => {\n        const spaceObject = space.current;\n        if (spaceObject == null) {\n            return false;\n        }\n        fromMatrixWorld.copy(spaceObject.matrixWorld);\n        return true;\n    }, options), undefined, undefined, undefined, options);\n}\n", "import { Pointer } from '../pointer.js';\nimport { SphereIntersector } from '../intersections/index.js';\nimport { generateUniquePointerId } from './index.js';\nexport function createTouchPointer(space, pointerState, options = {}, pointerType = 'touch') {\n    return new Pointer(generateUniquePointerId(), pointerType, pointerState, new SphereIntersector((_nativeEvent, fromPosition, fromQuaternion) => {\n        const spaceObject = space.current;\n        if (spaceObject == null) {\n            return undefined;\n        }\n        spaceObject.updateWorldMatrix(true, false);\n        fromPosition.setFromMatrixPosition(spaceObject.matrixWorld);\n        fromQuaternion.setFromRotationMatrix(spaceObject.matrixWorld);\n        return options.hoverRadius ?? 0.1;\n    }, options), createUpdateTouchPointer(options), undefined, undefined, options);\n}\nfunction createUpdateTouchPointer(options) {\n    let wasPointerDown = false;\n    return (pointer) => {\n        if (!pointer.getEnabled()) {\n            return;\n        }\n        const intersection = pointer.getIntersection();\n        const isPointerDown = computeIsPointerDown(intersection, options.downRadius ?? 0.03);\n        if (isPointerDown === wasPointerDown) {\n            return;\n        }\n        const nativeEvent = { timeStamp: performance.now(), button: options.button ?? 0 };\n        if (isPointerDown) {\n            pointer.down(nativeEvent);\n        }\n        else {\n            pointer.up(nativeEvent);\n        }\n        wasPointerDown = isPointerDown;\n    };\n}\nfunction computeIsPointerDown(intersection, downRadius) {\n    if (intersection == null) {\n        return false;\n    }\n    return intersection.distance <= downRadius;\n}\n", "let pointerIdCounter = 23412;\nexport function generateUniquePointerId() {\n    return pointerIdCounter++;\n}\nexport * from './grab.js';\nexport * from './ray.js';\nexport * from './lines.js';\nexport * from './touch.js';\n", "import { Mesh } from 'three';\nimport { Pointer } from './pointer.js';\nimport { PointerEvent } from './event.js';\nimport { CameraRayIntersector } from './intersections/ray.js';\nimport { generateUniquePointerId } from './pointer/index.js';\nimport { getClosestUV } from './utils.js';\nfunction htmlEventToCoords(element, e, target) {\n    if (!(e instanceof globalThis.MouseEvent)) {\n        return target.set(0, 0);\n    }\n    const { width, height, top, left } = element.getBoundingClientRect();\n    const x = e.pageX - left;\n    const y = e.pageY - top;\n    return target.set((x / width) * 2 - 1, -(y / height) * 2 + 1);\n}\n/**\n * sets the `pointerTypePrefix` to `\"screen-\"`. Therefore, a event with pointerType `touch` is forwarded to the scene as `\"screen-touch\"`\n */\nexport function forwardHtmlEvents(fromElement, toCamera, toScene, options) {\n    return forwardEvents(fromElement, toCamera, toScene, htmlEventToCoords.bind(null, fromElement), fromElement.setPointerCapture.bind(fromElement), fromElement.releasePointerCapture.bind(fromElement), {\n        pointerTypePrefix: 'screen-',\n        ...options,\n    });\n}\nfunction portalEventToCoords(e, target) {\n    if (!(e instanceof PointerEvent)) {\n        return target.set(0, 0);\n    }\n    if (!(e.object instanceof Mesh)) {\n        return target.set(0, 0);\n    }\n    getClosestUV(target, e.point, e.object);\n    target.multiplyScalar(2).addScalar(-1);\n    return target;\n}\nexport function forwardObjectEvents(fromPortal, toCamera, toScene, options) {\n    return forwardEvents(fromPortal, toCamera, toScene, portalEventToCoords, fromPortal.setPointerCapture.bind(fromPortal), fromPortal.releasePointerCapture.bind(fromPortal), options);\n}\n/**\n * @returns cleanup function\n */\nfunction forwardEvents(from, toCamera, toScene, toCoords, setPointerCapture, releasePointerCapture, options = {}) {\n    const forwardPointerCapture = options?.forwardPointerCapture ?? true;\n    const pointerMap = new Map();\n    const pointerTypePrefix = options.pointerTypePrefix ?? 'forward-';\n    const getInnerPointer = ({ pointerId = -1, pointerType = 'mouse', pointerState }) => {\n        let innerPointer = pointerMap.get(pointerId);\n        if (innerPointer != null) {\n            return innerPointer;\n        }\n        pointerMap.set(pointerId, (innerPointer = new Pointer(generateUniquePointerId(), `${pointerTypePrefix}${pointerType}`, pointerState, new CameraRayIntersector((nativeEvent, coords) => {\n            toCoords(nativeEvent, coords);\n            return toCamera;\n        }, options), undefined, forwardPointerCapture ? setPointerCapture.bind(null, pointerId) : undefined, forwardPointerCapture ? releasePointerCapture.bind(null, pointerId) : undefined, options)));\n        return innerPointer;\n    };\n    const pointerMoveListener = (e) => getInnerPointer(e).move(toScene, e);\n    const pointerCancelListener = (e) => getInnerPointer(e).cancel(e);\n    const pointerDownListener = (e) => void (hasButton(e) && getInnerPointer(e).down(e));\n    const pointerUpListener = (e) => void (hasButton(e) && getInnerPointer(e).up(e));\n    const pointerLeaveListener = (e) => getInnerPointer(e).exit(e);\n    const wheelListener = (e) => getInnerPointer(e).wheel(toScene, e, false);\n    from.addEventListener('pointermove', pointerMoveListener);\n    from.addEventListener('pointercancel', pointerCancelListener);\n    from.addEventListener('pointerdown', pointerDownListener);\n    from.addEventListener('pointerup', pointerUpListener);\n    from.addEventListener('pointerleave', pointerLeaveListener);\n    from.addEventListener('wheel', wheelListener);\n    return () => {\n        from.removeEventListener('pointermove', pointerMoveListener);\n        from.removeEventListener('pointercancel', pointerCancelListener);\n        from.removeEventListener('pointerdown', pointerDownListener);\n        from.removeEventListener('pointerup', pointerUpListener);\n        from.removeEventListener('pointerleave', pointerLeaveListener);\n        from.removeEventListener('wheel', wheelListener);\n    };\n}\nfunction hasButton(val) {\n    return val.button != null;\n}\n", "import { intersectPointerEventTargets } from './intersections/utils.js';\nexport class CombinedPointer {\n    enableMultiplePointers;\n    pointers = [];\n    isDefaults = [];\n    enabled = true;\n    activePointer;\n    nonCapturedPointers = [];\n    constructor(enableMultiplePointers) {\n        this.enableMultiplePointers = enableMultiplePointers;\n    }\n    register(pointer, isDefault = false) {\n        this.pointers.push(pointer);\n        this.isDefaults.push(isDefault);\n        return this.unregister.bind(this, pointer);\n    }\n    unregister(pointer) {\n        const index = this.pointers.indexOf(pointer);\n        if (index === -1) {\n            return;\n        }\n        this.isDefaults.splice(index, 1);\n        this.pointers.splice(index, 1);\n    }\n    /**\n     * @returns true if any pointer is captured\n     */\n    startIntersection(nonCapturedPointers, nativeEvent) {\n        const length = this.pointers.length;\n        let anyPointerIsCaptured = false;\n        for (let i = 0; i < length; i++) {\n            const pointer = this.pointers[i];\n            if (pointer instanceof CombinedPointer) {\n                pointer.startIntersection(nonCapturedPointers, nativeEvent);\n                continue;\n            }\n            const pointerCapture = pointer.getPointerCapture();\n            if (pointerCapture != null) {\n                anyPointerIsCaptured = true;\n                pointer.setIntersection(pointer.intersector.intersectPointerCapture(pointerCapture, nativeEvent));\n                continue;\n            }\n            nonCapturedPointers.push(pointer);\n            pointer.intersector.startIntersection(nativeEvent);\n        }\n        return anyPointerIsCaptured;\n    }\n    /**\n     * only for internal use\n     */\n    getIntersection() {\n        return this.activePointer?.getIntersection();\n    }\n    /**\n     * only for internal use\n     */\n    getPointerCapture() {\n        return this.activePointer?.getPointerCapture();\n    }\n    computeActivePointer() {\n        let smallestDistance;\n        this.activePointer = undefined;\n        const length = this.pointers.length;\n        for (let i = 0; i < length; i++) {\n            const pointer = this.pointers[i];\n            if (pointer instanceof CombinedPointer) {\n                pointer.computeActivePointer();\n            }\n            const intersection = pointer.getIntersection();\n            const distance = pointer.getPointerCapture() != null ? -Infinity : (intersection?.distance ?? Infinity);\n            const isDefault = this.isDefaults[i];\n            if (smallestDistance == null || (isDefault && distance === smallestDistance) || distance < smallestDistance) {\n                this.activePointer = pointer;\n                smallestDistance = distance;\n            }\n        }\n    }\n    /**\n     * only for internal use\n     */\n    commit(nativeEvent, computeActivePointer = true) {\n        if (this.enableMultiplePointers) {\n            const length = this.pointers.length;\n            for (let i = 0; i < length; i++) {\n                this.pointers[i].commit(nativeEvent);\n            }\n            return;\n        }\n        if (computeActivePointer) {\n            this.computeActivePointer();\n        }\n        //commit all pointers, enable the active pointer, and disable all other pointers\n        const length = this.pointers.length;\n        for (let i = 0; i < length; i++) {\n            const pointer = this.pointers[i];\n            pointer.setEnabled(pointer === this.activePointer, nativeEvent, false);\n            pointer.commit(nativeEvent, false);\n        }\n    }\n    move(scene, nativeEvent) {\n        if (!this.enabled) {\n            return;\n        }\n        //start intersection, build nonCapturedPointers list, and compute the intersection for all captured pointers\n        this.nonCapturedPointers.length = 0;\n        const anyPointerIsCaptured = this.startIntersection(this.nonCapturedPointers, nativeEvent);\n        //we only need to intersect the scene if no pointer is captured or (in case one or more pointers are captured) if mulitple pointers can be enabled\n        if (!anyPointerIsCaptured || this.enableMultiplePointers) {\n            //intersect scene using the non captured pointers\n            intersectPointerEventTargets(scene, this.nonCapturedPointers);\n            //finalize the intersection for the non captured pointers\n            const nonCapturedPointerLength = this.nonCapturedPointers.length;\n            for (let i = 0; i < nonCapturedPointerLength; i++) {\n                const pointer = this.nonCapturedPointers[i];\n                pointer.setIntersection(pointer.intersector.finalizeIntersection());\n            }\n        }\n        //commit the intersection, compute active pointers, and enabling/disabling pointers\n        this.commit(nativeEvent);\n    }\n    setEnabled(enabled, nativeEvent) {\n        this.enabled = enabled;\n        const length = this.pointers.length;\n        for (let i = 0; i < length; i++) {\n            const pointer = this.pointers[i];\n            pointer.setEnabled(enabled && (this.enableMultiplePointers || pointer == this.activePointer), nativeEvent);\n        }\n    }\n}\n", "import { BufferAttribute, BufferGeometry } from 'three';\nexport function updateXRMeshGeometry(mesh, geometry) {\n    if (geometry != null && geometry.createdAt != null && geometry.createdAt >= mesh.lastChangedTime) {\n        return geometry;\n    }\n    const newGeometry = new BufferGeometry();\n    newGeometry.setIndex(new BufferAttribute(mesh.indices, 1));\n    newGeometry.setAttribute('position', new BufferAttribute(mesh.vertices, 3));\n    return Object.assign(newGeometry, { creationTime: mesh.lastChangedTime });\n}\n", "import { Box2, BufferGeometry, Shape, ShapeGeometry, Vector2 } from 'three';\nexport function updateXRPlaneGeometry(plane, geometry) {\n    if (geometry != null && geometry.createdAt != null && geometry.createdAt >= plane.lastChangedTime) {\n        return geometry;\n    }\n    return Object.assign(createGeometryFromPolygon(plane.polygon), { createdAt: plane.lastChangedTime });\n}\nconst boxHelper = new Box2();\nconst sizeHelper = new Vector2();\nfunction createGeometryFromPolygon(polygon) {\n    if (polygon.length === 0) {\n        return new BufferGeometry();\n    }\n    const shape = new Shape();\n    const points = polygon.map(({ x, z }) => new Vector2(x, z));\n    //we measure the size and scale & unscale to have normalized UVs for the geometry\n    boxHelper.setFromPoints(points);\n    boxHelper.getSize(sizeHelper);\n    for (const point of points) {\n        point.sub(boxHelper.min);\n        point.divide(sizeHelper);\n    }\n    shape.setFromPoints(points);\n    const geometry = new ShapeGeometry(shape);\n    geometry.scale(sizeHelper.x, sizeHelper.y, 1);\n    geometry.translate(boxHelper.min.x, boxHelper.min.y, 0);\n    geometry.rotateX(Math.PI / 2);\n    return geometry;\n}\n", "export function toDOMPointInit(value, defaultW = 1) {\n    if (value == null) {\n        return undefined;\n    }\n    return { x: value.x, y: value.y, z: value.z, w: 'w' in value ? value.w : defaultW };\n}\n", "import { CylinderGeometry, DepthTexture, HalfFloatType, LinearFilter, Matrix4, PlaneGeometry, Quaternion, SphereGeometry, SRGBColorSpace, Texture, Vector3, VideoTexture, WebGLRenderTarget, } from 'three';\nimport { getSpaceFromAncestors } from './space.js';\nimport { toDOMPointInit } from './utils.js';\nconst DefaultCentralAngle = (60 / 180) * Math.PI;\nconst DefaultCentralHorizontalAngle = (60 / 180) * Math.PI;\nconst DefaultLowerVerticalAngle = (-30 / 180) * Math.PI;\nconst DefaultUpperVerticalAngle = (30 / 180) * Math.PI;\nexport function createXRLayer(src, state, xrManager, relativeTo, options, properties) {\n    return src instanceof HTMLVideoElement\n        ? createXRVideoLayer(src, state, relativeTo, options, properties)\n        : createXRNormalLayer(src, state, xrManager, relativeTo, options, properties);\n}\nfunction createXRVideoLayer(src, state, relativeTo, { invertStereo, layout, shape = 'quad' }, properties = {}) {\n    const space = getSpaceFromAncestors(relativeTo, state.origin, state.originReferenceSpace, matrixHelper);\n    if (space == null) {\n        return undefined;\n    }\n    const transform = matrixToRigidTransform(matrixHelper, scaleHelper);\n    const init = {\n        invertStereo,\n        layout,\n        space,\n        transform,\n    };\n    applyXRLayerScale(shape, init, properties.centralAngle, scaleHelper);\n    const fnName = `create${capitalize(shape)}Layer`;\n    const layer = state.mediaBinding?.[fnName](src, init);\n    if (layer == null) {\n        return;\n    }\n    updateXRLayerProperties(layer, properties);\n    return layer;\n}\nfunction createXRNormalLayer(src, state, xrManager, relativeTo, { shape = 'quad', ...options }, properties = {}) {\n    const space = getSpaceFromAncestors(relativeTo, state.origin, state.originReferenceSpace, matrixHelper);\n    if (space == null) {\n        return undefined;\n    }\n    const transform = matrixToRigidTransform(matrixHelper, scaleHelper);\n    const init = {\n        ...options,\n        isStatic: !(src instanceof WebGLRenderTarget),\n        textureType: 'texture',\n        viewPixelWidth: options.layout === 'stereo-left-right' ? src.width / 2 : src.width,\n        viewPixelHeight: options.layout === 'stereo-top-bottom' ? src.height / 2 : src.height,\n        space,\n        transform,\n    };\n    applyXRLayerScale(shape, init, properties.centralAngle, scaleHelper);\n    const fnName = `create${capitalize(shape)}Layer`;\n    const layer = xrManager.getBinding()?.[fnName](init);\n    if (layer == null) {\n        return;\n    }\n    updateXRLayerProperties(layer, properties);\n    return layer;\n}\nconst matrixHelper = new Matrix4();\nconst vectorHelper = new Vector3();\nconst quaternionHelper = new Quaternion();\nconst scaleHelper = new Vector3();\nfunction matrixToRigidTransform(matrix, scaleTarget = scaleHelper) {\n    matrix.decompose(vectorHelper, quaternionHelper, scaleTarget);\n    return new XRRigidTransform(toDOMPointInit(vectorHelper), toDOMPointInit(quaternionHelper));\n}\nexport function setXRLayerRenderTarget(renderer, renderTarget, layerEntry, frame) {\n    if (layerEntry != null && frame != null) {\n        const subImage = renderer.xr.getBinding().getSubImage(layerEntry.layer, frame);\n        renderer.setRenderTargetTextures(renderTarget, subImage.colorTexture);\n    }\n    renderer.setRenderTarget(renderTarget);\n}\nexport function createXRLayerGeometry(shape, properties) {\n    switch (shape) {\n        case 'cylinder':\n            const centralAngle = properties.centralAngle ?? DefaultCentralAngle;\n            return new CylinderGeometry(1, 1, 1, 32, 1, true, Math.PI - centralAngle / 2, centralAngle).scale(-1, 1, 1);\n        case 'equirect': {\n            const centralHorizontalAngle = properties.centralHorizontalAngle ?? DefaultCentralHorizontalAngle;\n            const upperVerticalAngle = properties.upperVerticalAngle ?? DefaultUpperVerticalAngle;\n            return new SphereGeometry(1, 32, 16, -Math.PI / 2 - centralHorizontalAngle / 2, centralHorizontalAngle, Math.PI / 2 - upperVerticalAngle, upperVerticalAngle - (properties.lowerVerticalAngle ?? DefaultLowerVerticalAngle)).scale(-1, 1, 1);\n        }\n        case 'quad':\n            return new PlaneGeometry();\n    }\n}\nfunction capitalize(text) {\n    return `${text[0].toUpperCase()}${text.slice(1)}`;\n}\nexport function updateXRLayerProperties(target, properties = {}) {\n    target.chromaticAberrationCorrection = properties.chromaticAberrationCorrection;\n    target.quality = properties.quality ?? 'default';\n    target.blendTextureSourceAlpha = properties.blendTextureSourceAlpha ?? false;\n    if (target instanceof XRCylinderLayer) {\n        target.centralAngle = properties?.centralAngle ?? DefaultCentralAngle;\n        return;\n    }\n    if (target instanceof XREquirectLayer) {\n        target.centralHorizontalAngle = properties?.centralHorizontalAngle ?? DefaultCentralHorizontalAngle;\n        target.lowerVerticalAngle = properties?.lowerVerticalAngle ?? DefaultLowerVerticalAngle;\n        target.upperVerticalAngle = properties?.upperVerticalAngle ?? DefaultUpperVerticalAngle;\n    }\n}\nexport function setupXRImageLayer(renderer, store, layer, src) {\n    let stop = false;\n    const draw = async () => {\n        const frame = await store.requestFrame();\n        if (stop) {\n            return;\n        }\n        writeContentToXRLayer(renderer, layer, frame, src);\n    };\n    layer.addEventListener('redraw', draw);\n    draw();\n    return () => {\n        stop = true;\n        layer.removeEventListener('redraw', draw);\n    };\n}\nexport async function waitForXRLayerSrcSize(src) {\n    if (src instanceof HTMLImageElement && !src.complete) {\n        await new Promise((resolve) => {\n            const onResolve = () => {\n                resolve();\n                src.removeEventListener('load', onResolve);\n            };\n            src.addEventListener('load', onResolve);\n        });\n    }\n    if (src instanceof HTMLVideoElement && src.readyState < 1) {\n        return new Promise((resolve) => {\n            const onResolve = () => {\n                resolve();\n                src.removeEventListener('loadedmetadata', onResolve);\n            };\n            src.addEventListener('loadedmetadata', onResolve);\n        });\n    }\n}\nexport function getXRLayerSrcTexture(src) {\n    if (src instanceof WebGLRenderTarget) {\n        return src.texture;\n    }\n    const texture = src instanceof HTMLVideoElement ? new VideoTexture(src) : new Texture(src);\n    texture.colorSpace = SRGBColorSpace;\n    texture.needsUpdate = true;\n    return texture;\n}\nfunction writeContentToXRLayer(renderer, layer, frame, content) {\n    const context = renderer.getContext();\n    const subImage = renderer.xr.getBinding().getSubImage(layer, frame);\n    renderer.state.bindTexture(context.TEXTURE_2D, subImage.colorTexture);\n    context.pixelStorei(context.UNPACK_FLIP_Y_WEBGL, true);\n    context.texSubImage2D(context.TEXTURE_2D, 0, 0, 0, content.width, content.height, context.RGBA, context.UNSIGNED_BYTE, content);\n}\nexport function updateXRLayerTransform(state, target, centralAngle, relativeTo) {\n    if (state.originReferenceSpace == null) {\n        return;\n    }\n    target.space = getSpaceFromAncestors(relativeTo, state.origin, state.originReferenceSpace, matrixHelper);\n    target.transform = matrixToRigidTransform(matrixHelper, scaleHelper);\n    applyXRLayerScale(getLayerShape(target), target, centralAngle, scaleHelper);\n}\nfunction applyXRLayerScale(shape, target, centralAngle, scale) {\n    if (shape === 'cylinder') {\n        //0.5 * avg of x and z axis\n        const scaleXZ = (scale.x + scale.z) / 2;\n        const radius = scaleXZ;\n        const layerWidth = radius * (centralAngle ?? DefaultCentralAngle);\n        target.radius = radius;\n        target.aspectRatio = layerWidth / scale.y;\n    }\n    else if (shape === 'quad') {\n        target.width = scale.x / 2;\n        target.height = scale.y / 2;\n    }\n    else {\n        target.radius = (scale.x + scale.y + scale.z) / 3;\n    }\n}\nexport function getLayerShape(layer) {\n    if (layer instanceof XRCylinderLayer) {\n        return 'cylinder';\n    }\n    if (layer instanceof XREquirectLayer) {\n        return 'equirect';\n    }\n    return 'quad';\n}\nexport function createXRLayerRenderTarget(pixelWidth, pixelHeight, dpr) {\n    return new WebGLRenderTarget(pixelWidth * dpr, pixelHeight * dpr, {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter,\n        type: HalfFloatType,\n        depthTexture: new DepthTexture(pixelWidth, pixelHeight),\n    });\n}\n", "import { Quaternion, Vector3 } from 'three';\nconst vectorHelper = new Vector3();\nconst directionHelper = new Vector3();\nconst positionHelper = new Vector3();\nconst quaternionHelper = new Quaternion();\nexport function isFacingCamera(camera, object, direction, angle) {\n    //compute object world direction -> directionHelper\n    object.getWorldQuaternion(quaternionHelper);\n    directionHelper.copy(direction).applyQuaternion(quaternionHelper);\n    //compute guardToCamera direction (guard - camera) -> vectorHelper\n    object.getWorldPosition(positionHelper);\n    camera.getWorldPosition(vectorHelper);\n    vectorHelper.sub(positionHelper);\n    //compute the angle between guardToCamera and object world direction\n    return vectorHelper.angleTo(directionHelper) < angle / 2;\n}\n", "import { Euler, Mesh, QuadraticBezierCurve3, Quaternion, Vector3, } from 'three';\nimport { MeshLineGeometry, MeshLineMaterial } from 'meshline';\nimport { clamp } from 'three/src/math/MathUtils.js';\n/**\n * marks its children as teleportable\n */\nexport function makeTeleportTarget(root, camera, onTeleport) {\n    root.traverse((object) => (object.userData.teleportTarget = true));\n    const listener = (e) => {\n        if ('point' in e && e.point instanceof Vector3) {\n            const c = typeof camera === 'function' ? camera() : camera;\n            const point = new Vector3().setFromMatrixPosition(c.matrix).negate().setComponent(1, 0).add(e.point);\n            onTeleport(point, e);\n        }\n    };\n    root.addEventListener('pointerup', listener);\n    return () => {\n        root.traverse((object) => (object.userData.teleportTarget = false));\n        root.removeEventListener('pointerup', listener);\n    };\n}\nconst eulerHelper = new Euler(0, 0, 0, 'YXZ');\nconst quaternionHelper = new Quaternion();\n/**\n * @param space\n * @param rayGroup must be placed directly into the scene\n */\nexport function syncTeleportPointerRayGroup(space, rayGroup, deltaTimeMs) {\n    space.matrixWorld.decompose(rayGroup.position, quaternionHelper, rayGroup.scale);\n    eulerHelper.setFromQuaternion(quaternionHelper);\n    eulerHelper.z = 0;\n    eulerHelper.x = clamp(eulerHelper.x - (10 * Math.PI) / 180, -Math.PI / 2, (1.1 * Math.PI) / 4);\n    quaternionHelper.setFromEuler(eulerHelper);\n    rayGroup.quaternion.slerp(quaternionHelper, deltaTimeMs / 100);\n}\n/**\n * check if the object is marked as teleportable\n */\nexport function isTeleportTarget(object) {\n    return object.userData.teleportTarget === true;\n}\nexport function buildTeleportTargetFilter(options = {}) {\n    return (interaction) => {\n        if (!isTeleportTarget(interaction.object)) {\n            return false;\n        }\n        if (options.customFilter != null && !options.customFilter(interaction)) {\n            return false;\n        }\n        return true;\n    };\n}\nexport function createTeleportRayLine() {\n    const curve = new QuadraticBezierCurve3(new Vector3(0, 0, 0), new Vector3(0, 0, -8), new Vector3(0, -20, -15));\n    return curve.getPoints(20);\n}\nexport class TeleportPointerRayModel extends Mesh {\n    multiplier;\n    lineLengths;\n    options = {};\n    constructor(points) {\n        const geometry = new MeshLineGeometry();\n        const float32Array = new Float32Array(points.length * 3);\n        for (let i = 0; i < points.length; i++) {\n            points[i].toArray(float32Array, i * 3);\n        }\n        geometry.setPoints(float32Array);\n        const multiplier = (points.length * 3 - 3) / (points.length * 3 - 1);\n        const material = new MeshLineMaterial({\n            lineWidth: 0.1,\n            resolution: undefined,\n            visibility: multiplier,\n        });\n        super(geometry, material);\n        this.material.transparent = true;\n        this.multiplier = multiplier;\n        this.material = material;\n        this.lineLengths = points.slice(0, -1).map((p, i) => p.distanceTo(points[i + 1]));\n    }\n    update(pointer) {\n        const enabled = pointer.getEnabled();\n        if (!enabled || pointer.getButtonsDown().size === 0) {\n            this.visible = false;\n            return;\n        }\n        this.visible = true;\n        const intersection = pointer.getIntersection();\n        if (intersection?.details.type != 'lines') {\n            this.material.visibility = this.multiplier;\n            return;\n        }\n        const { distanceOnLine, lineIndex } = intersection.details;\n        const lineLength = this.lineLengths[lineIndex];\n        this.material.visibility = (this.multiplier * (lineIndex + distanceOnLine / lineLength)) / this.lineLengths.length;\n        const { color = 'white', opacity = 0.4, size = 0.01 } = this.options;\n        this.material.lineWidth = size;\n        this.material.opacity = typeof opacity === 'function' ? opacity(pointer) : opacity;\n        const resolvedColor = typeof color === 'function' ? color(pointer) : color;\n        if (Array.isArray(resolvedColor)) {\n            this.material.color.set(...resolvedColor);\n        }\n        else {\n            this.material.color.set(resolvedColor);\n        }\n    }\n}\n", "import { Matrix4, Quaternion, Vector3 } from 'three';\nimport { getSpaceFromAncestors } from './internals.js';\nimport { toDOMPointInit } from './utils.js';\nconst matrixHelper = new Matrix4();\nconst vectorHelper = new Vector3();\nconst quaternionHelper = new Quaternion();\nexport async function createXRHitTestSource(store, relativeTo, trackableType = ['point', 'plane', 'mesh']) {\n    const state = store.getState();\n    if (typeof relativeTo === 'string') {\n        if (state.session == null) {\n            return undefined;\n        }\n        relativeTo = await state.session.requestReferenceSpace(relativeTo);\n    }\n    const entityTypes = Array.isArray(trackableType) ? trackableType : [trackableType];\n    //necassary data for request and compute hit test results\n    let options;\n    let baseSpace;\n    let object;\n    if (relativeTo instanceof XRSpace) {\n        //configure for request and compute hit test results\n        options = { space: relativeTo, entityTypes };\n        object = state.origin;\n    }\n    else {\n        //compute space\n        const space = getSpaceFromAncestors(relativeTo, state.origin, state.originReferenceSpace, matrixHelper);\n        if (space == null) {\n            return undefined;\n        }\n        //compute offset ray\n        vectorHelper.setFromMatrixPosition(matrixHelper);\n        const point = toDOMPointInit(vectorHelper);\n        quaternionHelper.setFromRotationMatrix(matrixHelper);\n        vectorHelper.set(0, 0, -1).applyQuaternion(quaternionHelper);\n        const offsetRay = new XRRay(point, toDOMPointInit(vectorHelper, 0));\n        //configure for request and compute hit test results\n        object = relativeTo;\n        options = { space, offsetRay, entityTypes };\n        baseSpace = space;\n    }\n    const source = await store.getState().session?.requestHitTestSource?.(options);\n    if (source == null) {\n        return undefined;\n    }\n    return {\n        source,\n        getWorldMatrix: computeWorldMatrixFromXRHitTestResult.bind(null, store, baseSpace, object),\n    };\n}\nexport async function requestXRHitTest(store, relativeTo, trackableType) {\n    const sourceData = await createXRHitTestSource(store, relativeTo, trackableType);\n    if (sourceData == null) {\n        return undefined;\n    }\n    const { source, getWorldMatrix } = sourceData;\n    const frame = await store.requestFrame();\n    const results = frame.getHitTestResults?.(source) ?? [];\n    source.cancel();\n    if (results == null) {\n        return undefined;\n    }\n    return { results, getWorldMatrix };\n}\nfunction computeWorldMatrixFromXRHitTestResult(store, baseSpace, object, target, result) {\n    baseSpace ??= store.getState().originReferenceSpace;\n    if (baseSpace == null) {\n        return false;\n    }\n    const pose = result.getPose(baseSpace);\n    if (pose == null) {\n        return false;\n    }\n    //target = ObjectMatrixWorld? * HitTestMatrix\n    target.fromArray(pose.transform.matrix);\n    if (object != null) {\n        target.premultiply(object.matrixWorld);\n    }\n    return true;\n}\n", "import { Matrix4, Quaternion, Vector3 } from 'three';\nimport { toDOMPointInit } from './utils.js';\nconst OneVector = new Vector3(1, 1, 1);\nconst ZeroVector = new Vector3(0, 0, 0);\nconst NeutralQuaternion = new Quaternion();\nconst matrixHelper1 = new Matrix4();\nconst matrixHelper2 = new Matrix4();\nconst quaternionHelper = new Quaternion();\nconst positionHelper = new Vector3();\nconst vectorHelper = new Vector3();\nexport async function requestXRAnchor(store, options) {\n    if (options.relativeTo === 'hit-test-result') {\n        return options.hitTestResult.createAnchor?.(new XRRigidTransform(toDOMPointInit(options.offsetPosition), toDOMPointInit(options.offsetQuaternion)));\n    }\n    let frame;\n    let space;\n    if (options.relativeTo === 'world') {\n        frame = options.frame ?? (await store.requestFrame());\n        const { origin, originReferenceSpace } = store.getState();\n        if (originReferenceSpace == null) {\n            return undefined;\n        }\n        space = originReferenceSpace;\n        const { worldPosition, worldQuaternion } = options;\n        if (origin != null) {\n            //compute vectorHelper and quaternionHelper in the local space of the origin\n            matrixHelper1.copy(origin.matrixWorld).invert();\n            matrixHelper2.compose(worldPosition, worldQuaternion, OneVector).multiply(matrixHelper1);\n            matrixHelper2.decompose(positionHelper, quaternionHelper, vectorHelper);\n            quaternionHelper.setFromRotationMatrix(matrixHelper2);\n        }\n        else {\n            positionHelper.copy(worldPosition);\n            quaternionHelper.copy(worldQuaternion);\n        }\n    }\n    else {\n        frame = options.frame ?? (await store.requestFrame());\n        space = options.space;\n        const { offsetPosition, offsetQuaternion } = options;\n        positionHelper.copy(offsetPosition ?? ZeroVector);\n        quaternionHelper.copy(offsetQuaternion ?? NeutralQuaternion);\n    }\n    return frame.createAnchor?.(new XRRigidTransform(toDOMPointInit(positionHelper), toDOMPointInit(quaternionHelper)), space);\n}\n", "import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nexport const DefaultGltfLoader = new GLTFLoader();\nexport const DefaultAssetBasePath = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/';\nexport { getXRControllerComponentObject, configureXRControllerModel, createUpdateXRControllerVisuals, loadXRControllerModel, } from './controller/index.js';\nexport { isXRInputSourceState, } from './input.js';\nexport * from './visible.js';\nexport * from './pointer/index.js';\nexport * from './vanilla/index.js';\nexport * from './misc.js';\nexport * from './teleport.js';\nexport * from './hit-test.js';\nexport * from './anchor.js';\nexport * from './layer.js';\n", "export function syncAsync(fn, ...fns) {\n    let value = fn();\n    for (const fnEntry of fns) {\n        if (value instanceof Promise) {\n            value = value.then(fnEntry);\n        }\n        else {\n            value = fnEntry(value);\n        }\n    }\n    return value;\n}\n", "import { DefaultAssetBasePath } from '../index.js';\nimport { syncAsync } from './utils.js';\nconst DefaultDefaultControllerProfileId = 'generic-trigger';\nexport class XRControllerLayoutLoader {\n    baseAssetPath;\n    defaultProfileId;\n    //cache\n    profilesListCache;\n    profileCacheMap = new Map();\n    constructor(options) {\n        this.baseAssetPath = options?.baseAssetPath ?? DefaultAssetBasePath;\n        this.defaultProfileId = options?.defaultControllerProfileId ?? DefaultDefaultControllerProfileId;\n    }\n    load(inputSourceProfileIds, handedness) {\n        return syncAsync(\n        //load profile\n        () => this.loadProfile(inputSourceProfileIds), \n        //get controller layout from profile\n        (profile) => {\n            for (const key in profile.layouts) {\n                if (!key.includes(handedness)) {\n                    continue;\n                }\n                return profile.layouts[key];\n            }\n            throw new Error(`No matching layout for \"${handedness}\", in profile ${profile.profileId} with layouts ${Object.keys(profile.layouts).join(', ')}.`);\n        });\n    }\n    //alias for Loader compatibility\n    loadAsync = this.load;\n    loadProfile(inputSourceProfileIds) {\n        return syncAsync(\n        //load profiles list\n        () => this.profilesListCache ??\n            fetchJson(new URL('profilesList.json', this.baseAssetPath).href).then((profilesList) => (this.profilesListCache = profilesList)), \n        //load profile\n        (profilesList) => {\n            const length = inputSourceProfileIds.length;\n            let profileInfo;\n            for (let i = 0; i < length; i++) {\n                profileInfo = profilesList[inputSourceProfileIds[i]];\n                if (profileInfo != null) {\n                    break;\n                }\n            }\n            profileInfo ??= profilesList[this.defaultProfileId];\n            if (profileInfo == null) {\n                throw new Error(`no matching profile found for profiles \"${inputSourceProfileIds.join(', ')}\" in profile list ${JSON.stringify(profilesList)}`);\n            }\n            return this.loadProfileFromPath(profileInfo.path);\n        });\n    }\n    loadProfileFromPath(relativeProfilePath) {\n        const result = this.profileCacheMap.get(relativeProfilePath);\n        if (result != null) {\n            return result;\n        }\n        const absoluteProfilePath = new URL(relativeProfilePath, this.baseAssetPath).href;\n        return fetchJson(absoluteProfilePath).then((profile) => {\n            //overwrite the relative assetPath into an absolute path\n            for (const key in profile.layouts) {\n                const layout = profile.layouts[key];\n                if (layout == null) {\n                    continue;\n                }\n                layout.assetPath = new URL(layout.assetPath, absoluteProfilePath).href;\n            }\n            this.profileCacheMap.set(relativeProfilePath, profile);\n            return profile;\n        });\n    }\n}\nasync function fetchJson(url) {\n    let response = await fetch(url);\n    if (!response.ok) {\n        return Promise.reject(new Error(response.statusText));\n    }\n    return response.json();\n}\n", "import { updateXRControllerGamepadState } from './gamepad.js';\nimport { syncAsync } from './utils.js';\nexport function createXRControllerState(id, inputSource, layoutLoader, events, isPrimary) {\n    return syncAsync(() => layoutLoader.load(inputSource.profiles, inputSource.handedness), (layout) => {\n        const gamepad = {};\n        updateXRControllerGamepadState(gamepad, inputSource, layout);\n        return {\n            id,\n            isPrimary,\n            events,\n            type: 'controller',\n            inputSource,\n            gamepad,\n            layout,\n        };\n    });\n}\nexport function updateXRControllerState({ gamepad, inputSource, layout }) {\n    updateXRControllerGamepadState(gamepad, inputSource, layout);\n}\n", "import { createContext } from 'react';\nexport const xrContext = createContext(undefined);\nexport const xrInputSourceStateContext = createContext(undefined);\nexport const xrSpaceContext = createContext(undefined);\nexport const combinedPointerContext = createContext(undefined);\n", "import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { createXRStore as createXRStoreImpl, } from '@pmndrs/xr/internals';\nimport { useFrame, useThree, useStore as useRootStore } from '@react-three/fiber';\nimport { useContext, useEffect, useMemo } from 'react';\nimport { useStore } from 'zustand';\nimport { combinedPointerContext, xrContext } from './contexts.js';\nimport { XRElements } from './elements.js';\nimport { setupSyncIsVisible } from '@pmndrs/xr';\nimport { CombinedPointer } from '@pmndrs/pointer-events';\n/**\n * starting point for each XR application\n * allows to configure the session's features and defaults such as what controllers are rendered and how they can interact with the scene\n * @returns an xr store\n */\nexport function createXRStore(options) {\n    return createXRStoreImpl(options);\n}\n/**\n * core XR component for connectin the xr store with the scene\n * requires the xr store which it will provide to its children\n */\nexport function XR({ children, store }) {\n    store.setWebXRManager(useThree((s) => s.gl.xr));\n    const rootStore = useRootStore();\n    useEffect(() => {\n        let initialCamera;\n        return store.subscribe((state, prevState) => {\n            if (state.session === prevState.session) {\n                return;\n            }\n            //session has changed\n            if (state.session != null) {\n                const { camera, gl } = rootStore.getState();\n                initialCamera = camera;\n                rootStore.setState({ camera: gl.xr.getCamera() });\n                return;\n            }\n            if (initialCamera == null) {\n                //we always were in xr?\n                return;\n            }\n            rootStore.setState({ camera: initialCamera });\n        });\n    }, [rootStore, store]);\n    useFrame((state, _delta, frame) => store.onBeforeFrame(state.scene, state.camera, frame), -1000);\n    useFrame(() => store.onBeforeRender());\n    return (_jsx(xrContext.Provider, { value: store, children: _jsxs(RootCombinedPointer, { children: [_jsx(XRElements, {}), children] }) }));\n}\nexport function RootCombinedPointer({ children }) {\n    const store = useXRStore();\n    const pointer = useMemo(() => new CombinedPointer(true), []);\n    useEffect(() => setupSyncIsVisible(store, (visible) => pointer.setEnabled(visible, { timeStamp: performance.now() })), [store, pointer]);\n    useFrame((state) => pointer.move(state.scene, { timeStamp: performance.now() }), -50);\n    return _jsx(combinedPointerContext.Provider, { value: pointer, children: children });\n}\n/**\n * hook for getting the xr store from the context\n */\nexport function useXRStore() {\n    const store = useContext(xrContext);\n    if (store == null) {\n        throw new Error(`XR features can only be used inside the <XR> component`);\n    }\n    return store;\n}\n/**\n * hook for reading the state from the xr store\n */\nexport function useXR(selector = (state) => state, equalityFn) {\n    return useStore(useXRStore(), selector, equalityFn);\n}\n", "import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { context, reconciler, useStore } from '@react-three/fiber';\nimport { Suspense, useMemo } from 'react';\nimport { xrInputSourceStateContext, xrSpaceContext } from './contexts.js';\nimport { useXR } from './xr.js';\nimport { objectToKey } from './utils.js';\nimport { XRSpace } from './space.js';\nimport { resolveInputSourceImplementation } from '@pmndrs/xr/internals';\nimport { useXRSessionVisibilityState } from './hooks.js';\nimport { DefaultXRController, DefaultXRGaze, DefaultXRHand, DefaultXRScreenInput, DefaultXRTransientPointer, } from './default.js';\nimport { shallow } from 'zustand/shallow';\nexport function XRElements({ children }) {\n    const referenceSpace = useXR((xr) => xr.originReferenceSpace);\n    const origin = useXR((xr) => xr.origin);\n    const visible = useXRSessionVisibilityState() === 'visible';\n    const store = useStore();\n    const storeWithOriginAsScene = useMemo(() => Object.assign({}, store, {\n        getState() {\n            return { ...store.getState(), scene: origin };\n        },\n    }), [origin, store]);\n    if (origin == null || referenceSpace == null) {\n        return null;\n    }\n    return (_jsx(_Fragment, { children: reconciler.createPortal(_jsx(context.Provider, { value: store, children: _jsxs(xrSpaceContext.Provider, { value: referenceSpace, children: [_jsxs(\"group\", { matrixAutoUpdate: false, visible: visible, children: [_jsx(XRControllers, {}), _jsx(XRHands, {}), _jsx(XRTransientPointers, {}), _jsx(XRGazes, {}), _jsx(XRScreenInputs, {})] }), children] }) }), storeWithOriginAsScene, null) }));\n}\nfunction XRControllers() {\n    const controllerStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === 'controller'), shallow);\n    let Implementation = useXR((xr) => xr.controller);\n    if (Implementation === false) {\n        return null;\n    }\n    return (_jsx(_Fragment, { children: controllerStates.map((state) => {\n            const ResolvedImpl = resolveInputSourceImplementation(Implementation, state.inputSource.handedness, {});\n            if (ResolvedImpl === false) {\n                return null;\n            }\n            return (_jsx(XRSpace, { space: state.inputSource.gripSpace, children: _jsx(xrInputSourceStateContext.Provider, { value: state, children: _jsx(Suspense, { children: typeof ResolvedImpl === 'function' ? _jsx(ResolvedImpl, {}) : _jsx(DefaultXRController, { ...ResolvedImpl }) }) }) }, state.id));\n        }) }));\n}\nfunction XRHands() {\n    const handStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === 'hand'), shallow);\n    const Implementation = useXR((xr) => xr.hand);\n    if (Implementation === false) {\n        return null;\n    }\n    return (_jsx(_Fragment, { children: handStates.map((state) => {\n            const ResolvedImpl = resolveInputSourceImplementation(Implementation, state.inputSource.handedness, {});\n            if (ResolvedImpl === false) {\n                return null;\n            }\n            return (_jsx(XRSpace, { space: state.inputSource.hand.get('wrist'), children: _jsx(xrInputSourceStateContext.Provider, { value: state, children: _jsx(Suspense, { children: typeof ResolvedImpl === 'function' ? _jsx(ResolvedImpl, {}) : _jsx(DefaultXRHand, { ...ResolvedImpl }) }) }) }, objectToKey(state)));\n        }) }));\n}\nfunction XRTransientPointers() {\n    const transientPointerStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === 'transientPointer'), shallow);\n    const Implementation = useXR((xr) => xr.transientPointer);\n    if (Implementation === false) {\n        return null;\n    }\n    return (_jsx(_Fragment, { children: transientPointerStates.map((state) => {\n            const ResolvedImpl = resolveInputSourceImplementation(Implementation, state.inputSource.handedness, {});\n            if (ResolvedImpl === false) {\n                return null;\n            }\n            return (_jsx(XRSpace, { space: state.inputSource.targetRaySpace, children: _jsx(xrInputSourceStateContext.Provider, { value: state, children: _jsx(Suspense, { children: typeof ResolvedImpl === 'function' ? (_jsx(ResolvedImpl, {})) : (_jsx(DefaultXRTransientPointer, { ...ResolvedImpl })) }) }) }, objectToKey(state)));\n        }) }));\n}\nfunction XRGazes() {\n    const gazeStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === 'gaze'), shallow);\n    const Implementation = useXR((xr) => xr.gaze);\n    if (Implementation === false) {\n        return null;\n    }\n    return (_jsx(_Fragment, { children: gazeStates.map((state) => {\n            return (_jsx(XRSpace, { space: state.inputSource.targetRaySpace, children: _jsx(xrInputSourceStateContext.Provider, { value: state, children: _jsx(Suspense, { children: typeof Implementation === 'function' ? (_jsx(Implementation, {})) : (_jsx(DefaultXRGaze, { ...spreadable(Implementation) })) }) }) }, objectToKey(state)));\n        }) }));\n}\nfunction XRScreenInputs() {\n    const screenInputStates = useXR((xr) => xr.inputSourceStates.filter((state) => state.type === 'screenInput'), shallow);\n    const Implementation = useXR((xr) => xr.screenInput);\n    if (Implementation === false) {\n        return null;\n    }\n    return (_jsx(_Fragment, { children: screenInputStates.map((state) => {\n            return (_jsx(XRSpace, { space: state.inputSource.targetRaySpace, children: _jsx(xrInputSourceStateContext.Provider, { value: state, children: _jsx(Suspense, { children: typeof Implementation === 'function' ? (_jsx(Implementation, {})) : (_jsx(DefaultXRScreenInput, { ...spreadable(Implementation) })) }) }) }, objectToKey(state)));\n        }) }));\n}\nfunction spreadable(value) {\n    if (value === true) {\n        return undefined;\n    }\n    return value;\n}\n", "let i = 0;\nconst map = new Map();\nexport function objectToKey(object) {\n    let key = map.get(object);\n    if (key == null) {\n        map.set(object, (key = i++));\n    }\n    return key;\n}\n", "import { useEffect, useMemo, useRef, useState, useSyncExternalStore } from 'react';\nimport { useXR } from './xr.js';\nexport function useHover(ref, onChange) {\n    let setHover;\n    let hover;\n    if (onChange == null) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const [_hover, _setHover] = useState(false);\n        setHover = _setHover;\n        hover = _hover;\n    }\n    else {\n        setHover = onChange;\n    }\n    useEffect(() => {\n        const { current } = ref;\n        if (current == null) {\n            return;\n        }\n        const set = new Set();\n        const enter = (e) => {\n            if (set.size === 0) {\n                setHover(true);\n            }\n            set.add(e.pointerId);\n        };\n        const leave = (e) => {\n            set.delete(e.pointerId);\n            if (set.size === 0) {\n                setHover(false);\n            }\n        };\n        current.addEventListener('pointerenter', enter);\n        current.addEventListener('pointerleave', leave);\n        return () => {\n            current.removeEventListener('pointerenter', enter);\n            current.removeEventListener('pointerleave', leave);\n        };\n    }, [ref, setHover]);\n    return hover;\n}\n/**\n * hook for getting the session visibility state\n */\nexport function useXRSessionVisibilityState() {\n    return useXR((xr) => xr.visibilityState);\n}\n/**\n * hook for getting the function to initialize the room capture for scanning the room\n */\nexport function useInitRoomCapture() {\n    return useXR((xr) => xr.session?.initiateRoomCapture?.bind(xr.session));\n}\n/**\n * hook for checking if a session mode is supported\n * @param onError callback executed when an error happens while checking if the session mode is supported\n */\nexport function useSessionModeSupported(mode, onError) {\n    const onErrorRef = useRef(onError);\n    onErrorRef.current = onError;\n    const [subscribe, getSnapshot] = useMemo(() => {\n        let sessionSupported = undefined;\n        return [\n            (onChange) => {\n                let canceled = false;\n                if (navigator.xr == null) {\n                    sessionSupported = false;\n                    return () => { };\n                }\n                navigator.xr\n                    .isSessionSupported(mode)\n                    .then((isSupported) => {\n                    sessionSupported = isSupported;\n                    if (canceled) {\n                        return;\n                    }\n                    onChange();\n                })\n                    .catch((e) => {\n                    if (canceled) {\n                        return;\n                    }\n                    onErrorRef.current?.(e);\n                });\n                return () => (canceled = true);\n            },\n            () => sessionSupported,\n        ];\n    }, [mode]);\n    return useSyncExternalStore(subscribe, getSnapshot);\n}\nexport function useSessionFeatureEnabled(feature) {\n    return useXR(({ session }) => session?.enabledFeatures?.includes(feature) ?? false);\n}\n", "import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { defaultGrabPointerOpacity, defaultRayPointerOpacity, defaultTouchPointerOpacity, createTeleportRayLine, syncTeleportPointerRayGroup, buildTeleportTargetFilter, } from '@pmndrs/xr/internals';\nimport { useRef, Suspense, useContext, useMemo } from 'react';\nimport { XRControllerModel } from './controller.js';\nimport { XRHandModel } from './hand.js';\nimport { CombinedPointer, PointerCursorModel, PointerRayModel, useGrabPointer, useLinesPointer, usePointerXRInputSourceEvents, useRayPointer, useTouchPointer, } from './pointer.js';\nimport { XRSpace as XRSpaceImpl } from './space.js';\nimport { xrInputSourceStateContext } from './contexts.js';\nimport { TeleportPointerRayModel } from './teleport.js';\nimport { createPortal, useFrame, useThree } from '@react-three/fiber';\nimport { useXRInputSourceStateContext } from './input.js';\nexport { defaultGrabPointerOpacity, defaultRayPointerOpacity, defaultTouchPointerOpacity, } from '@pmndrs/xr/internals';\nfunction DefaultXRInputSourceGrabPointer(event, getSpace, options) {\n    const state = useContext(xrInputSourceStateContext);\n    if (state == null) {\n        throw new Error(`DefaultXRInputSourceGrabPointer can only be used inside a XRInputSource`);\n    }\n    const ref = useRef(null);\n    const pointer = useGrabPointer(ref, state, options);\n    usePointerXRInputSourceEvents(pointer, state.inputSource, event, state.events);\n    const cursorModelOptions = options.cursorModel;\n    return (_jsx(XRSpaceImpl, { ref: ref, space: getSpace(state.inputSource), children: cursorModelOptions !== false && (_jsx(PointerCursorModel, { pointer: pointer, opacity: defaultGrabPointerOpacity, ...spreadable(cursorModelOptions) })) }));\n}\n/**\n * grab pointer for the XRHand\n *\n * properties\n * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event\n * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event\n * - `contextMenuButton` the button that triggers contextmenu events\n * - `makeDefault` used the set the default pointer inside a combined pointer\n * - `cursorModel` properties for configuring how the cursor should look\n * - `radius` the size of the intersection sphere\n */\nexport const DefaultXRHandGrabPointer = DefaultXRInputSourceGrabPointer.bind(null, 'select', (inputSource) => inputSource.hand.get('index-finger-tip'));\n/**\n * grab pointer for the XRController\n *\n * properties\n * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event\n * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event\n * - `contextMenuButton` the button that triggers contextmenu events\n * - `makeDefault` used the set the default pointer inside a combined pointer\n * - `cursorModel` properties for configuring how the cursor should look\n * - `radius` the size of the intersection sphere\n */\nexport const DefaultXRControllerGrabPointer = DefaultXRInputSourceGrabPointer.bind(null, 'squeeze', (inputSource) => inputSource.gripSpace);\n/**\n * ray pointer for the XRInputSource\n *\n * properties\n * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event\n * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event\n * - `contextMenuButton` the button that triggers contextmenu events\n * - `makeDefault` used the set the default pointer inside a combined pointer\n * - `radius` the size of the intersection sphere\n * - `minDistance` minimal distance to trigger interactions\n * - `linePoints` the points thay make up the shape of the ray if undefined the ray goes in a straight line\n * - `direction` the direction of the ray\n * - `rayModel` properties for configuring how the ray should look\n * - `cursorModel` properties for configuring how the cursor should look\n */\nexport function DefaultXRInputSourceRayPointer(options) {\n    const state = useXRInputSourceStateContext();\n    const ref = useRef(null);\n    const pointer = useRayPointer(ref, state, options);\n    usePointerXRInputSourceEvents(pointer, state.inputSource, 'select', state.events);\n    const rayModelOptions = options.rayModel;\n    const cursorModelOptions = options.cursorModel;\n    return (_jsxs(XRSpaceImpl, { ref: ref, space: state.inputSource.targetRaySpace, children: [rayModelOptions !== false && (_jsx(PointerRayModel, { pointer: pointer, opacity: defaultRayPointerOpacity, ...spreadable(rayModelOptions) })), cursorModelOptions !== false && (_jsx(PointerCursorModel, { pointer: pointer, opacity: defaultRayPointerOpacity, ...spreadable(cursorModelOptions) }))] }));\n}\n/**\n * touch pointer for the XRHand\n *\n * properties\n * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event\n * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event\n * - `contextMenuButton` the button that triggers contextmenu events\n * - `makeDefault` used the set the default pointer inside a combined pointer\n * - `cursorModel` properties for configuring how the cursor should look\n * - `hoverRadius` the size of the intersection sphere\n * - `downRadius` the distance to the touch center to trigger a pointerdown event\n * - `button` the id of the button that is triggered when touching\n */\nexport function DefaultXRHandTouchPointer(options) {\n    const state = useXRInputSourceStateContext('hand');\n    const ref = useRef(null);\n    const pointer = useTouchPointer(ref, state, options);\n    const cursorModelOptions = options.cursorModel;\n    return (_jsx(XRSpaceImpl, { ref: ref, space: state.inputSource.hand.get('index-finger-tip'), children: cursorModelOptions !== false && (_jsx(PointerCursorModel, { pointer: pointer, opacity: defaultTouchPointerOpacity, ...spreadable(cursorModelOptions) })) }));\n}\n/**\n * default controller implementation with grab and ray pointers\n *\n * properties\n * - `model` options for configuring the controller apperance\n * - `grabPointer` options for configuring the grab pointer\n * - `rayPointer` options for configuring the ray pointer\n */\nexport function DefaultXRController(options) {\n    const modelOptions = options.model;\n    const grabPointerOptions = options.grabPointer;\n    const rayPointerOptions = options.rayPointer;\n    const teleportPointerOptions = options.teleportPointer ?? false;\n    return (_jsxs(_Fragment, { children: [modelOptions !== false && (_jsx(Suspense, { children: _jsx(XRControllerModel, { ...spreadable(modelOptions) }) })), _jsxs(CombinedPointer, { children: [grabPointerOptions !== false && _jsx(DefaultXRControllerGrabPointer, { ...spreadable(grabPointerOptions) }), rayPointerOptions !== false && (_jsx(DefaultXRInputSourceRayPointer, { makeDefault: true, minDistance: 0.2, ...spreadable(rayPointerOptions) })), teleportPointerOptions !== false && (_jsx(DefaultXRInputSourceTeleportPointer, { ...spreadable(teleportPointerOptions) }))] })] }));\n}\n/**\n * default hand implementation with touch, grab and ray pointers\n *\n * properties\n * - `model` options for configuring the hand appearance\n * - `grabPointer` options for configuring the grab pointer\n * - `rayPointer` options for configuring the ray pointer\n * - `touchPointer` options for configuring the touch pointer\n */\nexport function DefaultXRHand(options) {\n    const modelOptions = options.model;\n    const grabPointerOptions = options.grabPointer;\n    const rayPointerOptions = options.rayPointer;\n    const touchPointerOptions = options.touchPointer;\n    const teleportPointerOptions = options.teleportPointer ?? false;\n    const rayPointerRayModelOptions = rayPointerOptions === false ? false : spreadable(rayPointerOptions)?.rayModel;\n    return (_jsxs(_Fragment, { children: [modelOptions !== false && (_jsx(Suspense, { children: _jsx(XRHandModel, { ...spreadable(modelOptions) }) })), _jsxs(CombinedPointer, { children: [grabPointerOptions !== false && _jsx(DefaultXRHandGrabPointer, { ...spreadable(grabPointerOptions) }), touchPointerOptions !== false && _jsx(DefaultXRHandTouchPointer, { ...spreadable(touchPointerOptions) }), rayPointerOptions !== false && (_jsx(DefaultXRInputSourceRayPointer, { makeDefault: true, minDistance: 0.2, ...spreadable(rayPointerOptions), rayModel: rayPointerRayModelOptions === false ? false : { maxLength: 0.2, ...spreadable(rayPointerRayModelOptions) } })), teleportPointerOptions !== false && (_jsx(DefaultXRInputSourceTeleportPointer, { ...spreadable(teleportPointerOptions) }))] })] }));\n}\n/**\n * default transient-pointer implementation with ray pointer\n *\n * properties\n * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event\n * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event\n * - `contextMenuButton` the button that triggers contextmenu events\n * - `minDistance` minimal distance to trigger interactions\n * - `linePoints` the points thay make up the shape of the ray if undefined the ray goes in a straight line\n * - `direction` the direction of the ray\n * - `cursorModel` properties for configuring how the cursor should look\n */\nexport function DefaultXRTransientPointer(options) {\n    return _jsx(DefaultXRInputSourceRayPointer, { ...options, rayModel: false });\n}\n/**\n * default gaze implementation with ray pointer\n *\n * properties\n * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event\n * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event\n * - `contextMenuButton` the button that triggers contextmenu events\n * - `minDistance` minimal distance to trigger interactions\n * - `linePoints` the points thay make up the shape of the ray if undefined the ray goes in a straight line\n * - `direction` the direction of the ray\n * - `cursorModel` properties for configuring how the cursor should look\n */\nexport function DefaultXRGaze(options) {\n    return _jsx(DefaultXRInputSourceRayPointer, { ...options, rayModel: false });\n}\n/**\n * default screen-input implementation with ray pointer\n *\n * properties\n * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event\n * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event\n * - `contextMenuButton` the button that triggers contextmenu events\n * - `minDistance` minimal distance to trigger interactions\n * - `linePoints` the points thay make up the shape of the ray if undefined the ray goes in a straight line\n * - `direction` the direction of the ray\n */\nexport function DefaultXRScreenInput(options) {\n    return _jsx(DefaultXRInputSourceRayPointer, { ...options, cursorModel: false, rayModel: false });\n}\n/**\n * telport pointer for the XRInputSource\n * emits a downwards bend ray that only interesects with meshes marked as teleportable\n *\n * properties\n * - `clickThesholdMs` time in milliseconds between pointerdown and pointerup to trigger a click event\n * - `dblClickThresholdMs` time in milliseconds between the first click and the second click to trigger a dblclick event\n * - `contextMenuButton` the button that triggers contextmenu events\n * - `makeDefault` used the set the default pointer inside a combined pointer\n * - `radius` the size of the intersection sphere\n * - `minDistance` minimal distance to trigger interactions\n * - `direction` the direction of the ray\n * - `rayModel` properties for configuring how the ray should look\n * - `cursorModel` properties for configuring how the cursor should look\n */\nexport function DefaultXRInputSourceTeleportPointer(options) {\n    const state = useContext(xrInputSourceStateContext);\n    if (state == null) {\n        throw new Error(`DefaultXRInputSourceRayPointer can only be used inside a XRInputSource`);\n    }\n    const ref = useRef(null);\n    const groupRef = useRef(null);\n    const linePoints = useMemo(() => createTeleportRayLine(), []);\n    const pointer = useLinesPointer(groupRef, state, {\n        ...options,\n        linePoints,\n        customFilter: buildTeleportTargetFilter(options),\n    }, 'teleport');\n    usePointerXRInputSourceEvents(pointer, state.inputSource, 'select', state.events);\n    const rayModelOptions = options.rayModel;\n    const cursorModelOptions = options.cursorModel;\n    const scene = useThree((state) => state.scene);\n    const cursorRef = useRef(null);\n    useFrame((_, delta) => {\n        if (cursorRef.current != null) {\n            cursorRef.current.visible = pointer.getEnabled() && pointer.getButtonsDown().size > 0;\n        }\n        const target = groupRef.current;\n        const source = ref.current;\n        if (target == null || source == null) {\n            return;\n        }\n        syncTeleportPointerRayGroup(source, target, delta * 1000);\n    });\n    return (_jsxs(_Fragment, { children: [_jsx(XRSpaceImpl, { ref: ref, space: state.inputSource.targetRaySpace }), createPortal(_jsxs(\"group\", { ref: groupRef, children: [rayModelOptions !== false && (_jsx(TeleportPointerRayModel, { linePoints: linePoints, pointer: pointer, opacity: defaultRayPointerOpacity, ...spreadable(rayModelOptions) })), cursorModelOptions !== false && (_jsx(PointerCursorModel, { ref: cursorRef, pointer: pointer, opacity: defaultRayPointerOpacity, ...spreadable(cursorModelOptions) }))] }), scene)] }));\n}\nfunction spreadable(value) {\n    if (value === true) {\n        return undefined;\n    }\n    return value;\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useImperativeHandle, useMemo, useRef, useState } from 'react';\nimport { suspend } from 'suspend-react';\nimport { configureXRControllerModel, createUpdateXRControllerVisuals, loadXRControllerModel, XRControllerLayoutLoader, } from '@pmndrs/xr/internals';\nimport { createPortal, useFrame } from '@react-three/fiber';\nimport { useXRInputSourceStateContext } from './input.js';\n/**\n * component for placing content in the controller anchored at a specific component such as the Thumbstick\n *\n * properties\n * - `id` is the id of the component (e.g. `\"a-button\"`)\n * - `onPress` is an optional callback to receive when the component is pressed\n * - `onRelease` is an optional callback to receive when the component is released\n *\n * the component allows children to be placed inside for e.g. visualizing a tooltip over the button/...\n */\nexport const XRControllerComponent = forwardRef(({ id, children, onPress, onRelease }, ref) => {\n    const state = useXRInputSourceStateContext('controller');\n    const [object, setObject] = useState(undefined);\n    useImperativeHandle(ref, () => object, [object]);\n    useXRControllerButtonEvent(state, id, (state) => (state === 'pressed' ? onPress?.() : onRelease?.()));\n    useFrame(() => setObject(state.gamepad[id]?.object));\n    if (object == null) {\n        return;\n    }\n    return createPortal(children, object);\n});\n/**\n * hook for subscribing to a button state change event on the controller\n * @param id of the button\n * @param onChange callback that gets executed when the state of the button changes\n * @param handedness of the controller\n */\nexport function useXRControllerButtonEvent(controller, id, onChange) {\n    const state = useRef();\n    useFrame(() => {\n        const currentState = controller?.gamepad[id]?.state;\n        if (currentState != null && currentState != state.current) {\n            onChange(currentState);\n        }\n        state.current = currentState;\n    });\n}\nconst LoadXRControllerModelSymbol = Symbol('loadXRControllerModel');\n/**\n * component for rendering a 3D model for the XRController\n *\n * properties\n * - `colorWrite`\n * - `renderOrder`\n */\nexport const XRControllerModel = forwardRef((options, ref) => {\n    const state = useXRInputSourceStateContext('controller');\n    const model = suspend(loadXRControllerModel, [state.layout, undefined, LoadXRControllerModelSymbol]);\n    configureXRControllerModel(model, options);\n    state.object = model;\n    useImperativeHandle(ref, () => model, [model]);\n    const update = useMemo(() => createUpdateXRControllerVisuals(model, state.layout, state.gamepad), [model, state.layout, state.gamepad]);\n    useFrame(update);\n    return _jsx(\"primitive\", { object: model });\n});\nconst LoadXRControllerLayoutSymbol = Symbol('loadXRControllerLayout');\nexport function useLoadXRControllerLayout(profileIds, handedness, { baseAssetPath, defaultControllerProfileId } = {}) {\n    const loader = useMemo(() => new XRControllerLayoutLoader({ baseAssetPath, defaultControllerProfileId }), [baseAssetPath, defaultControllerProfileId]);\n    return suspend(() => {\n        const result = loader.loadAsync(profileIds, handedness);\n        return result instanceof Promise ? result : Promise.resolve(result);\n    }, [LoadXRControllerLayoutSymbol, handedness, ...profileIds]);\n}\nexport function useLoadXRControllerModel(layout) {\n    return suspend(loadXRControllerModel, [layout, undefined, LoadXRControllerModelSymbol]);\n}\n", "import { bindXRInputSourceEvent, } from '@pmndrs/xr/internals';\nimport { useXR } from './xr.js';\nimport { xrInputSourceStateContext } from './contexts.js';\nimport { useContext, useEffect } from 'react';\nexport function useXRInputSourceStates() {\n    return useXR((xr) => xr.inputSourceStates);\n}\nexport function useXRInputSourceState(type, handedness) {\n    return useXR((s) => s.inputSourceStates.find((state) => state.type === type && (handedness == null || state.inputSource.handedness === handedness)));\n}\nexport function useXRInputSourceStateContext(type) {\n    const state = useContext(xrInputSourceStateContext);\n    if (state == null || (type != null && state.type != type)) {\n        throw new Error(`useXRInputSourceStateContext() can only be used inside a the xr store config`);\n    }\n    return state;\n}\n/**\n * hook for listening to xr input source events\n */\nexport function useXRInputSourceEvent(inputSource, event, fn, deps) {\n    const session = useXR((xr) => xr.session);\n    useEffect(() => {\n        if (session == null || inputSource == null) {\n            return;\n        }\n        return bindXRInputSourceEvent(session, inputSource, event, fn);\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [event, inputSource, session, ...deps]);\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { cloneXRHandGltf, configureXRHandModel, createUpdateXRHandVisuals, } from '@pmndrs/xr/internals';\nimport { forwardRef, useImperativeHandle, useMemo } from 'react';\nimport { XRSpace, useXRSpace } from './space.js';\nimport { useFrame, useLoader } from '@react-three/fiber';\nimport { useXRInputSourceStateContext } from './input.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\n/**\n * component for rendering a 3D model for the XRHand\n *\n * properties\n * - `colorWrite`\n * - `renderOrder`\n */\nexport const XRHandModel = forwardRef((options, ref) => {\n    const state = useXRInputSourceStateContext('hand');\n    const gltf = useLoader(GLTFLoader, state.assetPath);\n    const model = useMemo(() => cloneXRHandGltf(gltf), [gltf]);\n    configureXRHandModel(model, options);\n    useImperativeHandle(ref, () => model, [model]);\n    const referenceSpace = useXRSpace();\n    const update = useMemo(() => createUpdateXRHandVisuals(state.inputSource.hand, model, referenceSpace), [state.inputSource, model, referenceSpace]);\n    useFrame((_state, _delta, frame) => update(frame));\n    return _jsx(\"primitive\", { object: model });\n});\n/**\n * component for placing content in the hand anchored at a specific joint such as the index finger tip\n *\n * properties\n * - `joint` is the name of the joint (e.g. `\"wrist\"`)\n *\n * the component allows children to be placed inside for e.g. visualizing a tooltip over the index finger tip\n */\nexport const XRHandJoint = forwardRef(({ joint, children }, ref) => {\n    const state = useXRInputSourceStateContext('hand');\n    return (_jsx(XRSpace, { ref: ref, space: state.inputSource.hand.get(joint), children: children }));\n});\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useContext, useEffect, useImperativeHandle, useMemo, useRef } from 'react';\nimport { CombinedPointer as CombinedPointerImpl, Pointer, createGrabPointer, createLinesPointer, createRayPointer, createTouchPointer, } from '@pmndrs/pointer-events';\nimport { createPortal, useFrame, useThree } from '@react-three/fiber';\nimport { PointerCursorMaterial, PointerRayMaterial, bindPointerXRInputSourceEvent, updatePointerCursorModel, updatePointerRayModel, } from '@pmndrs/xr/internals';\nimport { useXR } from './xr.js';\nimport { combinedPointerContext } from './contexts.js';\n//for checking if `event.pointerState` is from an xr input source\nexport { isXRInputSourceState } from '@pmndrs/xr/internals';\n/**\n * component for combining multiple pointer into one so that only one pointer is active at each time\n */\nexport function CombinedPointer({ children }) {\n    const pointer = useMemo(() => new CombinedPointerImpl(false), []);\n    useSetupPointer(pointer);\n    return _jsx(combinedPointerContext.Provider, { value: pointer, children: children });\n}\nfunction clearObject(object) {\n    for (const key of Object.keys(object)) {\n        delete object[key];\n    }\n}\n/**\n * hook for creating a grab pointer\n */\nexport function useGrabPointer(spaceRef, pointerState, currentOptions, pointerType) {\n    const options = useMemo(() => ({}), []);\n    clearObject(options);\n    Object.assign(options, currentOptions);\n    const pointer = useMemo(() => createGrabPointer(spaceRef, pointerState, options, pointerType), [spaceRef, pointerState, options, pointerType]);\n    useSetupPointer(pointer, currentOptions?.makeDefault);\n    return pointer;\n}\n/**\n * hook for creating a ray pointer\n */\nexport function useRayPointer(spaceRef, pointerState, currentOptions, pointerType) {\n    const options = useMemo(() => ({}), []);\n    clearObject(options);\n    Object.assign(options, currentOptions);\n    const pointer = useMemo(() => createRayPointer(spaceRef, pointerState, options, pointerType), [spaceRef, pointerState, options, pointerType]);\n    useSetupPointer(pointer, currentOptions?.makeDefault);\n    return pointer;\n}\n/**\n * hook for creating a ray pointer\n */\nexport function useLinesPointer(spaceRef, pointerState, currentOptions, pointerType) {\n    const options = useMemo(() => ({}), []);\n    clearObject(options);\n    Object.assign(options, currentOptions);\n    const pointer = useMemo(() => createLinesPointer(spaceRef, pointerState, options, pointerType), [spaceRef, pointerState, options, pointerType]);\n    useSetupPointer(pointer, currentOptions?.makeDefault);\n    return pointer;\n}\n/**\n * hook for creating a touch pointer\n */\nexport function useTouchPointer(spaceRef, pointerState, currentOptions, pointerType) {\n    const options = useMemo(() => ({}), []);\n    clearObject(options);\n    Object.assign(options, currentOptions);\n    const pointer = useMemo(() => createTouchPointer(spaceRef, pointerState, options, pointerType), [spaceRef, pointerState, options, pointerType]);\n    useSetupPointer(pointer, currentOptions?.makeDefault);\n    return pointer;\n}\n/**\n * component for rendering a ray for a pointer\n */\nexport const PointerRayModel = forwardRef((props, ref) => {\n    const material = useMemo(() => new PointerRayMaterial(), []);\n    const internalRef = useRef(null);\n    useImperativeHandle(ref, () => internalRef.current, []);\n    useFrame(() => internalRef.current != null && updatePointerRayModel(internalRef.current, material, props.pointer, props));\n    return (_jsx(\"mesh\", { matrixAutoUpdate: false, renderOrder: props.renderOrder ?? 2, ref: internalRef, material: material, children: _jsx(\"boxGeometry\", {}) }));\n});\n/**\n * component for rendering a cursor for a pointer\n */\nexport const PointerCursorModel = forwardRef((props, ref) => {\n    const material = useMemo(() => new PointerCursorMaterial(), []);\n    const internalRef = useRef(null);\n    useImperativeHandle(ref, () => internalRef.current, []);\n    useFrame(() => internalRef.current != null && updatePointerCursorModel(internalRef.current, material, props.pointer, props));\n    const scene = useThree((s) => s.scene);\n    return createPortal(_jsx(\"mesh\", { renderOrder: props.renderOrder ?? 1, ref: internalRef, matrixAutoUpdate: false, material: material, children: _jsx(\"planeGeometry\", {}) }), scene);\n});\n/**\n * hook for binding the xr session events such as `selectstart` to the provided pointer down/up events\n */\nexport function usePointerXRInputSourceEvents(pointer, inputSource, event, missingEvents) {\n    const session = useXR((xr) => xr.session);\n    useEffect(() => {\n        if (session == null) {\n            return;\n        }\n        return bindPointerXRInputSourceEvent(pointer, session, inputSource, event, missingEvents);\n    }, [event, inputSource, pointer, session, missingEvents]);\n}\nfunction useSetupPointer(pointer, makeDefault = false) {\n    const combinedPointer = useContext(combinedPointerContext);\n    if (combinedPointer == null) {\n        throw new Error(`xr pointers can only be used inside the XR component`);\n    }\n    useEffect(() => {\n        const unregister = combinedPointer.register(pointer, makeDefault);\n        return () => {\n            unregister();\n        };\n    }, [combinedPointer, pointer, makeDefault]);\n    useEffect(() => {\n        if (!(pointer instanceof Pointer)) {\n            return;\n        }\n        return () => pointer.exit({ timeStamp: performance.now() });\n    }, [pointer]);\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { makeTeleportTarget, TeleportPointerRayModel as TeleportPointerRayModelImpl, } from '@pmndrs/xr';\nimport { useFrame, useStore } from '@react-three/fiber';\nimport { forwardRef, useEffect, useImperativeHandle, useMemo, useRef } from 'react';\n/**\n * component that allows to declare its children as teleport targets.\n */\nexport function TeleportTarget({ children, onTeleport, }) {\n    const ref = useRef(null);\n    const teleportRef = useRef(onTeleport);\n    teleportRef.current = onTeleport;\n    const store = useStore();\n    useEffect(() => {\n        if (ref.current == null) {\n            return;\n        }\n        return makeTeleportTarget(ref.current, () => store.getState().camera, (point, event) => teleportRef.current?.(point, event));\n    }, [store]);\n    return (_jsx(\"group\", { pointerEventsType: { allow: 'teleport' }, ref: ref, children: children }));\n}\nexport const TeleportPointerRayModel = forwardRef(({ pointer, linePoints, ...options }, ref) => {\n    const mesh = useMemo(() => new TeleportPointerRayModelImpl(linePoints), [linePoints]);\n    useImperativeHandle(ref, () => mesh, [mesh]);\n    mesh.options = options;\n    useFrame(() => mesh.update(pointer));\n    return _jsx(\"primitive\", { object: mesh });\n});\n", "function shallow$1(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n  if (objA instanceof Map && objB instanceof Map) {\n    if (objA.size !== objB.size) return false;\n    for (const [key, value] of objA) {\n      if (!Object.is(value, objB.get(key))) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (objA instanceof Set && objB instanceof Set) {\n    if (objA.size !== objB.size) return false;\n    for (const value of objA) {\n      if (!objB.has(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  for (const keyA of keysA) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvar shallow = (objA, objB) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { shallow } from 'zustand/shallow'`.\"\n    );\n  }\n  return shallow$1(objA, objB);\n};\n\nexport { shallow as default, shallow$1 as shallow };\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useEffect, useMemo, useState } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport { updateXRMeshGeometry } from '@pmndrs/xr/internals';\nimport { useXR } from './xr.js';\n/**\n * component for rendering a mesh for the XRMesh based on the detected mesh geometry\n */\nexport const XRMeshModel = forwardRef(({ mesh, ...rest }, ref) => {\n    const geometry = useXRMeshGeometry(mesh);\n    return _jsx(\"mesh\", { ref: ref, geometry: geometry, ...rest });\n});\n/**\n * hook for getting all dected meshes with the provided semantic label\n */\nexport function useXRMeshes(semanticLabel) {\n    const meshes = useXR((xr) => xr.detectedMeshes);\n    return useMemo(() => (semanticLabel == null ? meshes : meshes.filter((mesh) => mesh.semanticLabel === semanticLabel)), [meshes, semanticLabel]);\n}\n/**\n * hook for getting the geometry from the detected mesh\n * @param mesh the detected mesh\n * @param disposeBuffer allows to disable auto disposing the geometry buffer\n */\nexport function useXRMeshGeometry(mesh, disposeBuffer = true) {\n    const [geometry, setGeometry] = useState(updateXRMeshGeometry(mesh, undefined));\n    useFrame(() => setGeometry((geometry) => updateXRMeshGeometry(mesh, geometry)));\n    useEffect(() => {\n        if (!disposeBuffer) {\n            return;\n        }\n        return () => geometry.dispose();\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [geometry]);\n    return geometry;\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useEffect, useMemo, useState } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport { updateXRPlaneGeometry } from '@pmndrs/xr/internals';\nimport { useXR } from './xr.js';\n/**\n * component for rendering a mesh for the XRPlane based on the detected plane geometry\n */\nexport const XRPlaneModel = forwardRef(({ plane, ...rest }, ref) => {\n    const geometry = useXRPlaneGeometry(plane);\n    return _jsx(\"mesh\", { ref: ref, geometry: geometry, ...rest });\n});\n/**\n * hook for getting all dected planes with the provided semantic label\n */\nexport function useXRPlanes(semanticLabel) {\n    const planes = useXR((xr) => xr.detectedPlanes);\n    return useMemo(() => (semanticLabel == null ? planes : planes.filter((plane) => plane.semanticLabel === semanticLabel)), [planes, semanticLabel]);\n}\n/**\n * hook for getting the geometry from the detected plane\n * @param plane the detected plane\n * @param disposeBuffer allows to disable auto disposing the geometry buffer\n */\nexport function useXRPlaneGeometry(plane, disposeBuffer = true) {\n    const [geometry, setGeometry] = useState(updateXRPlaneGeometry(plane, undefined));\n    useFrame(() => setGeometry((geometry) => updateXRPlaneGeometry(plane, geometry)));\n    useEffect(() => {\n        if (!disposeBuffer) {\n            return;\n        }\n        return () => geometry.dispose();\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [geometry]);\n    return geometry;\n}\n", "import { jsx as _jsx, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { isFacingCamera } from '@pmndrs/xr';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport { useRef, useState } from 'react';\nfunction useIsFacingCamera(ref, set, direction, angle) {\n    const camera = useThree((state) => state.camera);\n    useFrame(() => {\n        if (ref.current == null) {\n            return;\n        }\n        set(isFacingCamera(camera, ref.current, direction, angle));\n    });\n}\n/**\n * guard that only shows its shildren if the camera towards the object based on the provided angle and direction\n */\nexport function ShowIfFacingCamera({ children, direction, angle = Math.PI / 2, }) {\n    const ref = useRef(null);\n    useIsFacingCamera(ref, (visible) => {\n        if (ref.current == null) {\n            return;\n        }\n        ref.current.visible = visible;\n    }, direction, angle);\n    return _jsx(\"group\", { ref: ref, children: children });\n}\n/**\n * guard that only renders its shildren if the camera towards the object based on the provided angle and direction\n */\nexport function IfFacingCamera({ children, direction, angle = Math.PI / 2, }) {\n    const ref = useRef(null);\n    const [show, setShow] = useState(false);\n    useIsFacingCamera(ref, setShow, direction, angle);\n    return show ? _jsx(_Fragment, { children: children }) : null;\n}\n", "import { jsx as _jsx, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { useXR } from '../index.js';\nfunction useIsInSessionMode(allow, deny) {\n    const mode = useXR((state) => state.mode);\n    if (deny != null) {\n        return Array.isArray(deny) ? !deny.includes(mode) : deny != mode;\n    }\n    if (allow != null) {\n        return Array.isArray(allow) ? allow.includes(mode) : allow === mode;\n    }\n    return true;\n}\n/**\n * guard that shows its children based on the current session mode\n */\nexport function ShowIfInSessionMode({ children, allow, deny, }) {\n    const visible = useIsInSessionMode(allow, deny);\n    return _jsx(\"group\", { visible: visible, children: children });\n}\n/**\n * guard that renders its children based on the current session mode\n */\nexport function IfInSessionMode({ children, allow, deny, }) {\n    const visible = useIsInSessionMode(allow, deny);\n    return visible ? _jsx(_Fragment, { children: children }) : null;\n}\n", "import { jsx as _jsx, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { useSessionModeSupported } from '../index.js';\n/**\n * guard that only show its children if the session mode is supported\n */\nexport function ShowIfSessionModeSupported({ children, mode }) {\n    const supported = useSessionModeSupported(mode);\n    return _jsx(\"group\", { visible: supported, children: children });\n}\n/**\n * guard that only renders its visible if the session mode is supported\n */\nexport function IfSessionModeSupported({ children, mode }) {\n    const supported = useSessionModeSupported(mode);\n    if (!supported) {\n        return null;\n    }\n    return _jsx(_Fragment, { children: children });\n}\n", "import { jsx as _jsx, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { useXRSessionVisibilityState } from '../index.js';\n/**\n * guard that only makes its children visible when the session is not blurred or when not in a session\n */\nexport function ShowIfSessionVisible({ children }) {\n    const state = useXRSessionVisibilityState();\n    return _jsx(\"group\", { visible: state == null || state === 'visible', children: children });\n}\n/**\n * guard that only renders its children when the session is not blurred or when not in a session\n */\nexport function IfSessionVisible({ children }) {\n    const state = useXRSessionVisibilityState();\n    if (state != 'visible' && state != null) {\n        return null;\n    }\n    return _jsx(_Fragment, { children: children });\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useThree } from '@react-three/fiber';\nimport { forwardRef, useEffect, useImperativeHandle, useRef } from 'react';\nimport { xrSpaceContext } from './contexts.js';\nimport { useXR } from './xr.js';\n/**\n * component for setting the origin of the player (their feet)\n */\nexport const XROrigin = forwardRef(({ children, ...props }, ref) => {\n    const xrCamera = useThree((s) => s.gl.xr.getCamera());\n    const internalRef = useRef(null);\n    useImperativeHandle(ref, () => internalRef.current, []);\n    const referenceSpace = useXR((xr) => xr.originReferenceSpace);\n    useEffect(() => {\n        const group = internalRef.current;\n        if (group == null) {\n            return;\n        }\n        group.add(xrCamera);\n        return () => void group.remove(xrCamera);\n    }, [xrCamera]);\n    return (_jsx(\"group\", { ref: internalRef, ...props, children: referenceSpace != null && _jsx(xrSpaceContext.Provider, { value: referenceSpace, children: children }) }));\n});\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useCallback, useEffect, useImperativeHandle, useRef, useState } from 'react';\nimport { createXRHitTestSource, requestXRHitTest } from '@pmndrs/xr';\nimport { useXRStore } from './xr.js';\nimport { useFrame } from '@react-three/fiber';\nexport { createXRHitTestSource, requestXRHitTest } from '@pmndrs/xr';\n/**\n * hook for creating a hit test source originating from the provided object or xrspace\n */\nexport function useXRHitTestSource(relativeTo, trackableType) {\n    const [source, setState] = useState();\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useCreateXRHitTestSource(relativeTo, trackableType, setState);\n    return source;\n}\n/**\n * hook for setting up a continous hit test originating from the provided object or xrspace\n */\nexport function useXRHitTest(fn, relativeTo, trackableType) {\n    const sourceRef = useRef(undefined);\n    useCreateXRHitTestSource(relativeTo, trackableType, useCallback((source) => (sourceRef.current = source), []));\n    useFrame((_s, _d, frame) => {\n        if (fn == null || frame == null || sourceRef.current == null) {\n            return;\n        }\n        fn(frame.getHitTestResults(sourceRef.current.source), sourceRef.current.getWorldMatrix);\n    });\n}\nfunction useCreateXRHitTestSource(relativeTo, trackableType, onLoad) {\n    const store = useXRStore();\n    useEffect(() => {\n        let storedResult;\n        let cancelled = false;\n        const relativeToResolved = relativeTo instanceof XRSpace || typeof relativeTo === 'string' ? relativeTo : relativeTo?.current;\n        if (relativeToResolved == null) {\n            return;\n        }\n        createXRHitTestSource(store, relativeToResolved, trackableType).then((result) => {\n            if (cancelled) {\n                return;\n            }\n            storedResult = result;\n            onLoad(result);\n        });\n        return () => {\n            onLoad(undefined);\n            cancelled = true;\n            storedResult?.source.cancel();\n        };\n    }, [store, relativeTo, trackableType, onLoad]);\n}\n/**\n * hook that returns a function to request a single hit test\n */\nexport function useXRRequestHitTest() {\n    const store = useXRStore();\n    return useCallback((relativeTo, trackableType) => {\n        const relativeToResolved = relativeTo instanceof XRSpace || typeof relativeTo === 'string' ? relativeTo : relativeTo.current;\n        if (relativeToResolved == null) {\n            return;\n        }\n        return requestXRHitTest(store, relativeToResolved, trackableType);\n    }, [store]);\n}\n/**\n * component for getting hit tests originating based on its position in the scene graph\n */\nexport const XRHitTest = forwardRef(({ trackableType, onResults, space, ...rest }, ref) => {\n    const internalRef = useRef(null);\n    useImperativeHandle(ref, () => internalRef.current);\n    useXRHitTest(onResults, space ?? internalRef, trackableType);\n    return _jsx(\"group\", { ...rest, ref: internalRef });\n});\n", "import { requestXRAnchor } from '@pmndrs/xr';\nimport { useState, useRef, useCallback, useEffect, useMemo } from 'react';\nimport { useXRStore } from './xr.js';\nexport { requestXRAnchor,\n//requestXRPersistentAnchor,\n//loadXRPersistentAnchor,\n//deleteXRPersistentAnchor,\n } from '@pmndrs/xr';\n/**\n * hook that returns a function that allows to request a xr anchor\n */\nexport function useRequestXRAnchor() {\n    const store = useXRStore();\n    return useMemo(() => requestXRAnchor.bind(null, store), [store]);\n}\n/**\n * hook that returns a function that allows to request a xr persistent anchor\n *\nexport function useRequestXRPersistentAnchor() {\n  const store = useXRStore()\n  return useMemo(() => requestXRPersistentAnchor.bind(null, store), [store])\n}*/\n/**\n * hook that returns a function that allows to load a xr persistent anchor\n *\nexport function useLoadXRPersistentAnchor() {\n  const session = useXR((xr) => xr.session)\n  return useMemo(() => (session != null ? loadXRPersistentAnchor.bind(null, session) : undefined), [session])\n}*/\n/**\n * hook that returns a function that allows to delete a xr persistent anchor\n *\nexport function useDeleteXRPersistentAnchor() {\n  const store = useXRStore()\n  return useMemo(() => deleteXRPersistentAnchor.bind(null, store), [store])\n}*/\n/*\nexport function useXRPersistentAnchor(\n  id: string,\n): [anchor: XRAnchor | undefined, createAnchor: (options: XRAnchorOptions) => Promise<XRAnchor | undefined>] {\n  const cleanup = useRef<(() => void) | undefined>(() => {})\n  const store = useXRStore()\n  const session = useXR((xr) => xr.session)\n  const [anchor, setAnchor] = useState<XRAnchor | undefined>(undefined)\n  useEffect(() => {\n    if (session == null) {\n      return\n    }\n    cleanup.current?.()\n    cleanup.current = undefined\n    let cancelled = false\n    cleanup.current = () => (cancelled = true)\n    loadXRPersistentAnchor(session, id).then((anchor) => {\n      if (cancelled) {\n        anchor?.delete()\n        return\n      }\n      cleanup.current = () => anchor?.delete()\n      setAnchor(anchor)\n    })\n    return () => {\n      cleanup.current?.()\n      cleanup.current = undefined\n    }\n  }, [session, id])\n  const create = useCallback(\n    async (options: XRAnchorOptions) => {\n      await deleteXRPersistentAnchor(store, id)\n      cleanup.current?.()\n      cleanup.current = undefined\n      const abortRef = { current: false }\n      cleanup.current = () => (abortRef.current = true)\n      const anchor = await requestXRPersistentAnchor(store, id, options, abortRef)\n      if (abortRef.current) {\n        anchor?.delete()\n        return undefined\n      }\n      cleanup.current = () => anchor?.delete()\n      setAnchor(anchor)\n      return anchor\n    },\n    [id, store],\n  )\n  return [anchor, create]\n}*/\n/**\n * hook for requesting and storing a single xr anchor\n */\nexport function useXRAnchor() {\n    const [anchor, setAnchor] = useState(undefined);\n    const cleanup = useRef(() => { });\n    const store = useXRStore();\n    const create = useCallback(async (options) => {\n        cleanup.current?.();\n        cleanup.current = undefined;\n        let cancelled = false;\n        cleanup.current = () => (cancelled = true);\n        const anchor = await requestXRAnchor(store, options);\n        if (cancelled) {\n            anchor?.delete();\n            return undefined;\n        }\n        cleanup.current = () => anchor?.delete();\n        setAnchor(anchor);\n        return anchor;\n    }, [store]);\n    useEffect(() => () => void cleanup.current?.(), []);\n    return [anchor, create];\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useXR } from './xr.js';\nimport { forwardRef, useEffect, useMemo } from 'react';\nimport { createRoot } from 'react-dom/client';\nimport tunnel from 'tunnel-rat';\n/**\n * component to render html elements as overlay for handheld AR experiences\n */\nexport const XRDomOverlay = forwardRef((props, ref) => {\n    const domOverlayRoot = useXR((xr) => xr.domOverlayRoot);\n    const { In, Out } = useMemo(tunnel, []);\n    useEffect(() => {\n        const root = createRoot(domOverlayRoot);\n        root.render(_jsx(Out, {}));\n        return () => root.unmount();\n    }, [domOverlayRoot, Out]);\n    return (_jsx(In, { children: _jsx(\"div\", { ...props, ref: ref }) }));\n});\n", "import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { createXRLayerGeometry, updateXRLayerProperties, updateXRLayerTransform, createXRLayer, waitForXRLayerSrcSize, getXRLayerSrcTexture, setupXRImageLayer, setXRLayerRenderTarget, createXRLayerRenderTarget, } from '@pmndrs/xr';\nimport { context, reconciler, useFrame, useStore, useThree, } from '@react-three/fiber';\nimport { forwardRef, useEffect, useImperativeHandle, useMemo, useRef, useState, } from 'react';\nimport { useSessionFeatureEnabled } from './hooks.js';\nimport { useXRStore } from './xr.js';\nimport { OrthographicCamera, PerspectiveCamera, Raycaster, Scene, Vector2, Vector3, WebGLRenderTarget, } from 'three';\nimport { create } from 'zustand';\nimport { forwardObjectEvents } from '@pmndrs/pointer-events';\nexport function XRLayer({ src, pixelWidth = 1024, pixelHeight = 1024, dpr = 1, renderPriority = 0, children, ...props }) {\n    const [hasSize, setHasSize] = useState(false);\n    const ref = useRef(null);\n    const renderTargetRef = useRef(undefined);\n    const layerEntryRef = useRef(undefined);\n    useEffect(() => {\n        setHasSize(false);\n        let aborted = false;\n        waitForXRLayerSrcSize(src).then(() => !aborted && setHasSize(true));\n        return () => void (aborted = true);\n    }, [src]);\n    const layersEnabled = useSessionFeatureEnabled('layers');\n    const geometry = useMemo(() => createXRLayerGeometry(props.shape ?? 'quad', {\n        centralAngle: props.centralAngle,\n        centralHorizontalAngle: props.centralHorizontalAngle,\n        lowerVerticalAngle: props.lowerVerticalAngle,\n        upperVerticalAngle: props.upperVerticalAngle,\n    }), [props.centralAngle, props.centralHorizontalAngle, props.lowerVerticalAngle, props.shape, props.upperVerticalAngle]);\n    const store = useLayerStore(pixelWidth, pixelHeight, dpr);\n    useForwardEvents(store, ref, [hasSize, layersEnabled]);\n    if (!hasSize) {\n        return null;\n    }\n    return (_jsxs(_Fragment, { children: [src == null && (_jsx(ChildrenToRenderTarget, { store: store, renderPriority: renderPriority, renderTargetRef: renderTargetRef, layerEntryRef: layersEnabled ? layerEntryRef : undefined, children: children })), layersEnabled ? (_jsx(XRLayerImplementation, { renderTargetRef: renderTargetRef, layerEntryRef: layerEntryRef, pixelWidth: pixelWidth, pixelHeight: pixelHeight, dpr: dpr, ref: ref, ...props, src: src, geometry: geometry })) : (_jsx(FallbackXRLayerImplementation, { renderTargetRef: renderTargetRef, ref: ref, ...props, src: src, pixelWidth: pixelWidth, pixelHeight: pixelHeight, dpr: dpr, geometry: geometry }))] }));\n}\nexport const XRLayerImplementation = forwardRef(({ src, shape, colorFormat, depthFormat, layout, mipLevels, renderOrder = 0, blendTextureSourceAlpha, centralAngle, centralHorizontalAngle, chromaticAberrationCorrection, lowerVerticalAngle, quality, upperVerticalAngle, invertStereo, pixelWidth, pixelHeight, dpr, renderTargetRef, layerEntryRef, ...props }, ref) => {\n    const internalRef = useRef(null);\n    const renderer = useThree((state) => state.gl);\n    const store = useXRStore();\n    const layerProperties = {\n        blendTextureSourceAlpha,\n        centralAngle,\n        centralHorizontalAngle,\n        chromaticAberrationCorrection,\n        lowerVerticalAngle,\n        quality,\n        upperVerticalAngle,\n    };\n    const layerPropertiesRef = useRef(layerProperties);\n    layerPropertiesRef.current = layerProperties;\n    const renderOrderRef = useRef(renderOrder);\n    renderOrderRef.current = renderOrder;\n    //create layer\n    useEffect(() => {\n        if (internalRef.current == null) {\n            return;\n        }\n        const resolvedSrc = src ?? (renderTargetRef.current = createXRLayerRenderTarget(pixelWidth, pixelHeight, dpr));\n        const layer = createXRLayer(resolvedSrc, store.getState(), renderer.xr, internalRef.current, {\n            colorFormat,\n            depthFormat,\n            invertStereo,\n            layout,\n            mipLevels,\n            shape,\n        }, layerPropertiesRef.current);\n        if (layer == null) {\n            return;\n        }\n        const layerEntry = (layerEntryRef.current = { layer, renderOrder: renderOrderRef.current });\n        store.addLayerEntry(layerEntry);\n        if (resolvedSrc instanceof HTMLVideoElement || resolvedSrc instanceof WebGLRenderTarget) {\n            return () => {\n                store.removeLayerEntry(layerEntry);\n                layer.destroy();\n            };\n        }\n        const cleanupXRImageLayer = setupXRImageLayer(renderer, store, layer, resolvedSrc);\n        return () => {\n            store.removeLayerEntry(layerEntry);\n            cleanupXRImageLayer();\n            layer.destroy();\n        };\n    }, [\n        colorFormat,\n        depthFormat,\n        invertStereo,\n        layerEntryRef,\n        layout,\n        mipLevels,\n        pixelHeight,\n        pixelWidth,\n        dpr,\n        renderTargetRef,\n        renderer,\n        shape,\n        src,\n        store,\n    ]);\n    //update render order\n    if (layerEntryRef.current != null) {\n        layerEntryRef.current.renderOrder = renderOrder;\n    }\n    //update layer properties\n    if (layerEntryRef.current != null) {\n        updateXRLayerProperties(layerEntryRef.current.layer, layerPropertiesRef.current);\n    }\n    //update layer transform\n    useFrame(() => {\n        if (layerEntryRef.current == null || internalRef.current == null) {\n            return;\n        }\n        updateXRLayerTransform(store.getState(), layerEntryRef.current.layer, layerPropertiesRef.current.centralAngle, internalRef.current);\n    });\n    useImperativeHandle(ref, () => internalRef.current, []);\n    return (_jsx(\"mesh\", { ...props, renderOrder: -Infinity, ref: internalRef, children: _jsx(\"meshBasicMaterial\", { colorWrite: false }) }));\n});\nexport const FallbackXRLayerImplementation = forwardRef(({ src, renderTargetRef, dpr, renderOrder, pixelWidth, pixelHeight, ...props }, ref) => {\n    const materialRef = useRef(null);\n    useEffect(() => {\n        if (materialRef.current == null) {\n            return;\n        }\n        const resolvedSrc = src ?? (renderTargetRef.current = createXRLayerRenderTarget(pixelWidth, pixelHeight, dpr));\n        const texture = getXRLayerSrcTexture(resolvedSrc);\n        materialRef.current.map = texture;\n        materialRef.current.needsUpdate = true;\n        return () => {\n            if (resolvedSrc instanceof WebGLRenderTarget) {\n                resolvedSrc.dispose();\n                return;\n            }\n            texture.dispose();\n        };\n    }, [src, pixelWidth, pixelHeight, dpr, renderTargetRef]);\n    return (_jsx(\"mesh\", { ref: ref, ...props, children: _jsx(\"meshBasicMaterial\", { ref: materialRef, toneMapped: false }) }));\n});\nfunction useForwardEvents(store, ref, deps) {\n    useEffect(() => {\n        const { current } = ref;\n        if (current == null) {\n            return;\n        }\n        let cleanup;\n        const update = (state, prevState) => {\n            if (state.camera === prevState?.camera && state.scene === prevState.scene) {\n                return;\n            }\n            cleanup?.();\n            cleanup = forwardObjectEvents(current, state.camera, state.scene);\n        };\n        update(store.getState());\n        const unsubscribe = store.subscribe(update);\n        return () => {\n            unsubscribe();\n            cleanup?.();\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [store, ref, ...deps]);\n}\n// Keys that shouldn't be copied between R3F stores\nexport const privateKeys = [\n    'set',\n    'get',\n    'setSize',\n    'setFrameloop',\n    'setDpr',\n    'events',\n    'invalidate',\n    'advance',\n    'size',\n    'viewport',\n];\nexport function useLayerStore(width, height, dpr) {\n    const previousRoot = useStore();\n    const layerStore = useMemo(() => {\n        let previousState = previousRoot.getState();\n        // We have our own camera in here, separate from the main scene.\n        const camera = new PerspectiveCamera(50, 1, 0.1, 1000);\n        camera.position.set(0, 0, 5);\n        const pointer = new Vector2();\n        let ownState = {\n            events: { enabled: false, priority: 0 },\n            size: { width: 1, height: 1, left: 0, top: 0 },\n            camera,\n            scene: new Scene(),\n            raycaster: new Raycaster(),\n            pointer: pointer,\n            mouse: pointer,\n            previousRoot,\n        };\n        //we now merge in order previousState, injectState, ownState\n        const store = create((innerSet, get) => {\n            const merge = () => {\n                const result = {};\n                for (const key in previousState) {\n                    if (privateKeys.includes(key)) {\n                        continue;\n                    }\n                    result[key] = previousState[key];\n                }\n                return Object.assign(result, ownState, {\n                    events: { ...previousState.events, ...ownState.events },\n                    viewport: Object.assign({}, previousState.viewport, previousState.viewport.getCurrentViewport(camera, new Vector3(), ownState.size)),\n                });\n            };\n            const update = () => innerSet(merge());\n            return {\n                ...previousState,\n                // Set and get refer to this root-state\n                set(newOwnState) {\n                    if (typeof newOwnState === 'function') {\n                        newOwnState = newOwnState(get());\n                    }\n                    Object.assign(ownState, newOwnState);\n                    update();\n                },\n                setPreviousState(prevState) {\n                    previousState = prevState;\n                    update();\n                },\n                get,\n                setEvents() { },\n                ...merge(),\n            };\n        });\n        return Object.assign(store, {\n            setState(state) {\n                store.getState().set(state);\n            },\n        });\n    }, [previousRoot]);\n    //syncing up previous store with the current store\n    useEffect(() => previousRoot.subscribe(layerStore.getState().setPreviousState), [previousRoot, layerStore]);\n    useEffect(() => {\n        const viewport = {\n            factor: 1,\n            distance: 0,\n            dpr,\n            initialDpr: dpr,\n            left: 0,\n            top: 0,\n            getCurrentViewport: () => viewport,\n            width,\n            height,\n            aspect: width / height,\n        };\n        layerStore.setState({\n            size: { width, height, top: 0, left: 0 },\n            viewport,\n        });\n    }, [width, height, dpr, layerStore, previousRoot]);\n    return layerStore;\n}\nfunction ChildrenToRenderTarget({ renderPriority, children, layerEntryRef, renderTargetRef, store, }) {\n    useEffect(() => {\n        const update = (state, prevState) => {\n            const { size, camera } = state;\n            if (camera instanceof OrthographicCamera) {\n                camera.left = size.width / -2;\n                camera.right = size.width / 2;\n                camera.top = size.height / 2;\n                camera.bottom = size.height / -2;\n            }\n            else {\n                camera.aspect = size.width / size.height;\n            }\n            if (size !== prevState?.size || camera !== prevState.camera) {\n                camera.updateProjectionMatrix();\n                // https://github.com/pmndrs/react-three-fiber/issues/178\n                // Update matrix world since the renderer is a frame late\n                camera.updateMatrixWorld();\n            }\n        };\n        update(store.getState());\n        return store.subscribe(update);\n    }, [store]);\n    let oldAutoClear;\n    let oldXrEnabled;\n    let oldIsPresenting;\n    let oldRenderTarget;\n    //TODO: support frameloop=\"demand\"\n    useFrame((_state, _delta, frame) => {\n        if (renderTargetRef.current == null ||\n            (layerEntryRef != null && (layerEntryRef.current == null || frame == null))) {\n            return;\n        }\n        const { gl, scene, camera } = store.getState();\n        oldAutoClear = gl.autoClear;\n        oldXrEnabled = gl.xr.enabled;\n        oldIsPresenting = gl.xr.isPresenting;\n        oldRenderTarget = gl.getRenderTarget();\n        gl.autoClear = true;\n        gl.xr.enabled = false;\n        gl.xr.isPresenting = false;\n        const renderTarget = renderTargetRef.current;\n        setXRLayerRenderTarget(gl, renderTarget, layerEntryRef?.current, frame);\n        gl.render(scene, camera);\n        gl.setRenderTarget(oldRenderTarget);\n        gl.autoClear = oldAutoClear;\n        gl.xr.enabled = oldXrEnabled;\n        gl.xr.isPresenting = oldIsPresenting;\n    }, renderPriority);\n    return _jsx(_Fragment, { children: reconciler.createPortal(_jsx(context.Provider, { value: store, children: children }), store, null) });\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef } from 'react';\nimport { useSessionModeSupported } from '../hooks.js';\nimport { useStore } from 'zustand';\n/**\n * @deprecated use <button onClick={() => store.enterXR()}> instead\n */\nexport const XRButton = forwardRef(({ store, mode, onError, children, ...props }, ref) => {\n    const session = useStore(store, (xr) => xr.session);\n    const supported = useSessionModeSupported(mode, onError);\n    return (_jsx(\"button\", { ref: ref, ...props, onClick: () => (session != null ? session.end() : store.enterXR(mode).catch(onError)), children: typeof children === 'function'\n            ? children(supported ? (session != null ? 'entered' : 'exited') : 'unsupported')\n            : children }));\n});\n/**\n * @deprecated use <button onClick={() => store.enterAR()}> instead\n */\nexport const ARButton = forwardRef((props, ref) => {\n    return _jsx(XRButton, { ref: ref, mode: \"immersive-ar\", ...props });\n});\n/**\n * @deprecated use <button onClick={() => store.enterVR()}> instead\n */\nexport const VRButton = forwardRef((props, ref) => {\n    return _jsx(XRButton, { ref: ref, mode: \"immersive-vr\", ...props });\n});\n", "import { useEffect, useRef } from 'react';\nimport { PointerEvent } from '@pmndrs/pointer-events';\nimport { useXR } from '../xr.js';\nimport { useXRInputSourceState, useXRInputSourceStateContext } from '../input.js';\nimport { useXRSpace } from '../space.js';\nconst eventTranslations = {\n    onBlur: 'pointerleave',\n    onHover: 'pointerenter',\n    onMove: 'pointermove',\n    onSelect: {\n        type: 'click',\n        filter: (e) => e.pointerType === 'ray',\n    },\n    onSelectEnd: {\n        type: 'pointerup',\n        filter: (e) => e.pointerType === 'ray',\n    },\n    onSelectStart: {\n        type: 'pointerdown',\n        filter: (e) => e.pointerType === 'ray',\n    },\n    onSqueeze: {\n        type: 'click',\n        filter: (e) => e.pointerType === 'grab',\n    },\n    onSqueezeEnd: {\n        type: 'pointerup',\n        filter: (e) => e.pointerType === 'grab',\n    },\n    onSqueezeStart: {\n        type: 'pointerdown',\n        filter: (e) => e.pointerType === 'grab',\n    },\n};\n/**\n * @deprecated use normal react-three/fiber event listeners instead (e.g. <mesh onClick={...} />)\n */\nexport function useInteraction(ref, type, handler) {\n    const handlerRef = useRef(handler);\n    handlerRef.current = handler;\n    useEffect(() => {\n        const { current } = ref;\n        if (current == null) {\n            return;\n        }\n        const translation = eventTranslations[type];\n        const fn = typeof translation === 'string'\n            ? (event) => handlerRef.current?.({ intersection: event, intersections: [event], target: event.pointerState })\n            : (event) => {\n                if (event instanceof PointerEvent && !translation.filter(event)) {\n                    return;\n                }\n                handlerRef.current?.({ intersection: event, intersections: [event], target: event.pointerState });\n            };\n        const eventName = typeof translation === 'string' ? translation : translation.type;\n        current.addEventListener(eventName, fn);\n        return () => current.removeEventListener(eventName, fn);\n    }, [ref, type]);\n}\n/**\n * @deprecated\n */\nexport function useXREvent(type, handler, { handedness } = {}) {\n    const session = useXR((xr) => xr.session);\n    const handlerRef = useRef(handler);\n    handlerRef.current = handler;\n    useEffect(() => {\n        if (session == null) {\n            return;\n        }\n        const fn = (e) => {\n            handlerRef.current?.({\n                type: e.type,\n                data: e.inputSource,\n            });\n        };\n        session.addEventListener(type, fn);\n        return session.removeEventListener(type, fn);\n    }, [session, handedness, type]);\n}\nexport function useXRTransientPointerState(handedness) {\n    return handedness == null\n        ? // eslint-disable-next-line react-hooks/rules-of-hooks\n            useXRInputSourceStateContext('transientPointer')\n        : // eslint-disable-next-line react-hooks/rules-of-hooks\n            useXRInputSourceState('transientPointer', handedness);\n}\n/**\n * @deprecated use `useXRInputSourceStateContext(\"gaze\")` instead\n * hook for getting the gaze state\n */\nexport function useXRGazeState() {\n    return useXRInputSourceStateContext('gaze');\n}\n/**\n * @deprecated `useXRInputSourceStateContext(\"screenInput\")` instead\n * hook for getting the screen-input state\n */\nexport function useXRScreenInputState() {\n    return useXRInputSourceStateContext('screenInput');\n}\nexport function useXRHandState(handedness) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return handedness == null ? useXRInputSourceStateContext('hand') : useXRInputSourceState('hand', handedness);\n}\nexport function useXRControllerState(handedness) {\n    return handedness == null\n        ? // eslint-disable-next-line react-hooks/rules-of-hooks\n            useXRInputSourceStateContext('controller')\n        : // eslint-disable-next-line react-hooks/rules-of-hooks\n            useXRInputSourceState('controller', handedness);\n}\n/**\n * @deprecated use useXRSpace instead\n */\nexport const useXRReferenceSpace = useXRSpace;\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useImperativeHandle, useRef } from 'react';\nimport { useInteraction } from './hooks.js';\n/**\n * @deprecated just use <group onClick/... />\n */\nexport const Interactive = forwardRef(({ onHover, onBlur, onSelectStart, onSelectEnd, onSelect, onSqueezeStart, onSqueezeEnd, onSqueeze, onMove, children, }, passedRef) => {\n    const ref = useRef(null);\n    useImperativeHandle(passedRef, () => ref.current);\n    useInteraction(ref, 'onHover', onHover);\n    useInteraction(ref, 'onBlur', onBlur);\n    useInteraction(ref, 'onSelectStart', onSelectStart);\n    useInteraction(ref, 'onSelectEnd', onSelectEnd);\n    //useInteraction(ref, 'onSelectMissed', onSelectMissed)\n    useInteraction(ref, 'onSelect', onSelect);\n    useInteraction(ref, 'onSqueezeStart', onSqueezeStart);\n    useInteraction(ref, 'onSqueezeEnd', onSqueezeEnd);\n    //useInteraction(ref, 'onSqueezeMissed', onSqueezeMissed)\n    useInteraction(ref, 'onSqueeze', onSqueeze);\n    useInteraction(ref, 'onMove', onMove);\n    return _jsx(\"group\", { ref: ref, children: children });\n});\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { forwardRef, useImperativeHandle, useMemo, useRef } from 'react';\nimport { Interactive } from './interactive.js';\nimport { Matrix4 } from 'three';\nimport { useFrame } from '@react-three/fiber';\nimport { isXRInputSourceState } from '@pmndrs/xr/internals';\n/**\n * @deprecated use DragControls instead\n */\nexport const RayGrab = forwardRef(function RayGrab({ onSelectStart, onSelectEnd, children, ...rest }, forwardedRef) {\n    const grabbingController = useRef();\n    const groupRef = useRef(null);\n    const previousTransform = useMemo(() => new Matrix4(), []);\n    useImperativeHandle(forwardedRef, () => groupRef.current);\n    useFrame(() => {\n        const controller = grabbingController.current;\n        const group = groupRef.current;\n        if (!group || !controller)\n            return;\n        group.applyMatrix4(previousTransform);\n        group.applyMatrix4(controller.matrixWorld);\n        group.updateMatrixWorld();\n        previousTransform.copy(controller.matrixWorld).invert();\n    });\n    return (_jsx(Interactive, { ref: groupRef, onSelectStart: (e) => {\n            if (isXRInputSourceState(e.target) &&\n                (e.target.type === 'controller' || e.target.type === 'hand') &&\n                e.target.object != null) {\n                grabbingController.current = e.target.object;\n                previousTransform.copy(e.target.object.matrixWorld).invert();\n                onSelectStart?.(e);\n            }\n        }, onSelectEnd: (e) => {\n            if (e.target.controller === grabbingController.current) {\n                grabbingController.current = undefined;\n            }\n            onSelectEnd?.(e);\n        }, ...rest, children: children }));\n});\n"],
  "mappings": "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",
  "names": ["import_jsx_runtime", "i", "i", "self", "res", "joints", "clone", "URL", "sourceURI", "node", "accessor", "i", "clone", "i", "i", "event", "i", "i", "enterXR", "_a", "i", "start", "end", "i", "i", "i", "i", "length", "i", "invertedMatrixHelper", "intersectsHelper", "matrixHelper", "planeHelper", "intersectsHelper", "planeHelper", "invertedMatrixHelper", "matrixHelper", "i", "intersection", "pointerMap", "i", "length", "matrixHelper", "scaleHelper", "vectorHelper", "quaternionHelper", "context", "vectorHelper", "directionHelper", "quaternionHelper", "quaternionHelper", "i", "matrixHelper", "vectorHelper", "quaternionHelper", "matrixHelper2", "quaternionHelper", "positionHelper", "vectorHelper", "i", "import_react", "import_jsx_runtime", "import_react", "import_jsx_runtime", "import_react", "map", "import_react", "import_jsx_runtime", "import_react", "import_react", "import_react", "state", "XRControllerModel", "_jsx", "import_jsx_runtime", "import_react", "XRHandModel", "_jsx", "XRSpace", "import_jsx_runtime", "import_react", "CombinedPointer", "_jsx", "PointerRayModel", "PointerCursorModel", "import_jsx_runtime", "import_react", "_jsx", "TeleportPointerRayModel", "_jsx", "XRSpace", "PointerCursorModel", "_jsxs", "PointerRayModel", "_Fragment", "XRControllerModel", "CombinedPointer", "XRHandModel", "state", "TeleportPointerRayModel", "_jsx", "_Fragment", "_jsxs", "XRSpace", "spreadable", "createXRStore", "_jsx", "_jsxs", "useStore", "XRSpace", "_jsx", "context", "import_jsx_runtime", "import_react", "_jsx", "geometry", "import_jsx_runtime", "import_react", "_jsx", "geometry", "import_jsx_runtime", "import_react", "_jsx", "_Fragment", "import_jsx_runtime", "_jsx", "_Fragment", "import_jsx_runtime", "_jsx", "_Fragment", "import_jsx_runtime", "_jsx", "_Fragment", "import_jsx_runtime", "import_react", "_jsx", "import_jsx_runtime", "import_react", "_jsx", "import_react", "create", "anchor", "import_jsx_runtime", "import_react", "_jsx", "import_jsx_runtime", "import_react", "_jsxs", "_Fragment", "_jsx", "import_jsx_runtime", "import_react", "useStore", "_jsx", "import_react", "import_jsx_runtime", "import_react", "_jsx", "import_jsx_runtime", "import_react", "RayGrab", "_jsx"]
}
