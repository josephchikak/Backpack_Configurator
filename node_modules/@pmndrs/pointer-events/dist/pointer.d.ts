import { Object3D } from 'three';
import { Intersection } from './intersections/index.js';
import { NativeEvent, NativeWheelEvent } from './event.js';
import { Intersector } from './intersections/intersector.js';
declare const buttonsDownTimeKey: unique symbol;
declare const buttonsClickTimeKey: unique symbol;
export type AllowedPointerEvents = 'none' | 'auto' | 'listener';
export type ButtonsTime = Map<number, number>;
export type AllowedPointerEventsType = 'all' | ((poinerId: number, pointerType: string, pointerState: unknown) => boolean) | {
    allow: string | Array<string>;
} | {
    deny: string | Array<string>;
};
declare module 'three' {
    interface Object3D {
        _listeners?: Record<string, Array<(event: unknown) => void> | undefined>;
        /**
         * @default "listener"
         */
        pointerEvents?: AllowedPointerEvents;
        /**
         * @default "all"
         */
        pointerEventsType?: AllowedPointerEventsType;
        /**
         * @default 0
         * sorted by highest number first
         * (just like a higher renderOrder number will result in rendering over the previous - if depthTest is false)
         */
        pointerEventsOrder?: number;
        [buttonsDownTimeKey]?: ButtonsTime;
        [buttonsClickTimeKey]?: ButtonsTime;
    }
}
export type PointerCapture = {
    object: Object3D;
    intersection: Intersection;
};
export type PointerOptions = {
    /**
     * @default 300
     */
    clickThesholdMs?: number;
    /**
     * @default 500
     */
    dblClickThresholdMs?: number;
    /**
     * @default 2
     */
    contextMenuButton?: number;
};
declare module 'three' {
    interface Object3D {
        setPointerCapture(pointerId: number): void;
        releasePointerCapture(pointerId: number): void;
        hasPointerCapture(pointerId: number): boolean;
    }
}
export declare function getPointerById(pointerId: number): Pointer | undefined;
export declare class Pointer {
    readonly id: number;
    readonly type: string;
    readonly state: any;
    readonly intersector: Intersector;
    private readonly onMoveCommited?;
    private readonly parentSetPointerCapture?;
    private readonly parentReleasePointerCapture?;
    private readonly options;
    private prevIntersection;
    private intersection;
    private prevEnabled;
    private enabled;
    /**
     * ordered leaf -> root (bottom -> top)
     */
    private pointerEntered;
    private pointerEnteredHelper;
    private pointerCapture;
    private buttonsDownTime;
    private readonly buttonsDown;
    private wasMoved;
    private onFirstMove;
    constructor(id: number, type: string, state: any, intersector: Intersector, onMoveCommited?: ((pointer: Pointer) => void) | undefined, parentSetPointerCapture?: (() => void) | undefined, parentReleasePointerCapture?: (() => void) | undefined, options?: PointerOptions);
    getPointerCapture(): PointerCapture | undefined;
    hasCaptured(object: Object3D): boolean;
    setCapture(object: Object3D | undefined): void;
    getButtonsDown(): ReadonlySet<number>;
    getIntersection(): Intersection | undefined;
    getEnabled(): boolean;
    setEnabled(enabled: boolean, nativeEvent: NativeEvent, commit?: boolean): void;
    private computeIntersection;
    setIntersection(intersection: Intersection | undefined): void;
    /**
     * allows to separately compute and afterwards commit a move
     * => do not forget to call commitMove after computeMove
     * can be used to compute the current intersection and disable or enable the pointer before commiting the move
     */
    computeMove(scene: Object3D, nativeEvent: NativeEvent): void;
    commit(nativeEvent: NativeEvent): void;
    /**
     * computes and commits a move
     */
    move(scene: Object3D, nativeEvent: NativeEvent): void;
    down(nativeEvent: NativeEvent & {
        button: number;
    }): void;
    up(nativeEvent: NativeEvent & {
        button: number;
    }): void;
    cancel(nativeEvent: NativeEvent): void;
    wheel(scene: Object3D, nativeEvent: NativeWheelEvent, useCurrentIntersection: boolean): void;
    exit(nativeEvent: NativeEvent): void;
}
export {};
