import { hasObjectListeners } from '../utils.js';
export function computeIntersectionWorldPlane(target, intersection, object) {
    if (intersection.face == null) {
        return false;
    }
    target.setFromNormalAndCoplanarPoint(intersection.face.normal, intersection.localPoint);
    target.applyMatrix4(object.matrixWorld);
    return true;
}
function isPointerEventsAllowed(hasListener, pointerEvents, pointerEventsType) {
    if (pointerEvents === 'none') {
        return false;
    }
    if (pointerEvents === 'listener' && !hasListener) {
        return false;
    }
    if (pointerEventsType === 'all') {
        return true;
    }
    if (typeof pointerEventsType === 'function') {
        return ({ id, type, state }) => pointerEventsType(id, type, state);
    }
    let value;
    let invert;
    if ('deny' in pointerEventsType) {
        invert = true;
        value = pointerEventsType.deny;
    }
    else {
        invert = false;
        value = pointerEventsType.allow;
    }
    if (Array.isArray(value)) {
        return (pointer) => invertIf(value.includes(pointer.type), invert);
    }
    return (pointer) => invertIf(value === pointer.type, invert);
}
function invertIf(toInvert, ifIsTrue) {
    return ifIsTrue ? !toInvert : toInvert;
}
export function intersectPointerEventTargets(object, pointers, parentHasListener = false, parentPointerEvents, parentPointerEventsType, parentPointerEventsOrder) {
    const hasListener = parentHasListener || hasObjectListeners(object);
    const pointerEvents = object.pointerEvents ?? parentPointerEvents ?? 'listener';
    const pointerEventsType = object.pointerEventsType ?? parentPointerEventsType ?? 'all';
    const pointerEventsOrder = object.pointerEventsOrder ?? parentPointerEventsOrder;
    const isAllowed = isPointerEventsAllowed(hasListener, pointerEvents, pointerEventsType);
    const length = pointers.length;
    if (isAllowed === true) {
        for (let i = 0; i < length; i++) {
            pointers[i].intersector.executeIntersection(object, pointerEventsOrder);
        }
    }
    else if (typeof isAllowed === 'function') {
        for (let i = 0; i < length; i++) {
            const pointer = pointers[i];
            if (!isAllowed(pointer)) {
                continue;
            }
            pointers[i].intersector.executeIntersection(object, pointerEventsOrder);
        }
    }
    const childrenLength = object.children.length;
    for (let i = 0; i < childrenLength; i++) {
        intersectPointerEventTargets(object.children[i], pointers, hasListener, pointerEvents, pointerEventsType, pointerEventsOrder);
    }
}
/**
 * @returns undefined if `i1` is the dominant intersection
 * @param i2DistanceOffset modifies i2 and adds the i2DistanceOffset to the current distance
 */
export function getDominantIntersectionIndex(i1, pointerEventsOrder1, i2, pointerEventsOrder2, { customFilter, customSort: compare = defaultSort } = {}) {
    let index = undefined;
    const length = i2.length;
    for (let i = 0; i < length; i++) {
        const intersection = i2[i];
        if (!(customFilter?.(intersection) ?? true)) {
            continue;
        }
        if (i1 == null || compare(i1, pointerEventsOrder1, intersection, pointerEventsOrder2) > 0) {
            i1 = intersection;
            index = i;
        }
    }
    return index;
}
/**
 * @returns a negative number if i1 should be sorted before i2
 */
function defaultSort(i1, pointerEventsOrder1 = 0, i2, pointerEventsOrder2 = 0) {
    if (pointerEventsOrder1 != pointerEventsOrder2) {
        //inverted order because order is sorted highest first
        return pointerEventsOrder2 - pointerEventsOrder1;
    }
    //i1 - i2 because negative values mean the sorting i1 before i2 is correct
    return i1.distance - i2.distance;
}
